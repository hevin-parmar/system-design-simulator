{
  "version": "1.0",
  "components": [
    {
      "id": "dns",
      "name": "DNS",
      "category": "edge",
      "purpose": "Routes users to the closest/healthy endpoint; supports geo and failover.",
      "inputs": ["client-dns-query"],
      "outputs": ["ip-or-cname"],
      "knobs": ["ttlSeconds", "healthChecks", "geoRouting", "weightedRouting"],
      "commonFailureModes": ["stale records due to TTL", "misconfigured routing causing traffic imbalance"],
      "interviewHooks": ["How do you do failover? TTL tradeoff? Split traffic for migration?"],
      "synonyms": ["Route 53", "Cloud DNS", "Azure DNS"]
    },
    {
      "id": "cdn",
      "name": "CDN",
      "category": "edge",
      "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
      "inputs": ["http"],
      "outputs": ["http"],
      "knobs": ["cacheTTL", "cacheKey", "staleWhileRevalidate", "purge", "geoRestrictions"],
      "commonFailureModes": ["cache poisoning", "stale content", "origin overload when cache miss spikes"],
      "interviewHooks": ["What do you cache? How do you invalidate? Cache key design?"],
      "synonyms": ["CloudFront", "Akamai", "Fastly", "Cloud CDN", "Azure CDN"]
    },
    {
      "id": "waf",
      "name": "WAF",
      "category": "security",
      "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
      "inputs": ["http"],
      "outputs": ["http"],
      "knobs": ["rules", "botProtection", "ipAllowDeny", "rateRules"],
      "commonFailureModes": ["false positives blocking good traffic", "rules drift"],
      "interviewHooks": ["How do you tune rules? Whatâ€™s your rollout strategy?"],
      "synonyms": ["WAF", "Cloud Armor", "AWS WAF", "Azure WAF"]
    },
    {
      "id": "edge-rate-limiter",
      "name": "Rate Limiter",
      "category": "reliability",
      "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
      "inputs": ["http", "rpc"],
      "outputs": ["http", "rpc"],
      "knobs": ["limitKey", "limits", "burst", "window", "tokenBucket", "leakyBucket"],
      "commonFailureModes": ["hot keys on limiter storage", "incorrect keying causing unfair limits"],
      "interviewHooks": ["Token bucket vs fixed window? Distributed rate limiting?"],
      "synonyms": ["rate limiter", "throttling", "API throttling"]
    },
    {
      "id": "api-gateway",
      "name": "API Gateway",
      "category": "edge",
      "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
      "inputs": ["http"],
      "outputs": ["rpc", "http"],
      "knobs": ["routes", "auth", "quotas", "timeouts", "payloadLimits"],
      "commonFailureModes": ["single point of failure", "misconfigured routing", "latency overhead"],
      "interviewHooks": ["Why gateway vs LB only? How do you avoid SPOF?"],
      "synonyms": ["API gateway", "APIM", "Kong", "Envoy gateway"]
    },
    {
      "id": "load-balancer-l7",
      "name": "Load Balancer (L7)",
      "category": "edge",
      "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
      "inputs": ["http"],
      "outputs": ["http"],
      "knobs": ["algorithm", "healthChecks", "timeouts", "connectionDraining"],
      "commonFailureModes": ["bad health checks flapping", "uneven load distribution"],
      "interviewHooks": ["Round-robin vs least-connections? L4 vs L7?"],
      "synonyms": ["ALB", "Ingress", "HTTP load balancer"]
    },
    {
      "id": "load-balancer-l4",
      "name": "Load Balancer (L4)",
      "category": "edge",
      "purpose": "Distributes TCP/UDP traffic; lower overhead; no HTTP-aware routing.",
      "inputs": ["tcp", "udp"],
      "outputs": ["tcp", "udp"],
      "knobs": ["algorithm", "healthChecks", "timeouts"],
      "commonFailureModes": ["connection tracking limits", "no app-aware routing"],
      "interviewHooks": ["When pick L4 over L7? Impact on TLS termination?"],
      "synonyms": ["NLB", "TCP load balancer"]
    },
    {
      "id": "auth-service",
      "name": "Auth Service",
      "category": "security",
      "purpose": "Issues/validates credentials (sessions, tokens); enforces authentication flows.",
      "inputs": ["http", "rpc"],
      "outputs": ["token", "session", "claims"],
      "knobs": ["tokenTTL", "refreshTTL", "rotation", "mfa"],
      "commonFailureModes": ["token replay if not bound", "clock skew issues", "session store overload"],
      "interviewHooks": ["JWT vs session? Revocation? Rotation?"],
      "synonyms": ["OAuth server", "Auth0", "Cognito", "Identity provider", "OIDC"]
    },
    {
      "id": "policy-authorization",
      "name": "Authorization (Policy Engine)",
      "category": "security",
      "purpose": "Evaluates permissions/roles/attributes for access control decisions.",
      "inputs": ["claims", "resource", "action"],
      "outputs": ["allow/deny"],
      "knobs": ["policyModel", "caching", "audit"],
      "commonFailureModes": ["policy drift", "overly broad permissions"],
      "interviewHooks": ["RBAC vs ABAC? Where enforced? Audit trail?"],
      "synonyms": ["RBAC", "ABAC", "OPA", "policy engine"]
    },
    {
      "id": "web-app",
      "name": "Web App / UI",
      "category": "client",
      "purpose": "Client-facing UI; calls APIs; manages user interactions.",
      "inputs": ["user-actions"],
      "outputs": ["http"],
      "knobs": ["cache", "prefetch", "offlineMode"],
      "commonFailureModes": ["stale UI state", "over-fetching"],
      "interviewHooks": ["How do you optimize roundtrips? Error handling?"],
      "synonyms": ["frontend", "web client"]
    },
    {
      "id": "mobile-app",
      "name": "Mobile App",
      "category": "client",
      "purpose": "Mobile client; often needs offline, battery-aware, flaky-network handling.",
      "inputs": ["user-actions"],
      "outputs": ["http"],
      "knobs": ["retryPolicy", "offlineQueue", "backgroundSync"],
      "commonFailureModes": ["duplicate submissions on retry", "out-of-date caches"],
      "interviewHooks": ["Idempotency keys? Offline-first?"],
      "synonyms": ["iOS app", "Android app", "mobile client"]
    },

    {
      "id": "app-service",
      "name": "App Service",
      "category": "compute",
      "purpose": "Core business logic service handling requests and orchestrating dependencies.",
      "inputs": ["http", "rpc"],
      "outputs": ["rpc", "db-read", "db-write", "async-produce"],
      "knobs": ["autoscaling", "timeouts", "retries", "circuitBreaker"],
      "commonFailureModes": ["dependency timeouts cascading", "resource exhaustion", "thundering herd"],
      "interviewHooks": ["Timeout budgets? Bulkheads? Retries with jitter?"],
      "synonyms": ["application server", "API server", "backend service"]
    },
    {
      "id": "worker",
      "name": "Worker",
      "category": "compute",
      "purpose": "Consumes async jobs/events; performs background processing.",
      "inputs": ["async-consume"],
      "outputs": ["db-write", "object-write", "async-produce"],
      "knobs": ["concurrency", "retries", "idempotency", "batchSize"],
      "commonFailureModes": ["poison messages", "retry storms", "duplicate processing"],
      "interviewHooks": ["At-least-once semantics? DLQ strategy? Idempotency design?"],
      "synonyms": ["consumer", "job runner", "background processor"]
    },
    {
      "id": "scheduler",
      "name": "Scheduler",
      "category": "compute",
      "purpose": "Runs periodic jobs (cleanup, compaction, rollups, batch pipelines).",
      "inputs": ["time"],
      "outputs": ["async-produce"],
      "knobs": ["interval", "jitter", "backfill", "lock"],
      "commonFailureModes": ["double-run without locking", "missed runs", "clock skew"],
      "interviewHooks": ["Leader election? Exactly-once scheduling?"],
      "synonyms": ["cron", "job scheduler"]
    },

    {
      "id": "queue",
      "name": "Queue",
      "category": "messaging",
      "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
      "inputs": ["async-produce"],
      "outputs": ["async-consume"],
      "knobs": ["visibilityTimeout", "maxRetries", "dlq", "fifo", "orderingKey"],
      "commonFailureModes": ["backlog growth", "duplicate delivery", "hot partitions (FIFO)"],
      "interviewHooks": ["At-least-once vs exactly-once? Backpressure? DLQ?"],
      "synonyms": ["SQS", "RabbitMQ queue", "task queue", "job queue"]
    },
    {
      "id": "pubsub",
      "name": "Pub/Sub",
      "category": "messaging",
      "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
      "inputs": ["event"],
      "outputs": ["event"],
      "knobs": ["subscriptionFilters", "retention", "ackDeadline", "replay"],
      "commonFailureModes": ["slow consumer lag", "fanout amplification"],
      "interviewHooks": ["Delivery guarantees? Replay strategy? Consumer isolation?"],
      "synonyms": ["SNS", "topic", "event bus", "pubsub"]
    },
    {
      "id": "event-log",
      "name": "Event Log / Stream",
      "category": "messaging",
      "purpose": "Durable ordered log for high-throughput event streaming and replay.",
      "inputs": ["event"],
      "outputs": ["event"],
      "knobs": ["partitions", "replication", "retention", "compaction"],
      "commonFailureModes": ["hot partition", "consumer lag", "rebalancing storms"],
      "interviewHooks": ["Partition key design? Exactly-once processing patterns?"],
      "synonyms": ["Kafka", "Kinesis", "Pulsar", "log stream"]
    },
    {
      "id": "dlq",
      "name": "Dead Letter Queue",
      "category": "reliability",
      "purpose": "Isolates poison messages for inspection and reprocessing without blocking pipelines.",
      "inputs": ["failed-message"],
      "outputs": ["manual-reprocess"],
      "knobs": ["maxReceiveCount", "redrivePolicy"],
      "commonFailureModes": ["silent accumulation (no monitoring)", "reprocessing without fix"],
      "interviewHooks": ["How do you triage DLQ? Automated redrive?"],
      "synonyms": ["dead letter", "DLQ"]
    },

    {
      "id": "cache",
      "name": "Cache",
      "category": "caching",
      "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
      "inputs": ["cache-get", "cache-set"],
      "outputs": ["hit/miss", "value"],
      "knobs": ["ttl", "evictionPolicy", "maxMemory", "sharding", "replication"],
      "commonFailureModes": ["stampede on miss", "stale data", "cache node failure causing DB overload"],
      "interviewHooks": ["Cache-aside vs read-through? Stampede mitigation? Invalidation?"],
      "synonyms": ["Redis", "Memcached", "in-memory cache"]
    },
    {
      "id": "cache-invalidation",
      "name": "Cache Invalidation Stream",
      "category": "caching",
      "purpose": "Propagates invalidation events to caches to keep data fresh.",
      "inputs": ["event"],
      "outputs": ["invalidate"],
      "knobs": ["keys", "batching", "dedupe"],
      "commonFailureModes": ["missed invalidations", "out-of-order invalidations"],
      "interviewHooks": ["TTL-only vs event invalidation? Exactly-once invalidation?"],
      "synonyms": ["invalidation topic", "cache busting"]
    },

    {
      "id": "sql-db",
      "name": "SQL Database",
      "category": "storage",
      "purpose": "Relational storage with transactions and strong consistency options.",
      "inputs": ["db-read", "db-write"],
      "outputs": ["rows"],
      "knobs": ["indexes", "replication", "partitioning", "connectionPool", "isolationLevel"],
      "commonFailureModes": ["lock contention", "replication lag", "hot rows"],
      "interviewHooks": ["Sharding strategy? Isolation level? Read replicas usage?"],
      "synonyms": ["Postgres", "MySQL", "Aurora", "Cloud SQL", "SQL"]
    },
    {
      "id": "sql-read-replica",
      "name": "SQL Read Replica",
      "category": "storage",
      "purpose": "Scales reads; offloads primary; may have replication lag.",
      "inputs": ["replication-stream", "db-read"],
      "outputs": ["rows"],
      "knobs": ["replicationMode", "readRouting", "lagBudget"],
      "commonFailureModes": ["stale reads due to lag", "failover complexity"],
      "interviewHooks": ["How do you route reads? Consistency guarantees?"],
      "synonyms": ["read replica", "follower", "secondary"]
    },
    {
      "id": "kv-store",
      "name": "Key-Value Store",
      "category": "storage",
      "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
      "inputs": ["db-read", "db-write"],
      "outputs": ["value"],
      "knobs": ["partitionKey", "ttl", "replication", "consistencyLevel"],
      "commonFailureModes": ["hot keys", "uneven partitions", "eventual consistency surprises"],
      "interviewHooks": ["Partition key design? Hot key mitigation?"],
      "synonyms": ["DynamoDB", "Cassandra", "Bigtable", "Cosmos DB", "KV"]
    },
    {
      "id": "document-store",
      "name": "Document Store",
      "category": "storage",
      "purpose": "Flexible schema documents; good for evolving data models.",
      "inputs": ["db-read", "db-write"],
      "outputs": ["document"],
      "knobs": ["indexes", "sharding", "ttl"],
      "commonFailureModes": ["query without index", "hot partitions"],
      "interviewHooks": ["When doc store vs SQL? Index strategy?"],
      "synonyms": ["MongoDB", "document DB", "DocDB"]
    },
    {
      "id": "time-series-db",
      "name": "Time-Series Database",
      "category": "storage",
      "purpose": "Optimized for metrics/events over time; supports rollups and retention policies.",
      "inputs": ["ingest"],
      "outputs": ["query-results"],
      "knobs": ["retention", "downsampling", "compression"],
      "commonFailureModes": ["high cardinality blowups", "ingest bottlenecks"],
      "interviewHooks": ["Cardinality control? Rollups?"],
      "synonyms": ["Prometheus TSDB", "InfluxDB", "timeseries store"]
    },
    {
      "id": "object-storage",
      "name": "Object Storage",
      "category": "storage",
      "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
      "inputs": ["object-write", "object-read"],
      "outputs": ["blob"],
      "knobs": ["storageClass", "lifecyclePolicy", "versioning", "multipartUpload"],
      "commonFailureModes": ["eventual consistency edge cases (some systems)", "hot prefix"],
      "interviewHooks": ["Presigned uploads? CDN integration? Lifecycle policies?"],
      "synonyms": ["S3", "GCS", "Blob Storage", "object store"]
    },

    {
      "id": "search-index",
      "name": "Search Index",
      "category": "search",
      "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
      "inputs": ["index-write", "query"],
      "outputs": ["search-results"],
      "knobs": ["analyzers", "ranking", "shards", "replicas", "refreshInterval"],
      "commonFailureModes": ["stale index", "high write amplification", "hot shards"],
      "interviewHooks": ["Indexing pipeline? Consistency vs freshness?"],
      "synonyms": ["Elasticsearch", "Solr", "OpenSearch", "search service"]
    },
    {
      "id": "vector-index",
      "name": "Vector Index",
      "category": "search",
      "purpose": "Approximate nearest neighbor search for embeddings and semantic retrieval.",
      "inputs": ["vector-upsert", "vector-query"],
      "outputs": ["neighbors"],
      "knobs": ["indexType", "recall", "latency", "dimensions", "rebuild"],
      "commonFailureModes": ["drift in embeddings", "rebuild cost", "stale vectors"],
      "interviewHooks": ["Recall/latency tradeoff? Update strategy?"],
      "synonyms": ["FAISS", "HNSW", "vector DB", "Pinecone", "Milvus"]
    },

    {
      "id": "stream-processor",
      "name": "Stream Processor",
      "category": "analytics",
      "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
      "inputs": ["event"],
      "outputs": ["event", "db-write"],
      "knobs": ["windowing", "watermarks", "stateStore", "checkpointing"],
      "commonFailureModes": ["late events", "state blowups", "checkpoint lag"],
      "interviewHooks": ["Exactly-once? Windowing? Backpressure?"],
      "synonyms": ["Flink", "Spark Streaming", "stream processing"]
    },
    {
      "id": "batch-processor",
      "name": "Batch Processor",
      "category": "analytics",
      "purpose": "Runs batch jobs for ETL, backfills, offline aggregation.",
      "inputs": ["data"],
      "outputs": ["data"],
      "knobs": ["schedule", "backfill", "partitioning"],
      "commonFailureModes": ["slow backfills", "partial writes", "idempotency issues"],
      "interviewHooks": ["How do you rerun safely? Incremental vs full?"],
      "synonyms": ["Spark", "batch job", "ETL"]
    },
    {
      "id": "data-warehouse",
      "name": "Data Warehouse (OLAP)",
      "category": "analytics",
      "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
      "inputs": ["ingest"],
      "outputs": ["olap-query-results"],
      "knobs": ["partitioning", "clustering", "retention", "materializedViews"],
      "commonFailureModes": ["expensive scans", "bad partitioning", "stale materializations"],
      "interviewHooks": ["Partitioning strategy? Cost control? Freshness?"],
      "synonyms": ["BigQuery", "Snowflake", "Redshift", "warehouse"]
    },

    {
      "id": "metrics",
      "name": "Metrics",
      "category": "observability",
      "purpose": "Collects time-series measurements for monitoring and alerting.",
      "inputs": ["metric"],
      "outputs": ["alerts", "dashboards"],
      "knobs": ["cardinalityGuards", "scrapeInterval", "retention"],
      "commonFailureModes": ["high cardinality costs", "missing metrics due to scraping issues"],
      "interviewHooks": ["SLI/SLO? Alert fatigue? Cardinality control?"],
      "synonyms": ["Prometheus", "Cloud Monitoring", "metrics system"]
    },
    {
      "id": "logging",
      "name": "Logging",
      "category": "observability",
      "purpose": "Stores logs for debugging/auditing; supports search and retention.",
      "inputs": ["log"],
      "outputs": ["search", "alerts"],
      "knobs": ["sampling", "retention", "redaction"],
      "commonFailureModes": ["PII leakage", "cost explosion", "missing correlation IDs"],
      "interviewHooks": ["Structured logs? Sampling? PII redaction?"],
      "synonyms": ["ELK", "Splunk", "Cloud Logging", "logs"]
    },
    {
      "id": "tracing",
      "name": "Tracing",
      "category": "observability",
      "purpose": "Distributed tracing to understand request paths and latency contributors.",
      "inputs": ["trace"],
      "outputs": ["spans"],
      "knobs": ["sampling", "propagation", "retention"],
      "commonFailureModes": ["missing propagation", "sampling hides tail latencies"],
      "interviewHooks": ["How to debug tail latency? Sampling strategy?"],
      "synonyms": ["Jaeger", "Zipkin", "OpenTelemetry tracing"]
    },

    {
      "id": "circuit-breaker",
      "name": "Circuit Breaker",
      "category": "reliability",
      "purpose": "Stops calling failing dependencies to prevent cascading failures.",
      "inputs": ["rpc"],
      "outputs": ["rpc-or-fallback"],
      "knobs": ["errorThreshold", "openDuration", "halfOpenProbes", "fallback"],
      "commonFailureModes": ["bad thresholds causing flapping", "no fallback path"],
      "interviewHooks": ["Where do you place it? How do you choose thresholds?"],
      "synonyms": ["circuit breaker", "fail fast"]
    },
    {
      "id": "bulkhead",
      "name": "Bulkhead / Resource Isolation",
      "category": "reliability",
      "purpose": "Prevents one dependency or endpoint from exhausting shared resources.",
      "inputs": ["requests"],
      "outputs": ["limited-requests"],
      "knobs": ["threadPools", "queues", "perRouteLimits"],
      "commonFailureModes": ["misallocation starves important traffic"],
      "interviewHooks": ["How do you isolate read vs write paths?"],
      "synonyms": ["bulkhead", "pool isolation"]
    },
    {
      "id": "retry-policy",
      "name": "Retry Policy",
      "category": "reliability",
      "purpose": "Retries transient failures safely using backoff + jitter; must avoid amplification.",
      "inputs": ["errors"],
      "outputs": ["retries"],
      "knobs": ["maxRetries", "backoff", "jitter", "retryBudget"],
      "commonFailureModes": ["retry storms", "retrying non-idempotent ops"],
      "interviewHooks": ["Which calls are safe to retry? Retry budget?"],
      "synonyms": ["retries", "exponential backoff"]
    },

    {
      "id": "feature-flag",
      "name": "Feature Flag Service",
      "category": "reliability",
      "purpose": "Controls feature rollout; supports canary, kill-switch, experimentation.",
      "inputs": ["flag-eval"],
      "outputs": ["variant"],
      "knobs": ["targeting", "percentageRollout", "killSwitch", "auditing"],
      "commonFailureModes": ["flag config outages", "stale caches causing inconsistent behavior"],
      "interviewHooks": ["How do you fail open/closed? Local caching?"],
      "synonyms": ["feature flags", "launchdarkly", "flag service"]
    },

    {
      "id": "config-service",
      "name": "Config Service",
      "category": "reliability",
      "purpose": "Centralized dynamic config distribution with versioning and rollout.",
      "inputs": ["config-read"],
      "outputs": ["config"],
      "knobs": ["refresh", "versioning", "rollout"],
      "commonFailureModes": ["bad config rollout", "stale config"],
      "interviewHooks": ["How do you rollback config? Safe rollout?"],
      "synonyms": ["dynamic config", "configuration service"]
    },
    {
      "id": "realtime-gateway",
      "name": "Realtime Gateway (WebSocket)",
      "category": "edge",
      "purpose": "Maintains WebSocket connections for real-time bidirectional messaging; routes messages to connected clients.",
      "inputs": ["http-upgrade", "ws-message"],
      "outputs": ["ws-message"],
      "knobs": ["connectionTimeout", "heartbeatInterval", "maxConnectionsPerInstance", "stickySessions"],
      "commonFailureModes": ["connection storms on reconnect", "stale connections after instance failover"],
      "interviewHooks": ["How do you scale WebSocket servers? Sticky sessions? Reconnection strategy?"],
      "synonyms": ["WebSocket gateway", "Socket.io", "real-time gateway"]
    },
    {
      "id": "presence-service",
      "name": "Presence Service",
      "category": "compute",
      "purpose": "Tracks online/offline status of users; supports last-seen, typing indicators, and room membership.",
      "inputs": ["heartbeat", "status-update"],
      "outputs": ["presence-state"],
      "knobs": ["heartbeatTTL", "slidingWindow", "shardingKey"],
      "commonFailureModes": ["stale presence after crash", "hot keys for popular users"],
      "interviewHooks": ["How do you handle flaky networks? Scale presence for millions?"],
      "synonyms": ["presence", "online status", "typing indicator service"]
    },
    {
      "id": "conversation-service",
      "name": "Conversation Service",
      "category": "compute",
      "purpose": "Manages conversation metadata: create/archive threads, list conversations, resolve participants.",
      "inputs": ["rpc"],
      "outputs": ["conversation-metadata"],
      "knobs": ["pagination", "indexStrategy", "cacheTTL"],
      "commonFailureModes": ["N+1 queries on list", "hot partitions for popular conversations"],
      "interviewHooks": ["How do you paginate? Order by last message?"],
      "synonyms": ["thread service", "chat room service"]
    },
    {
      "id": "message-service",
      "name": "Message Service",
      "category": "compute",
      "purpose": "Handles message send/receive: validate, persist, fanout to realtime and push pipelines.",
      "inputs": ["rpc", "event"],
      "outputs": ["event", "db-write"],
      "knobs": ["idempotencyKey", "ordering", "retention"],
      "commonFailureModes": ["duplicate messages without idempotency", "ordering breaks under load"],
      "interviewHooks": ["Idempotency? Ordering guarantees? Fanout strategy?"],
      "synonyms": ["messaging service", "chat message API"]
    },
    {
      "id": "message-store",
      "name": "Message Store (Sharded KV/Wide-Column)",
      "category": "storage",
      "purpose": "Durable storage for chat messages; sharded by conversationId or (conversationId, messageId) for scale.",
      "inputs": ["db-write", "db-read"],
      "outputs": ["message"],
      "knobs": ["partitionKey", "sortKey", "ttl", "compaction"],
      "commonFailureModes": ["hot partition for popular conversations", "uneven shard distribution"],
      "interviewHooks": ["Partition key design? Time-range queries? Compaction?"],
      "synonyms": ["message store", "chat storage", "wide-column for messages"]
    },
    {
      "id": "conversation-metadata-store",
      "name": "Conversation Metadata Store",
      "category": "storage",
      "purpose": "Stores conversation metadata: participants, last message timestamp, read receipts.",
      "inputs": ["db-write", "db-read"],
      "outputs": ["metadata"],
      "knobs": ["indexes", "partitionKey", "cacheLayer"],
      "commonFailureModes": ["hot rows for active conversations", "eventual consistency for read receipts"],
      "interviewHooks": ["Index for list-by-user? Consistency model?"],
      "synonyms": ["conversation store", "thread metadata"]
    },
    {
      "id": "notification-service",
      "name": "Notification Service (Push)",
      "category": "compute",
      "purpose": "Sends push notifications to offline users via APNs/FCM; batches and retries.",
      "inputs": ["event"],
      "outputs": ["push-payload"],
      "knobs": ["batchSize", "retryPolicy", "deviceTokenRefresh"],
      "commonFailureModes": ["token expiry causing silent failures", "provider rate limits"],
      "interviewHooks": ["How do you handle token refresh? Batching for scale?"],
      "synonyms": ["push service", "APNs", "FCM", "push notifications"]
    },
    {
      "id": "media-service",
      "name": "Media Service",
      "category": "compute",
      "purpose": "Handles image/video upload, transcoding, thumbnails; stores in object storage, serves via CDN.",
      "inputs": ["upload", "rpc"],
      "outputs": ["url", "object-write"],
      "knobs": ["presignedUpload", "transcodingPipeline", "thumbnailSize"],
      "commonFailureModes": ["upload timeout for large files", "transcoding backlog"],
      "interviewHooks": ["Presigned URLs? Async transcoding? CDN invalidation?"],
      "synonyms": ["media upload", "attachment service", "image service"]
    }
  ]
}
