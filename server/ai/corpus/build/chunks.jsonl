{"id":"01_fundamentals#1","title":"System Design Fundamentals","text":"# System Design Fundamentals","tags":["fundamentals","scaling","failure","tradeoffs","interview","default"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["system","design","fundamentals"]}
{"id":"01_fundamentals#2","title":"What it is","text":"## What it is\n\nHigh-level approach to building scalable, reliable systems. Combines requirements gathering, capacity estimation, component selection, and failure-mode analysis.","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","what"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["what","high-level","approach","building","scalable","reliable","systems","combines","requirements","gathering","capacity","estimation"]}
{"id":"01_fundamentals#3","title":"When to use","text":"## When to use\n\n- Any system that must scale beyond a single machine\n- When latency, throughput, or availability matter\n- Interview setting: demonstrate structured thinking","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","use"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["use","any","system","scale","beyond","single","machine","latency","throughput","availability","matter","interview"]}
{"id":"01_fundamentals#4","title":"When NOT to use","text":"## When NOT to use\n\n- Trivial CRUD with low traffic; over-engineering wastes time\n- When requirements are unclear; scope first","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","not","use"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["not","use","trivial","crud","low","traffic","over-engineering","wastes","time","requirements","unclear","scope"]}
{"id":"01_fundamentals#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Dimension | Option A | Option B |\n|-----------|----------|----------|\n| Consistency | Strong | Eventual |\n| Latency | Low (cache) | Higher (DB) |\n| Complexity | Simple | Distributed |\n| Cost | Cheap storage | Fast storage |","tags":["fundamentals","scaling","failure","tradeoffs","interview","default"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["option","----------","storage","tradeoffs","dimension","-----------","consistency","strong","eventual","latency","low","cache"]}
{"id":"01_fundamentals#6","title":"Failure modes","text":"## Failure modes\n\n- Single point of failure; add redundancy\n- Cascading failure; use circuit breakers, timeouts\n- Resource exhaustion; rate limit, backpressure","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","modes"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["failure","modes","single","point","add","redundancy","cascading","use","circuit","breakers","timeouts","resource"]}
{"id":"01_fundamentals#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- QPS, latency p50/p99, error rate\n- Availability: 99.9% = 8.76h downtime/year\n- 1M DAU ≈ 10–50 QPS average; 3–5x peak","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","metrics","numbers","mention"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["qps","metrics","numbers","mention","latency","p50","p99","error","rate","availability","76h","downtime"]}
{"id":"01_fundamentals#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"What's the bottleneck?\"\n- \"How do you scale that?\"\n- \"What if this component fails?\"\n- \"Walk me through the numbers.\"","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","common","interviewer","follow-ups"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["what","common","interviewer","follow-ups","bottleneck","how","you","scale","component","fails","walk","through"]}
{"id":"01_fundamentals#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Start with requirements and constraints, then estimate QPS and storage. Design for the happy path first, then add caching and replication for scale.\"","tags":["fundamentals","scaling","failure","tradeoffs","interview","default","strong","sample","phrasing"],"topic":"fundamentals","component":"default","source":"01_fundamentals","docId":"01_fundamentals","keywords":["then","strong","sample","phrasing","start","requirements","constraints","estimate","qps","storage","design","happy"]}
{"id":"02_requirements#1","title":"Requirements Gathering","text":"# Requirements Gathering","tags":["requirements","functional","non-functional","clarify","scope","default"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["requirements","gathering"]}
{"id":"02_requirements#2","title":"What it is","text":"## What it is\n\nClarifying functional and non-functional requirements before designing. Functional = what the system does; non-functional = how well (latency, availability, consistency).","tags":["requirements","functional","non-functional","clarify","scope","default","what"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["what","functional","non-functional","clarifying","requirements","before","designing","system","how","well","latency","availability"]}
{"id":"02_requirements#3","title":"When to use","text":"## When to use\n\n- Start of any system design; prevents scope creep\n- When interviewer gives vague problem; ask clarifying questions","tags":["requirements","functional","non-functional","clarify","scope","default","use"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["use","start","any","system","design","prevents","scope","creep","interviewer","gives","vague","problem"]}
{"id":"02_requirements#4","title":"When NOT to use","text":"## When NOT to use\n\n- When problem is already well-defined; don't over-clarify\n- Mid-design deep dive; stay high-level at start","tags":["requirements","functional","non-functional","clarify","scope","default","not","use"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["not","use","problem","already","well-defined","don","over-clarify","mid-design","deep","dive","stay","high-level"]}
{"id":"02_requirements#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Clarify more | Clarify less |\n|--------------|--------------|\n| Less rework | Faster start |\n| May over-engineer | Risk missing critical need |","tags":["requirements","functional","non-functional","clarify","scope","default","tradeoffs"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["clarify","less","--------------","tradeoffs","more","rework","faster","start","over-engineer","risk","missing","critical"]}
{"id":"02_requirements#6","title":"Failure modes","text":"## Failure modes\n\n- Assuming requirements; always state assumptions\n- Ignoring non-functional; latency/availability often matter most\n- Scope creep; \"out of scope\" is a valid answer","tags":["requirements","functional","non-functional","clarify","scope","default","failure","modes"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["scope","failure","modes","assuming","requirements","always","state","assumptions","ignoring","non-functional","latency","availability"]}
{"id":"02_requirements#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- DAU, reads vs writes ratio\n- Latency SLO (e.g. p99 < 200ms)\n- Availability target (99.9%, 99.99%)\n- Data retention (30 days, 7 years)","tags":["requirements","functional","non-functional","clarify","scope","default","metrics","numbers","mention"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["metrics","numbers","mention","dau","reads","writes","ratio","latency","slo","p99","200ms","availability"]}
{"id":"02_requirements#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"What's the read/write ratio?\"\n- \"How many users? Active or total?\"\n- \"What's acceptable latency?\"\n- \"Any compliance requirements?\"","tags":["requirements","functional","non-functional","clarify","scope","default","common","interviewer","follow-ups"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["what","common","interviewer","follow-ups","read","write","ratio","how","many","users","active","total"]}
{"id":"02_requirements#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"I'll assume 10M DAU, 10:1 read/write, p99 latency under 200ms, and 99.9% availability. Correct me if any of these differ.\"","tags":["requirements","functional","non-functional","clarify","scope","default","strong","sample","phrasing"],"topic":"requirements","component":"default","source":"02_requirements","docId":"02_requirements","keywords":["strong","sample","phrasing","assume","10m","dau","read","write","p99","latency","under","200ms"]}
{"id":"03_capacity_estimation#1","title":"Capacity Estimation","text":"# Capacity Estimation","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["capacity","estimation"]}
{"id":"03_capacity_estimation#2","title":"What it is","text":"## What it is\n\nBack-of-envelope math: QPS, storage, bandwidth. Uses assumptions (DAU, actions/user, retention) to size components.","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","what"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["what","back-of-envelope","math","qps","storage","bandwidth","uses","assumptions","dau","actions","user","retention"]}
{"id":"03_capacity_estimation#3","title":"When to use","text":"## When to use\n\n- Sizing any component (servers, DB, cache)\n- Validating if design can handle load\n- Interview: shows you think in numbers","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","use"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["use","sizing","any","component","servers","cache","validating","design","handle","load","interview","shows"]}
{"id":"03_capacity_estimation#4","title":"When NOT to use","text":"## When NOT to use\n\n- Early requirements phase; need traffic assumptions first\n- Micro-optimization; ballpark is enough","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","not","use"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["not","use","early","requirements","phase","need","traffic","assumptions","first","micro-optimization","ballpark","enough"]}
{"id":"03_capacity_estimation#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Conservative | Aggressive |\n|--------------|------------|\n| Over-provision, higher cost | Risk under-provision |\n| Safer at launch | Requires scaling plan |","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","tradeoffs"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["tradeoffs","conservative","aggressive","--------------","------------","over-provision","higher","cost","risk","under-provision","safer","launch"]}
{"id":"03_capacity_estimation#6","title":"Failure modes","text":"## Failure modes\n\n- Wrong assumptions; state them explicitly\n- Forgetting peak vs average (3–5x multiplier)\n- Ignoring storage growth over time","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","failure","modes"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["failure","modes","wrong","assumptions","state","them","explicitly","forgetting","peak","average","multiplier","ignoring"]}
{"id":"03_capacity_estimation#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- 1M DAU × 10 requests/day ≈ 120 QPS average\n- Peak: 3–5× average\n- 100 bytes/row × 1B rows = 100 GB\n- 1 Gbps ≈ 12.5 MB/s","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","metrics","mention"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["average","100","metrics","numbers","mention","dau","requests","day","120","qps","peak","bytes"]}
{"id":"03_capacity_estimation#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"What's the bottleneck at that scale?\"\n- \"How much storage for 1 year?\"\n- \"Bandwidth between services?\"\n- \"Number of DB connections?\"","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","common","interviewer","follow-ups"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["common","interviewer","follow-ups","what","bottleneck","scale","how","much","storage","year","bandwidth","between"]}
{"id":"03_capacity_estimation#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"10M DAU, 20 requests/day each → 2.3k QPS average. With 5× peak, ~12k QPS. At 1KB/request, that's ~12 MB/s bandwidth. DB needs to handle 12k reads; with cache at 80% hit rate, DB sees 2.4k QPS.\"","tags":["capacity","qps","storage","bandwidth","estimation","numbers","capacity-estimation","default","strong","sample","phrasing"],"topic":"capacity-estimation","component":"default","source":"03_capacity_estimation","docId":"03_capacity_estimation","keywords":["qps","12k","strong","sample","phrasing","10m","dau","requests","day","each","average","peak"]}
{"id":"04_load_balancing#1","title":"Load Balancing","text":"# Load Balancing","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["load","balancing"]}
{"id":"04_load_balancing#2","title":"What it is","text":"## What it is\n\nDistributing requests across multiple backend servers. Prevents single-server overload and improves availability.","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","what"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["what","distributing","requests","across","multiple","backend","servers","prevents","single-server","overload","improves","availability"]}
{"id":"04_load_balancing#3","title":"When to use","text":"## When to use\n\n- Multiple app servers; need to route traffic\n- Horizontal scaling; add more backends\n- Health-based routing; skip unhealthy instances","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","use"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["use","multiple","app","servers","need","route","traffic","horizontal","scaling","add","more","backends"]}
{"id":"04_load_balancing#4","title":"When NOT to use","text":"## When NOT to use\n\n- Single server; no distribution needed\n- When all traffic must hit one node (e.g. primary DB)","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","not","use"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["not","use","single","server","distribution","needed","all","traffic","hit","one","node","primary"]}
{"id":"04_load_balancing#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Strategy | Use case |\n|----------|----------|\n| Round robin | Even load, stateless |\n| Least connections | Uneven request duration |\n| IP hash | Sticky sessions, no app support |\n| L7 path-based | Route by URL, A/B test |","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","tradeoffs"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["----------","tradeoffs","strategy","use","case","round","robin","even","load","stateless","least","connections"]}
{"id":"04_load_balancing#6","title":"Failure modes","text":"## Failure modes\n\n- LB as single point of failure; use multiple LBs, DNS failover\n- Slow health checks; traffic hits dead backend\n- Thundering herd; all clients reconnect to same backend","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","failure","modes"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["failure","backend","modes","single","point","use","multiple","lbs","dns","failover","slow","health"]}
{"id":"04_load_balancing#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Health check interval: 5–30 seconds\n- L4 vs L7: L4 = IP/port; L7 = HTTP, path, headers\n- Connection limits per backend\n- Failover time (DNS TTL, health check interval)","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","metrics","numbers","mention"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["health","check","interval","metrics","numbers","mention","seconds","port","http","path","headers","connection"]}
{"id":"04_load_balancing#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"L4 or L7? Why?\"\n- \"How do health checks work?\"\n- \"What if the LB fails?\"\n- \"Sticky sessions—when and how?\"","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","common","interviewer","follow-ups"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["how","common","interviewer","follow-ups","why","health","checks","work","what","fails","sticky","sessions"]}
{"id":"04_load_balancing#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"L7 load balancer for path-based routing and TLS termination. Round robin with least-connections fallback. Health checks every 10s; remove backend after 2 failures. Two LBs behind DNS for failover.\"","tags":["load-balancer","L4","L7","health-checks","routing","availability","load-balancing","lb","strong","sample","phrasing"],"topic":"load-balancing","component":"lb","source":"04_load_balancing","docId":"04_load_balancing","keywords":["strong","sample","phrasing","load","balancer","path-based","routing","tls","termination","round","robin","least-connections"]}
{"id":"05_caching#1","title":"Caching","text":"# Caching","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["caching"]}
{"id":"05_caching#2","title":"What it is","text":"## What it is\n\nStore frequently accessed data in fast storage (memory, SSD) to reduce load on primary store and lower latency.","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","what"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["store","what","frequently","accessed","data","fast","storage","memory","ssd","reduce","load","primary"]}
{"id":"05_caching#3","title":"When to use","text":"## When to use\n\n- Read-heavy workload; same data requested repeatedly\n- Primary store slow or expensive for high QPS\n- Can tolerate some staleness (TTL)\n- Need sub-ms read latency for hot data","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","use"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["data","use","read-heavy","workload","same","requested","repeatedly","primary","store","slow","expensive","high"]}
{"id":"05_caching#4","title":"When NOT to use","text":"## When NOT to use\n\n- Write-heavy; cache invalidates constantly\n- Data changes often; invalidation complexity\n- Strong consistency required; cache adds staleness","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","not","use"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["cache","not","use","write-heavy","invalidates","constantly","data","changes","often","invalidation","complexity","strong"]}
{"id":"05_caching#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Pattern | Consistency | Write latency | Complexity |\n|---------|-------------|---------------|------------|\n| Cache-aside | Stale possible | Low | Medium |\n| Write-through | Strong | Higher | Low |\n| Write-behind | Eventual | Lowest | High; data loss risk |","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","tradeoffs"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["low","tradeoffs","pattern","consistency","write","latency","complexity","---------","-------------","---------------","------------","cache-aside"]}
{"id":"05_caching#6","title":"Failure modes","text":"## Failure modes\n\n- Cache stampede: key expires, many requests hit DB. Use single-flier or probabilistic early expiry.\n- Stale reads: TTL too long or invalidation bug\n- Cache host fail: in-memory data lost; use replication\n- Thundering herd: one key, many misses","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","failure","modes"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["cache","key","many","use","failure","modes","stampede","expires","requests","hit","single-flier","probabilistic"]}
{"id":"05_caching#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Hit rate target: 80–95%\n- TTL: seconds to hours depending on freshness need\n- P99 latency: cache <1ms vs DB 10–50ms\n- Eviction: LRU common; memory bound","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","metrics","numbers","mention"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["metrics","numbers","mention","hit","rate","target","ttl","seconds","hours","depending","freshness","need"]}
{"id":"05_caching#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Write-through or write-back? Why?\"\n- \"Invalidation strategy?\"\n- \"What if cache goes down?\"\n- \"How to avoid cache stampede?\"","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","common","interviewer","follow-ups"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["cache","common","interviewer","follow-ups","write-through","write-back","why","invalidation","strategy","what","goes","down"]}
{"id":"05_caching#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Cache-aside with TTL of 5 minutes for read-heavy feeds. On write, invalidate key. Single-flier on miss to prevent stampede. If Redis fails, degrade to DB; add replicas for HA.\"","tags":["cache","ttl","invalidation","stampede","consistency","write-through","write-back","caching","strong","sample","phrasing"],"topic":"caching","component":"cache","source":"05_caching","docId":"05_caching","keywords":["strong","sample","phrasing","cache-aside","ttl","minutes","read-heavy","feeds","write","invalidate","key","single-flier"]}
{"id":"06_databases#1","title":"Databases","text":"# Databases","tags":["database","replication","primary","replica","consistency","connection-pool","databases"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["databases"]}
{"id":"06_databases#2","title":"What it is","text":"## What it is\n\nPersistent storage for structured (relational) or semi-structured (NoSQL) data. Supports queries, transactions, replication.","tags":["database","replication","primary","replica","consistency","connection-pool","databases","what"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["what","persistent","storage","structured","relational","semi-structured","nosql","data","supports","queries","transactions","replication"]}
{"id":"06_databases#3","title":"When to use","text":"## When to use\n\n- Need durable storage, ACID where required\n- Complex queries, joins (SQL) or flexible schema (NoSQL)\n- Replication for read scaling and HA","tags":["database","replication","primary","replica","consistency","connection-pool","databases","use"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["use","need","durable","storage","acid","where","required","complex","queries","joins","sql","flexible"]}
{"id":"06_databases#4","title":"When NOT to use","text":"## When NOT to use\n\n- Ephemeral data; use cache\n- High-throughput append-only log; consider message queue\n- Search over free text; use search index","tags":["database","replication","primary","replica","consistency","connection-pool","databases","not","use"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["use","search","not","ephemeral","data","cache","high-throughput","append-only","log","consider","message","queue"]}
{"id":"06_databases#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| SQL | NoSQL |\n|-----|-------|\n| ACID, joins | Flexible schema, scale-out |\n| Vertical scale limit | Eventually consistent |\n| Strong consistency | Tune per use case |","tags":["database","replication","primary","replica","consistency","connection-pool","databases","tradeoffs"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["tradeoffs","sql","nosql","-----","-------","acid","joins","flexible","schema","scale-out","vertical","scale"]}
{"id":"06_databases#6","title":"Failure modes","text":"## Failure modes\n\n- Primary failure: promote replica; downtime or automated failover\n- Replication lag: read from replica may miss recent writes\n- Connection exhaustion: pool limits, timeouts\n- Hot rows: single key high QPS; shard or cache","tags":["database","replication","primary","replica","consistency","connection-pool","databases","failure","modes"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["failure","replica","modes","primary","promote","downtime","automated","failover","replication","lag","read","from"]}
{"id":"06_databases#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Replication lag: ms to seconds\n- Connection pool: 10–100 per app instance\n- Read replica count: scale reads\n- WAL/binlog for replication","tags":["database","replication","primary","replica","consistency","connection-pool","databases","metrics","numbers","mention"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["replication","metrics","numbers","mention","lag","seconds","connection","pool","100","per","app","instance"]}
{"id":"06_databases#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Single node or replicated?\"\n- \"Read-your-writes consistency?\"\n- \"Partition key?\"\n- \"How handle primary failover?\"","tags":["database","replication","primary","replica","consistency","connection-pool","databases","common","interviewer","follow-ups"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["common","interviewer","follow-ups","single","node","replicated","read-your-writes","consistency","partition","key","how","handle"]}
{"id":"06_databases#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Primary-replica setup. Writes go to primary; reads from replicas. Accept replication lag for non-critical reads; read-from-primary for user's own writes. Connection pooling, 50 connections per app instance.\"","tags":["database","replication","primary","replica","consistency","connection-pool","databases","strong","sample","phrasing"],"topic":"databases","component":"database","source":"06_databases","docId":"06_databases","keywords":["writes","reads","strong","sample","phrasing","primary-replica","setup","primary","from","replicas","accept","replication"]}
{"id":"07_sharding#1","title":"Sharding","text":"# Sharding","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["sharding"]}
{"id":"07_sharding#2","title":"What it is","text":"## What it is\n\nSplit data across multiple DB instances (shards) by partition key. Each shard holds a subset. Enables horizontal scaling beyond single-node limits.","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","what"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["what","split","data","across","multiple","instances","shards","partition","key","each","shard","holds"]}
{"id":"07_sharding#3","title":"When to use","text":"## When to use\n\n- Data or write throughput exceeds single-node capacity\n- Read replicas don't solve write bottleneck\n- Data partitionable (user_id, tenant_id)\n- Can accept no cross-shard joins","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","use"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["data","write","use","throughput","exceeds","single-node","capacity","read","replicas","don","solve","bottleneck"]}
{"id":"07_sharding#4","title":"When NOT to use","text":"## When NOT to use\n\n- Single node sufficient; avoid complexity\n- Heavy cross-shard queries; design schema to avoid\n- When partition key changes often; rebalancing costly","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","not","use"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["avoid","not","use","single","node","sufficient","complexity","heavy","cross-shard","queries","design","schema"]}
{"id":"07_sharding#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Hash | Range |\n|------|-------|\n| Even distribution | Range queries easy |\n| No range scans | Hot spots at boundaries |\n| Rehash on add shards | Split hot ranges |","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","tradeoffs"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["range","hot","tradeoffs","hash","------","-------","even","distribution","queries","easy","scans","spots"]}
{"id":"07_sharding#6","title":"Failure modes","text":"## Failure modes\n\n- Hot partition: one shard overloaded. Mitigate: compound key, split hot shard.\n- Rebalancing: data migration causes load; do gradually.\n- Cross-shard query: expensive; avoid in hot path.\n- Shard failure: that partition down; replicate shards.","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","failure","modes"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["hot","shard","failure","partition","modes","one","overloaded","mitigate","compound","key","split","rebalancing"]}
{"id":"07_sharding#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Partition key: user_id, (user_id, timestamp)\n- Shard count: start small, add as needed\n- Rebalancing: online vs batch; migration lag\n- Consistent hashing: reduces churn on add/remove","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","metrics","numbers","mention"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["user_id","add","metrics","numbers","mention","partition","key","timestamp","shard","count","start","small"]}
{"id":"07_sharding#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Partition key? Why?\"\n- \"How avoid hot partitions?\"\n- \"Resharding strategy?\"\n- \"Cross-shard query—how handle?\"","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","common","interviewer","follow-ups"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["how","common","interviewer","follow-ups","partition","key","why","avoid","hot","partitions","resharding","strategy"]}
{"id":"07_sharding#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Shard by user_id modulo N. Compound key (user_id, created_at) for time-ordered data. Hot users: sub-shard or cache. Add shards with consistent hashing to minimize data movement.\"","tags":["sharding","partition-key","hot-partition","resharding","hash","range","shard","strong","sample","phrasing"],"topic":"sharding","component":"shard","source":"07_sharding","docId":"07_sharding","keywords":["user_id","data","strong","sample","phrasing","shard","modulo","compound","key","created_at","time-ordered","hot"]}
{"id":"08_messaging_queues#1","title":"Messaging Queues","text":"# Messaging Queues","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["messaging","queues"]}
{"id":"08_messaging_queues#2","title":"What it is","text":"## What it is\n\nAsync buffer between producers and consumers. Decouples services, absorbs spikes, enables event-driven workflows.","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","what"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["what","async","buffer","between","producers","consumers","decouples","services","absorbs","spikes","enables","event-driven"]}
{"id":"08_messaging_queues#3","title":"When to use","text":"## When to use\n\n- Decouple producer from consumer; async processing\n- Absorb traffic spikes; queue buffers bursts\n- Fan-out: one event, many consumers\n- At-least-once delivery with retries","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","use"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["use","decouple","producer","from","consumer","async","processing","absorb","traffic","spikes","queue","buffers"]}
{"id":"08_messaging_queues#4","title":"When NOT to use","text":"## When NOT to use\n\n- Synchronous response required\n- Strong ordering across all messages; use single partition\n- When duplicates unacceptable and idempotency hard","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","not","use"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["use","not","synchronous","response","required","strong","ordering","across","all","messages","single","partition"]}
{"id":"08_messaging_queues#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| At-least-once | Exactly-once |\n|---------------|--------------|\n| Duplicates possible | No duplicates |\n| Simpler | Idempotency, dedup |\n| Retry, DLQ | Transactional outbox |","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","tradeoffs"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["duplicates","tradeoffs","at-least-once","exactly-once","---------------","--------------","possible","simpler","idempotency","dedup","retry","dlq"]}
{"id":"08_messaging_queues#6","title":"Failure modes","text":"## Failure modes\n\n- Consumer lag: queue grows; backpressure or scale consumers\n- Poison message: crashes consumer; DLQ\n- Ordering: partition by key; global order costly\n- Queue full: producers block; capacity planning","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","failure","modes"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["consumer","queue","failure","modes","lag","grows","backpressure","scale","consumers","poison","message","crashes"]}
{"id":"08_messaging_queues#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Delivery semantics: at-least-once common\n- DLQ: messages after N retries\n- Backpressure: block producer when lag high\n- Partition count: parallelism; rebalancing cost","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","metrics","numbers","mention"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["metrics","numbers","mention","delivery","semantics","at-least-once","common","dlq","messages","after","retries","backpressure"]}
{"id":"08_messaging_queues#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"At-least-once or exactly-once?\"\n- \"How handle duplicates?\"\n- \"DLQ strategy?\"\n- \"Backpressure when consumer slow?\"","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","common","interviewer","follow-ups"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["common","interviewer","follow-ups","at-least-once","exactly-once","how","handle","duplicates","dlq","strategy","backpressure","consumer"]}
{"id":"08_messaging_queues#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"At-least-once delivery. Consumer processes and acks; on failure, message re-queued. Idempotent keys for dedup. DLQ after 5 retries. Backpressure: reject publish when lag > 10k.\"","tags":["queue","message-queue","dlq","backpressure","idempotency","at-least-once","delivery-semantics","messaging","strong","sample","phrasing"],"topic":"messaging","component":"queue","source":"08_messaging_queues","docId":"08_messaging_queues","keywords":["strong","sample","phrasing","at-least-once","delivery","consumer","processes","acks","failure","message","re-queued","idempotent"]}
{"id":"09_search#1","title":"Search","text":"# Search","tags":["search","index","elasticsearch","full-text","relevancy","default"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["search"]}
{"id":"09_search#2","title":"What it is","text":"## What it is\n\nIndexing and querying text or structured data for full-text or filtered search. Inverted index maps terms to documents.","tags":["search","index","elasticsearch","full-text","relevancy","default","what"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["what","indexing","querying","text","structured","data","full-text","filtered","search","inverted","index","maps"]}
{"id":"09_search#3","title":"When to use","text":"## When to use\n\n- Full-text search over content\n- Filtering, faceted search\n- Autocomplete, suggestions\n- Ranking by relevance","tags":["search","index","elasticsearch","full-text","relevancy","default","use"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["search","use","full-text","over","content","filtering","faceted","autocomplete","suggestions","ranking","relevance"]}
{"id":"09_search#4","title":"When NOT to use","text":"## When NOT to use\n\n- Exact key lookup; use DB or cache\n- Simple filters on primary key; DB index enough\n- Small dataset; in-memory search fine","tags":["search","index","elasticsearch","full-text","relevancy","default","not","use"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["use","key","not","exact","lookup","cache","simple","filters","primary","index","enough","small"]}
{"id":"09_search#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Elasticsearch | DB full-text |\n|---------------|--------------|\n| Rich search, scale-out | Simpler, single system |\n| Eventual consistency | Strong consistency |\n| Higher ops complexity | Lower latency for simple |","tags":["search","index","elasticsearch","full-text","relevancy","default","tradeoffs"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["consistency","tradeoffs","elasticsearch","full-text","---------------","--------------","rich","search","scale-out","simpler","single","system"]}
{"id":"09_search#6","title":"Failure modes","text":"## Failure modes\n\n- Index lag: writes delayed in search index\n- Relevancy tuning: bad ranking; iterate\n- Hot shards: popular terms; routing\n- Cluster split: split-brain; quorum settings","tags":["search","index","elasticsearch","full-text","relevancy","default","failure","modes"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["index","failure","modes","lag","writes","delayed","search","relevancy","tuning","bad","ranking","iterate"]}
{"id":"09_search#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Index latency: seconds to near-real-time\n- Query latency: p99 < 100ms typical\n- Sharding: by routing key for even load\n- Replica count: read scaling, HA","tags":["search","index","elasticsearch","full-text","relevancy","default","metrics","numbers","mention"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["latency","metrics","numbers","mention","index","seconds","near-real-time","query","p99","100ms","typical","sharding"]}
{"id":"09_search#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"How keep search index in sync with DB?\"\n- \"Scoring and ranking?\"\n- \"How scale search cluster?\"\n- \"Typo tolerance?\"","tags":["search","index","elasticsearch","full-text","relevancy","default","common","interviewer","follow-ups"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["how","search","common","interviewer","follow-ups","keep","index","sync","scoring","ranking","scale","cluster"]}
{"id":"09_search#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Elasticsearch for full-text search. Write to DB first; async sync to search via change stream or queue. Shard by tenant_id. Replicas for read scaling. Fuzzy matching for typos.\"","tags":["search","index","elasticsearch","full-text","relevancy","default","strong","sample","phrasing"],"topic":"search","component":"default","source":"09_search","docId":"09_search","keywords":["search","strong","sample","phrasing","elasticsearch","full-text","write","first","async","sync","via","change"]}
{"id":"10_storage_cdn#1","title":"Storage & CDN","text":"# Storage & CDN","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["storage","cdn"]}
{"id":"10_storage_cdn#2","title":"What it is","text":"## What it is\n\n**Object storage:** Blob storage (S3-style) for images, videos, backups. **CDN:** Edge caches to serve static assets close to users.","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","what"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["storage","what","object","blob","s3-style","images","videos","backups","cdn","edge","caches","serve"]}
{"id":"10_storage_cdn#3","title":"When to use","text":"## When to use\n\n- Large files: images, videos, backups\n- Static assets: JS, CSS, images\n- Global low-latency delivery\n- Immutable content; cache aggressively","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","use"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["images","use","large","files","videos","backups","static","assets","css","global","low-latency","delivery"]}
{"id":"10_storage_cdn#4","title":"When NOT to use","text":"## When NOT to use\n\n- Dynamic, personalized content; cache hit rate low\n- Small API responses; CDN overhead not worth it\n- Strong consistency required; CDN has propagation delay","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","not","use"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["not","cdn","use","dynamic","personalized","content","cache","hit","rate","low","small","api"]}
{"id":"10_storage_cdn#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Object storage | Block storage |\n|----------------|---------------|\n| Scale, cheap | Low latency, mutable |\n| Eventual consistency | Strong consistency |\n| HTTP API | Attached to instance |","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","tradeoffs"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["storage","consistency","tradeoffs","object","block","----------------","---------------","scale","cheap","low","latency","mutable"]}
{"id":"10_storage_cdn#6","title":"Failure modes","text":"## Failure modes\n\n- CDN cache invalidation: propagation delay (minutes)\n- Origin overload: CDN miss storm; warm cache\n- Region failure: multi-region origin\n- Cost: egress expensive; optimize cache hit rate","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","failure","modes"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["cache","failure","cdn","origin","modes","invalidation","propagation","delay","minutes","overload","miss","storm"]}
{"id":"10_storage_cdn#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- CDN hit rate: 90%+ for static\n- Invalidation: purge by path or full\n- Object storage: multipart upload for large files\n- Edge locations: dozens to hundreds","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","metrics","numbers","mention"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["metrics","numbers","mention","cdn","hit","rate","static","invalidation","purge","path","full","object"]}
{"id":"10_storage_cdn#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Cache invalidation strategy?\"\n- \"What if origin goes down?\"\n- \"How handle dynamic content?\"\n- \"Cost model—egress?\"","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","common","interviewer","follow-ups"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["common","interviewer","follow-ups","cache","invalidation","strategy","what","origin","goes","down","how","handle"]}
{"id":"10_storage_cdn#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Static assets on object storage. CDN in front; TTL 24h for immutable, versioned URLs. Invalidate on deploy by path prefix. Multi-region origin for resilience.\"","tags":["storage","cdn","object-storage","cache-invalidation","edge","storage-cdn","default","strong","sample","phrasing"],"topic":"storage-cdn","component":"default","source":"10_storage_cdn","docId":"10_storage_cdn","keywords":["strong","sample","phrasing","static","assets","object","storage","cdn","front","ttl","24h","immutable"]}
{"id":"11_consistency_reliability#1","title":"Consistency & Reliability","text":"# Consistency & Reliability","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["consistency","reliability"]}
{"id":"11_consistency_reliability#2","title":"What it is","text":"## What it is\n\n**Consistency:** When reads see latest writes. **Reliability:** System available and correct under failures.","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","what"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["what","consistency","reads","see","latest","writes","reliability","system","available","correct","under","failures"]}
{"id":"11_consistency_reliability#3","title":"When to use","text":"## When to use\n\n- Design tradeoffs: strong vs eventual\n- Replication, quorum, CAP\n- Failure detection and recovery","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","use"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["use","design","tradeoffs","strong","eventual","replication","quorum","cap","failure","detection","recovery"]}
{"id":"11_consistency_reliability#4","title":"When NOT to use","text":"## When NOT to use\n\n- Single-node design; consistency trivial\n- When interviewer wants component focus; stay on topic","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","not","use"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["not","use","single-node","design","consistency","trivial","interviewer","wants","component","focus","stay","topic"]}
{"id":"11_consistency_reliability#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Strong | Eventual |\n|--------|----------|\n| Read sees latest write | Stale reads possible |\n| Higher latency, lower availability | Lower latency, higher availability |\n| Critical for money, auth | OK for feeds, counters |","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","tradeoffs"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["higher","latency","lower","availability","tradeoffs","strong","eventual","--------","----------","read","sees","latest"]}
{"id":"11_consistency_reliability#6","title":"Failure modes","text":"## Failure modes\n\n- Split-brain: two primaries; use quorum\n- Cascading failure: one component down takes others; circuit breaker\n- Data loss: async replication; acknowledge sync durability","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","failure","modes"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["failure","modes","split-brain","two","primaries","use","quorum","cascading","one","component","down","takes"]}
{"id":"11_consistency_reliability#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- Quorum: W + R > N for read-your-writes\n- Availability: 99.9% = 8.76h/year downtime\n- RTO/RPO: recovery time/point objectives\n- CAP: partition forces choice","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","metrics","numbers","mention"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["metrics","numbers","mention","quorum","read-your-writes","availability","76h","year","downtime","rto","rpo","recovery"]}
{"id":"11_consistency_reliability#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Strong or eventual? Where?\"\n- \"Quorum settings?\"\n- \"How detect split-brain?\"\n- \"Read-your-writes—how?\"","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","common","interviewer","follow-ups"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["how","common","interviewer","follow-ups","strong","eventual","where","quorum","settings","detect","split-brain","read-your-writes"]}
{"id":"11_consistency_reliability#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Strong consistency for account balance; eventual for activity feed. Quorum writes (W=2) for durability. Read-your-writes: route user's reads to primary or wait for replica sync.\"","tags":["consistency","availability","quorum","cap","reliability","consistency-reliability","default","strong","sample","phrasing"],"topic":"consistency-reliability","component":"default","source":"11_consistency_reliability","docId":"11_consistency_reliability","keywords":["strong","sample","phrasing","consistency","account","balance","eventual","activity","feed","quorum","writes","durability"]}
{"id":"12_observability_cost_security#1","title":"Observability, Cost & Security","text":"# Observability, Cost & Security","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["observability","cost","security"]}
{"id":"12_observability_cost_security#2","title":"What it is","text":"## What it is\n\n**Observability:** Logs, metrics, traces to understand and debug system. **Cost:** Storage tiering, right-sizing. **Security:** Auth, encryption, compliance.","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","what"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["what","observability","logs","metrics","traces","understand","debug","system","cost","storage","tiering","right-sizing"]}
{"id":"12_observability_cost_security#3","title":"When to use","text":"## When to use\n\n- Production readiness; can't operate blind\n- Cost-sensitive; tier storage, optimize\n- PII, compliance; encrypt, audit","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","use"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["use","production","readiness","operate","blind","cost-sensitive","tier","storage","optimize","pii","compliance","encrypt"]}
{"id":"12_observability_cost_security#4","title":"When NOT to use","text":"## When NOT to use\n\n- Early design; focus on core flow first\n- When not asked; mention briefly","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","not","use"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["not","use","early","design","focus","core","flow","first","asked","mention","briefly"]}
{"id":"12_observability_cost_security#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Observability | Cost |\n|---------------|------|\n| More data = better debugging | More data = higher cost |\n| Sampling for high volume | Retention limits |\n| Structured logs vs free text | Hot vs cold storage |","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","tradeoffs"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["cost","more","data","tradeoffs","observability","---------------","------","better","debugging","higher","sampling","high"]}
{"id":"12_observability_cost_security#6","title":"Failure modes","text":"## Failure modes\n\n- Log explosion: cost, noise; sample, aggregate\n- No tracing: hard to debug across services\n- Keys in logs: security leak\n- Under-provisioned: outages; over: waste","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","failure","modes"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["failure","modes","log","explosion","cost","noise","sample","aggregate","tracing","hard","debug","across"]}
{"id":"12_observability_cost_security#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- SLI/SLO: p99 latency, error rate\n- Error budget: 99.9% = 43 min/month\n- Retention: logs 7–30 days; metrics 90 days\n- Auth: OAuth2, JWT, mTLS","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","numbers","mention"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["metrics","error","days","numbers","mention","sli","slo","p99","latency","rate","budget","min"]}
{"id":"12_observability_cost_security#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"How debug production issue?\"\n- \"What metrics alert on?\"\n- \"Cost at scale?\"\n- \"How secure user data?\"","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","common","interviewer","follow-ups"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["how","common","interviewer","follow-ups","debug","production","issue","what","metrics","alert","cost","scale"]}
{"id":"12_observability_cost_security#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Structured logs, metrics (QPS, latency, errors), distributed tracing. Alert on error rate, p99 latency. Encrypt at rest and in transit; auth via JWT. PII hashed or tokenized.\"","tags":["observability","slo","tracing","logging","metrics","security","cost","observability-cost-security","default","strong","sample","phrasing"],"topic":"observability-cost-security","component":"default","source":"12_observability_cost_security","docId":"12_observability_cost_security","keywords":["latency","strong","sample","phrasing","structured","logs","metrics","qps","errors","distributed","tracing","alert"]}
{"id":"13_interview_playbook#1","title":"Interview Playbook","text":"# Interview Playbook","tags":["interview","system-design","patterns","structure","interview-playbook","default"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["interview","playbook"]}
{"id":"13_interview_playbook#2","title":"What it is","text":"## What it is\n\nStructured approach to system design interviews: requirements, high-level design, deep dives, tradeoffs, failure modes.","tags":["interview","system-design","patterns","structure","interview-playbook","default","what"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["design","what","structured","approach","system","interviews","requirements","high-level","deep","dives","tradeoffs","failure"]}
{"id":"13_interview_playbook#3","title":"When to use","text":"## When to use\n\n- Every system design interview\n- When stuck; fall back to structure","tags":["interview","system-design","patterns","structure","interview-playbook","default","use"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["use","every","system","design","interview","stuck","fall","back","structure"]}
{"id":"13_interview_playbook#4","title":"When NOT to use","text":"## When NOT to use\n\n- Coding round; different format\n- When interviewer drives format; follow their lead","tags":["interview","system-design","patterns","structure","interview-playbook","default","not","use"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["format","not","use","coding","round","different","interviewer","drives","follow","their","lead"]}
{"id":"13_interview_playbook#5","title":"Tradeoffs","text":"## Tradeoffs\n\n| Structured | Ad-hoc |\n|------------|--------|\n| Covers bases | May miss areas |\n| Slower start | Faster dive |\n| Demonstrates method | Risk appearing scattered |","tags":["interview","system-design","patterns","structure","interview-playbook","default","tradeoffs"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["tradeoffs","structured","ad-hoc","------------","--------","covers","bases","miss","areas","slower","start","faster"]}
{"id":"13_interview_playbook#6","title":"Failure modes","text":"## Failure modes\n\n- Jumping to solution; always scope first\n- Ignoring numbers; estimate QPS, storage\n- No tradeoffs; every choice has pros/cons\n- Forgetting failure modes; \"what if X fails?\"","tags":["interview","system-design","patterns","structure","interview-playbook","default","failure","modes"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["failure","modes","jumping","solution","always","scope","first","ignoring","numbers","estimate","qps","storage"]}
{"id":"13_interview_playbook#7","title":"Metrics / numbers to mention","text":"## Metrics / numbers to mention\n\n- State assumptions: DAU, read/write ratio\n- Back-of-envelope: QPS, storage, bandwidth\n- SLOs: latency, availability\n- Capacity per component","tags":["interview","system-design","patterns","structure","interview-playbook","default","metrics","numbers","mention"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["metrics","numbers","mention","state","assumptions","dau","read","write","ratio","back-of-envelope","qps","storage"]}
{"id":"13_interview_playbook#8","title":"Common interviewer follow-ups","text":"## Common interviewer follow-ups\n\n- \"Go deeper on X\"\n- \"What's the bottleneck?\"\n- \"How would you scale that?\"\n- \"Tradeoffs?\"","tags":["interview","system-design","patterns","structure","interview-playbook","default","common","interviewer","follow-ups"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["common","interviewer","follow-ups","deeper","what","bottleneck","how","you","scale","tradeoffs"]}
{"id":"13_interview_playbook#9","title":"Strong sample phrasing","text":"## Strong sample phrasing\n\n\"Clarify requirements and constraints. Estimate capacity. Draw high-level diagram. Walk through read and write path. Identify bottlenecks. Add caching, replication, async where needed. Discuss failure modes and mitigations.\"","tags":["interview","system-design","patterns","structure","interview-playbook","default","strong","sample","phrasing"],"topic":"interview-playbook","component":"default","source":"13_interview_playbook","docId":"13_interview_playbook","keywords":["strong","sample","phrasing","clarify","requirements","constraints","estimate","capacity","draw","high-level","diagram","walk"]}
{"id":"caching#1","title":"caching","text":"# Caching","tags":["caching","cache"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["caching"]}
{"id":"caching#2","title":"What it is","text":"## What it is\n\nStore frequently accessed data in fast storage (memory, SSD) to reduce load on primary store and lower latency.","tags":["caching","cache","what"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["store","what","frequently","accessed","data","fast","storage","memory","ssd","reduce","load","primary"]}
{"id":"caching#3","title":"When to use","text":"## When to use\n\n- Read-heavy workload\n- Primary store slow or expensive\n- Can tolerate staleness (TTL)\n- Need sub-ms read latency","tags":["caching","cache","use"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["use","read-heavy","workload","primary","store","slow","expensive","tolerate","staleness","ttl","need","sub-ms"]}
{"id":"caching#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Cache-aside: app control, stale possible\n- Write-through: strong consistency, higher write latency\n- Write-behind: lowest write latency, data loss risk","tags":["caching","cache","tradeoffs"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["write","latency","tradeoffs","cache-aside","app","control","stale","possible","write-through","strong","consistency","higher"]}
{"id":"caching#5","title":"Failure modes","text":"## Failure modes\n\n- Cache stampede: key expires, many requests hit DB\n- Stale reads: TTL too long, invalidation bug\n- Cache host fail: in-memory data lost","tags":["caching","cache","failure","modes"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["cache","failure","modes","stampede","key","expires","many","requests","hit","stale","reads","ttl"]}
{"id":"caching#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Hit rate: 80–95%\n- TTL: seconds to hours\n- P99: cache <1ms vs DB 10–50ms\n- Eviction: LRU, memory bound","tags":["caching","cache","numbers","mention"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["numbers","mention","hit","rate","ttl","seconds","hours","p99","cache","1ms","50ms","eviction"]}
{"id":"caching#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"Write-through or write-back? Why?\"\n- \"Invalidation strategy?\"\n- \"What if cache goes down?\"\n- \"How to avoid cache stampede?\"","tags":["caching","cache","interview","prompts"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["cache","interview","prompts","write-through","write-back","why","invalidation","strategy","what","goes","down","how"]}
{"id":"caching#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Pattern: cache-aside, write-through, write-behind\n2. TTL and invalidation\n3. Stampede prevention: single-flier, probabilistic expiry\n4. Failure: degrade to DB, replication for HA","tags":["caching","cache","strong","answer","outline"],"topic":"caching","component":"cache","source":"caching","docId":"caching","keywords":["strong","answer","outline","pattern","cache-aside","write-through","write-behind","ttl","invalidation","stampede","prevention","single-flier"]}
{"id":"capacity_estimation#1","title":"capacity estimation","text":"# Capacity Estimation","tags":["capacity-estimation","default"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["capacity","estimation"]}
{"id":"capacity_estimation#2","title":"What it is","text":"## What it is\n\nBack-of-envelope math to size infrastructure: QPS, storage, bandwidth. Done early in design to identify bottlenecks and ballpark costs.","tags":["capacity-estimation","default","what"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["what","back-of-envelope","math","size","infrastructure","qps","storage","bandwidth","done","early","design","identify"]}
{"id":"capacity_estimation#3","title":"When to use it","text":"## When to use it\n\n- System design interview; show quantitative thinking\n- Pre-launch capacity planning\n- Cost estimation\n- Identifying scaling limits","tags":["capacity-estimation","default","use"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["use","system","design","interview","show","quantitative","thinking","pre-launch","capacity","planning","cost","estimation"]}
{"id":"capacity_estimation#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Rough vs precise: rough is fast; precise needs real traffic.\n- Assumptions matter: DAU, read/write ratio, payload size.\n- Growth: 2x, 5x, 10x headroom typical.","tags":["capacity-estimation","default","tradeoffs"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["rough","precise","tradeoffs","fast","needs","real","traffic","assumptions","matter","dau","read","write"]}
{"id":"capacity_estimation#5","title":"Failure scenarios","text":"## Failure scenarios\n\n- Under-provisioned: overload at launch. Scale up; add caching.\n- Over-provisioned: wasted cost. Right-size with monitoring.\n- Wrong assumptions: traffic pattern differs. Iterate.","tags":["capacity-estimation","default","failure","scenarios"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["failure","scenarios","under-provisioned","overload","launch","scale","add","caching","over-provisioned","wasted","cost","right-size"]}
{"id":"capacity_estimation#6","title":"Scaling considerations","text":"## Scaling considerations\n\n- Start with reads: usually 10:1 or 100:1 read:write.\n- Storage: retention × daily writes × replication factor.\n- Bandwidth: request size × QPS × 2 (in + out).\n- Peaks: 2–3x average common.","tags":["capacity-estimation","default","scaling","considerations"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["scaling","considerations","start","reads","usually","100","read","write","storage","retention","daily","writes"]}
{"id":"capacity_estimation#7","title":"Metrics to monitor","text":"## Metrics to monitor\n\n- Actual QPS vs estimated\n- Storage growth vs projection\n- Bandwidth utilization\n- Cost vs budget","tags":["capacity-estimation","default","metrics","monitor"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["metrics","monitor","actual","qps","estimated","storage","growth","projection","bandwidth","utilization","cost","budget"]}
{"id":"capacity_estimation#8","title":"Real-world examples","text":"## Real-world examples\n\n- 1M DAU, 10 requests/user/day → ~120 QPS average; 300–400 peak\n- 1KB average request → 400 KB/s = 3.2 Mbps\n- 100M users, 1KB profile, 3 replicas → 300 TB storage\n- Order of magnitude; refine with real data","tags":["capacity-estimation","default","real-world","examples"],"topic":"capacity-estimation","component":"default","source":"capacity_estimation","docId":"capacity_estimation","keywords":["average","300","400","1kb","real-world","examples","dau","requests","user","day","120","qps"]}
{"id":"consistency#1","title":"consistency","text":"# Consistency","tags":["consistency","default"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["consistency"]}
{"id":"consistency#2","title":"What it is","text":"## What it is\n\nGuarantees about when writes become visible to reads. Strong vs eventual consistency; CAP tradeoff.","tags":["consistency","default","what"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["what","guarantees","about","writes","become","visible","reads","strong","eventual","consistency","cap","tradeoff"]}
{"id":"consistency#3","title":"When to use","text":"## When to use\n\n- Strong: financial transactions, inventory\n- Eventual: social feeds, analytics, cache","tags":["consistency","default","use"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["use","strong","financial","transactions","inventory","eventual","social","feeds","analytics","cache"]}
{"id":"consistency#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Strong consistency: higher latency, lower availability\n- Eventual: lower latency, possible stale reads\n- CAP: pick 2 of Consistency, Availability, Partition tolerance","tags":["consistency","default","tradeoffs"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["consistency","latency","lower","availability","tradeoffs","strong","higher","eventual","possible","stale","reads","cap"]}
{"id":"consistency#5","title":"Failure modes","text":"## Failure modes\n\n- Stale reads from replicas\n- Split-brain in multi-leader\n- Write conflicts in distributed systems","tags":["consistency","default","failure","modes"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["failure","modes","stale","reads","from","replicas","split-brain","multi-leader","write","conflicts","distributed","systems"]}
{"id":"consistency#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Replication lag: ms (e.g. <100ms)\n- Quorum: W + R > N for read-your-writes\n- TTL for eventual consistency (cache)","tags":["consistency","default","numbers","mention"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["numbers","mention","replication","lag","100ms","quorum","read-your-writes","ttl","eventual","consistency","cache"]}
{"id":"consistency#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"What consistency do you need?\"\n- \"When do you get stale reads?\"\n- \"How do you handle replication lag?\"","tags":["consistency","default","interview","prompts"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["you","interview","prompts","what","consistency","need","get","stale","reads","how","handle","replication"]}
{"id":"consistency#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. State required consistency (strong vs eventual)\n2. Replication model: leader-based, multi-leader\n3. Read path: from leader vs replica\n4. Write path: synchronous vs async replication\n5. Tradeoff and why it's acceptable","tags":["consistency","default","strong","answer","outline"],"topic":"consistency","component":"default","source":"consistency","docId":"consistency","keywords":["strong","replication","path","answer","outline","state","required","consistency","eventual","model","leader-based","multi-leader"]}
{"id":"databases#1","title":"databases","text":"# Databases","tags":["databases","database"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["databases"]}
{"id":"databases#2","title":"What it is","text":"## What it is\n\nPersistent storage with ACID or BASE guarantees. SQL vs NoSQL; replication and failover.","tags":["databases","database","what"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["what","persistent","storage","acid","base","guarantees","sql","nosql","replication","failover"]}
{"id":"databases#3","title":"When to use","text":"## When to use\n\n- Persistent data\n- Transactions\n- Query patterns (relational vs key-value vs document)","tags":["databases","database","use"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["use","persistent","data","transactions","query","patterns","relational","key-value","document"]}
{"id":"databases#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- SQL: strong consistency, schema; scaling limits\n- NoSQL: flexible schema, scale-out; eventual consistency\n- Read replicas: scale reads; replication lag","tags":["databases","database","tradeoffs"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["consistency","schema","tradeoffs","sql","strong","scaling","limits","nosql","flexible","scale-out","eventual","read"]}
{"id":"databases#5","title":"Failure modes","text":"## Failure modes\n\n- Primary failure: failover time\n- Replication lag: stale reads\n- Connection exhaustion: connection pooling\n- Disk full, IOPS limit","tags":["databases","database","failure","modes"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["failure","connection","modes","primary","failover","time","replication","lag","stale","reads","exhaustion","pooling"]}
{"id":"databases#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Replication lag (ms)\n- Failover time (RTO)\n- Connection pool size\n- Read/write ratio","tags":["databases","database","numbers","mention"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["numbers","mention","replication","lag","failover","time","rto","connection","pool","size","read","write"]}
{"id":"databases#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"SQL or NoSQL? Why?\"\n- \"Replication lag?\"\n- \"Failover strategy?\"\n- \"Connection pooling?\"","tags":["databases","database","interview","prompts"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["interview","prompts","sql","nosql","why","replication","lag","failover","strategy","connection","pooling"]}
{"id":"databases#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Data model and access pattern\n2. Replication: primary-replica, multi-leader\n3. Consistency: read from leader vs replica\n4. Failover: automated, RTO\n5. Connection pooling, limits","tags":["databases","database","strong","answer","outline"],"topic":"databases","component":"database","source":"databases","docId":"databases","keywords":["strong","answer","outline","data","model","access","pattern","replication","primary-replica","multi-leader","consistency","read"]}
{"id":"failure_modes#1","title":"failure modes","text":"# Failure Modes","tags":["failure-modes","default"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["failure","modes"]}
{"id":"failure_modes#2","title":"What it is","text":"## What it is\n\nWays a system can fail: hardware, network, software, overload. Design for detection, mitigation, and recovery. Assume failures will happen.","tags":["failure-modes","default","what"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["what","ways","system","fail","hardware","network","software","overload","design","detection","mitigation","recovery"]}
{"id":"failure_modes#3","title":"When to use it","text":"## When to use it\n\n- Design phase: identify single points of failure\n- Operations: runbooks, playbooks\n- Post-incident: categorize and prevent recurrence","tags":["failure-modes","default","use"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["use","design","phase","identify","single","points","failure","operations","runbooks","playbooks","post-incident","categorize"]}
{"id":"failure_modes#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Redundancy vs cost: more replicas = higher cost\n- Fail fast vs retry: fail fast simplifies; retry masks transient failures\n- Circuit breaker: stops cascading; adds complexity","tags":["failure-modes","default","tradeoffs"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["cost","fail","fast","retry","tradeoffs","redundancy","more","replicas","higher","simplifies","masks","transient"]}
{"id":"failure_modes#5","title":"Failure scenarios","text":"## Failure scenarios\n\n- Node failure: replica takes over; RTO depends on detection + failover.\n- Network partition: split brain risk; quorum, fencing.\n- Disk full: no writes; monitoring, alerting.\n- Slow dependency: timeout, circuit breaker, fallback.\n- Thundering herd: many retries; exponential backoff, jitter.\n- Cascading: one failure triggers others; circuit breaker, bulkheads.","tags":["failure-modes","default","failure","scenarios"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["failure","circuit","breaker","scenarios","node","replica","takes","over","rto","depends","detection","failover"]}
{"id":"failure_modes#6","title":"Scaling considerations","text":"## Scaling considerations\n\n- More nodes: more failure domains; smaller blast radius.\n- Cross-region: regional outage; failover to another region.\n- Chaos engineering: inject failures; validate resilience.","tags":["failure-modes","default","scaling","considerations"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["more","scaling","considerations","nodes","failure","domains","smaller","blast","radius","cross-region","regional","outage"]}
{"id":"failure_modes#7","title":"Metrics to monitor","text":"## Metrics to monitor\n\n- Error rate, timeout rate\n- Latency degradation\n- Dependency health\n- Failover events, RTO actual\n- Circuit breaker trips","tags":["failure-modes","default","metrics","monitor"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["rate","metrics","monitor","error","timeout","latency","degradation","dependency","health","failover","events","rto"]}
{"id":"failure_modes#8","title":"Real-world examples","text":"## Real-world examples\n\n- Netflix Chaos Monkey: random instance kill\n- Circuit breaker: stop calling failing service\n- Bulkhead: isolate thread pool per dependency\n- Timeout: 99% under 100ms; fail at 200ms\n- Retry with exponential backoff: 1s, 2s, 4s","tags":["failure-modes","default","real-world","examples"],"topic":"failure-modes","component":"default","source":"failure_modes","docId":"failure_modes","keywords":["real-world","examples","netflix","chaos","monkey","random","instance","kill","circuit","breaker","stop","calling"]}
{"id":"foundations#1","title":"foundations","text":"# Foundations","tags":["fundamentals","default"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["foundations"]}
{"id":"foundations#2","title":"What it is","text":"## What it is\n\nSystem design is the practice of defining components, data flow, and tradeoffs to meet functional and non-functional requirements at scale.","tags":["fundamentals","default","what"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["what","system","design","practice","defining","components","data","flow","tradeoffs","meet","functional","non-functional"]}
{"id":"foundations#3","title":"When to use","text":"## When to use\n\n- Designing new systems or major features\n- Scaling existing systems\n- Preparing for system design interviews","tags":["fundamentals","default","use"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["systems","use","designing","new","major","features","scaling","existing","preparing","system","design","interviews"]}
{"id":"foundations#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Simplicity vs performance\n- Consistency vs availability (CAP)\n- Cost vs latency vs throughput","tags":["fundamentals","default","tradeoffs"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["tradeoffs","simplicity","performance","consistency","availability","cap","cost","latency","throughput"]}
{"id":"foundations#5","title":"Failure modes","text":"## Failure modes\n\n- Single point of failure\n- Cascading failures\n- Resource exhaustion (CPU, memory, connections)","tags":["fundamentals","default","failure","modes"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["failure","modes","single","point","cascading","failures","resource","exhaustion","cpu","memory","connections"]}
{"id":"foundations#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- QPS, p99 latency, availability (e.g. 99.9%)\n- Storage growth, retention\n- RTO/RPO for disaster recovery","tags":["fundamentals","default","numbers","mention"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["numbers","mention","qps","p99","latency","availability","storage","growth","retention","rto","rpo","disaster"]}
{"id":"foundations#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"Walk me through the high-level architecture\"\n- \"What are the bottlenecks?\"\n- \"How would you scale this 10x?\"","tags":["fundamentals","default","interview","prompts"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["interview","prompts","walk","through","high-level","architecture","what","bottlenecks","how","you","scale","10x"]}
{"id":"foundations#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Clarify requirements (functional + non-functional)\n2. Estimate capacity (QPS, storage)\n3. High-level components and data flow\n4. Identify bottlenecks and mitigation\n5. Tradeoffs and failure modes","tags":["fundamentals","default","strong","answer","outline"],"topic":"fundamentals","component":"default","source":"foundations","docId":"foundations","keywords":["strong","answer","outline","clarify","requirements","functional","non-functional","estimate","capacity","qps","storage","high-level"]}
{"id":"fundamentals#1","title":"fundamentals","text":"# System Design Fundamentals","tags":["fundamentals","default"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["system","design","fundamentals"]}
{"id":"fundamentals#2","title":"Load Balancer","text":"## Load Balancer\n\n**Routing strategies**\n- **Round robin:** Rotate through backends. Simple, no session awareness.\n- **Least connections:** Send to backend with fewest active connections. Better for uneven request duration.\n- **IP hash:** Same client IP → same backend. Enables sticky routing without app support.\n\n**Health checks:** Periodic probes (HTTP/TCP) to detect dead or overloaded backends. Remove from pool on failure; re-add when healthy. Typical interval 5–30s.\n\n**L4 vs L7:** L4 operates on IP/port; L7 sees HTTP, supports path-based routing, header inspection, and TLS termination.\n\n---","tags":["fundamentals","default","load","balancer"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["routing","backends","connections","backend","same","http","load","balancer","strategies","round","robin","rotate"]}
{"id":"fundamentals#3","title":"Cache","text":"## Cache\n\n**Patterns**\n- **Read-through:** App reads from cache; cache loads from DB on miss.\n- **Write-through:** Write goes to cache and DB synchronously. Strong consistency, higher latency.\n- **Write-back (write-behind):** Write to cache; async flush to DB. Low latency, risk of data loss on crash.\n\n**TTL:** Expiry time for entries. Balances freshness vs hit rate. Short TTL = fresher, more DB load.\n\n**Invalidation:** On write, invalidate or update cached copies. Hard cache invalidation is tricky in distributed setups—often use TTL + versioned keys or event-driven invalidation.\n\n---","tags":["fundamentals","default","cache"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["cache","write","ttl","invalidation","from","latency","patterns","read-through","app","reads","loads","miss"]}
{"id":"fundamentals#4","title":"Sharding","text":"## Sharding\n\n**Strategies**\n- **Hash-based:** `partition_key = hash(user_id) % num_shards`. Even distribution; range queries difficult.\n- **Range-based:** Partition by key range (e.g. A–M, N–Z). Good for range scans; risk of hot shards at boundaries.\n\n**Hot partitions:** One shard gets disproportionate load. Mitigate with secondary partition key, or split hot shards.\n\n---","tags":["fundamentals","default","sharding"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["range","hot","partition","key","shards","sharding","strategies","hash-based","partition_key","hash","user_id","num_shards"]}
{"id":"fundamentals#5","title":"Message Queues","text":"## Message Queues\n\n**Delivery semantics**\n- **At-least-once:** Consumer acks after processing. Retries on failure; duplicates possible.\n- **Exactly-once:** Requires idempotent consumers + transactional outbox or deduplication.\n\n**Retries:** Exponential backoff. Limit retries to avoid infinite loops.\n\n**DLQ (Dead Letter Queue):** Messages that exceed retries go to DLQ for inspection or replay.\n\n**Backpressure:** When consumers lag, producers slow down or reject. Prevents queue unbounded growth.\n\n---","tags":["fundamentals","default","message","queues"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["retries","consumers","dlq","queue","message","queues","delivery","semantics","at-least-once","consumer","acks","after"]}
{"id":"fundamentals#6","title":"Databases","text":"## Databases\n\n**Primary / Replica**\n- Primary handles writes; replicas replicate via WAL or binlog.\n- Replicas serve reads; reduce load on primary.\n- **Replication lag:** Writes on primary not yet visible on replica. Affects read-after-write consistency.\n\n---","tags":["fundamentals","default","databases"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["primary","replica","writes","replicas","databases","handles","replicate","via","wal","binlog","serve","reads"]}
{"id":"fundamentals#7","title":"Consistency & Availability","text":"## Consistency & Availability\n\n**Eventual consistency:** Replicas converge over time. Acceptable when immediate consistency not required (e.g. counters, analytics).\n\n**Quorum:** For N replicas, write to W and read from R. If W + R > N, read sees latest write. Tradeoffs: higher W/R = stronger consistency, lower availability.\n\n**CAP:** Under partition, choose consistency or availability. In practice, tune per operation.\n\n---","tags":["fundamentals","default","consistency","availability"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["consistency","availability","replicas","write","read","eventual","converge","over","time","acceptable","immediate","not"]}
{"id":"fundamentals#8","title":"SLO / SLI / Error Budgets","text":"## SLO / SLI / Error Budgets\n\n**SLI:** Measured metric (e.g. latency p99, error rate).\n**SLO:** Target for SLI (e.g. p99 < 200ms, 99.9% success).\n**Error budget:** Allowed failure before SLO breached. Drives release and incident response decisions.\n\n---","tags":["fundamentals","default","slo","sli","error","budgets"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["slo","sli","error","p99","budgets","measured","metric","latency","rate","target","200ms","success"]}
{"id":"fundamentals#9","title":"Observability","text":"## Observability\n\n**Logs:** Event records. Structured (JSON) for aggregation.\n**Metrics:** Aggregated counters/gauges (QPS, latency percentiles, error rate).\n**Traces:** Request flow across services. Correlate with trace IDs.\n\n---","tags":["fundamentals","default","observability"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["observability","logs","event","records","structured","json","aggregation","metrics","aggregated","counters","gauges","qps"]}
{"id":"fundamentals#10","title":"Cost Basics","text":"## Cost Basics\n\n**Hot vs cold storage:** Hot = low-latency, higher cost (SSD, in-memory). Cold = archival, cheaper (object storage, infrequent access). Tier by access pattern.","tags":["fundamentals","default","cost","basics"],"topic":"fundamentals","component":"default","source":"fundamentals","docId":"fundamentals","keywords":["cost","hot","cold","storage","access","basics","low-latency","higher","ssd","in-memory","archival","cheaper"]}
{"id":"interview_patterns#1","title":"interview patterns","text":"# Interview Patterns","tags":["interview-patterns","default"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["interview","patterns"]}
{"id":"interview_patterns#2","title":"What it is","text":"## What it is\n\nCommon structure and topics in system design interviews. Interviewers expect clarity on requirements, high-level design, deep dives, tradeoffs, and scaling.","tags":["interview-patterns","default","what"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["design","what","common","structure","topics","system","interviews","interviewers","expect","clarity","requirements","high-level"]}
{"id":"interview_patterns#3","title":"When to use it","text":"## When to use it\n\n- Preparing for system design interviews\n- Evaluating candidate responses\n- Structuring design discussions","tags":["interview-patterns","default","use"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["design","use","preparing","system","interviews","evaluating","candidate","responses","structuring","discussions"]}
{"id":"interview_patterns#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Breadth vs depth: cover more vs go deeper on fewer\n- Whiteboard vs conversational: visual helps; talking shows reasoning\n- Time box: 45 min typical; prioritize critical path","tags":["interview-patterns","default","tradeoffs"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["tradeoffs","breadth","depth","cover","more","deeper","fewer","whiteboard","conversational","visual","helps","talking"]}
{"id":"interview_patterns#5","title":"Failure scenarios","text":"## Failure scenarios\n\n- Vague requirements: design wrong system. Ask clarifying questions.\n- Jump to solution: miss key constraints. Requirements first.\n- No numbers: \"it scales\" unconvincing. Capacity estimation.\n- Ignore failure: \"assume it doesn't fail\" weak. Discuss failure modes.","tags":["interview-patterns","default","failure","scenarios"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["failure","requirements","scenarios","vague","design","wrong","system","ask","clarifying","questions","jump","solution"]}
{"id":"interview_patterns#6","title":"Scaling considerations","text":"## Scaling considerations\n\n- Start simple: single box, then add components\n- Explain why each component: load balancer for multiple app servers, etc.\n- End with tradeoffs: what you sacrificed and why","tags":["interview-patterns","default","scaling","considerations"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["why","scaling","considerations","start","simple","single","box","then","add","components","explain","each"]}
{"id":"interview_patterns#7","title":"Metrics to monitor","text":"## Metrics to monitor\n\n- Time spent per phase\n- Depth of follow-up answers\n- Coverage of: requirements, HLD, APIs, data model, scaling, failure","tags":["interview-patterns","default","metrics","monitor"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["metrics","monitor","time","spent","per","phase","depth","follow-up","answers","coverage","requirements","hld"]}
{"id":"interview_patterns#8","title":"Real-world examples","text":"## Real-world examples\n\n- Clarify: \"1M DAU or 1M QPS?\" \"Read-heavy or write-heavy?\"\n- High-level: \"Client → LB → App servers → DB. Add cache for reads.\"\n- Deep dive: \"For cache, what key? TTL? Invalidation?\"\n- Tradeoff: \"Strong consistency here; eventual for analytics.\"\n- Interview phases: requirements → HLD → APIs/data → scaling → failure → wrap-up","tags":["interview-patterns","default","real-world","examples"],"topic":"interview-patterns","component":"default","source":"interview_patterns","docId":"interview_patterns","keywords":["cache","real-world","examples","clarify","dau","qps","read-heavy","write-heavy","high-level","client","app","servers"]}
{"id":"load_balancer#1","title":"load balancer","text":"# Load Balancer","tags":["load-balancer","default"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["load","balancer"]}
{"id":"load_balancer#2","title":"What it is","text":"## What it is\n\nA component that distributes incoming traffic across multiple backend servers. Sits between clients and application servers. Can operate at L4 (TCP/UDP) or L7 (HTTP/HTTPS).","tags":["load-balancer","default","what"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["servers","what","component","distributes","incoming","traffic","across","multiple","backend","sits","between","clients"]}
{"id":"load_balancer#3","title":"When to use it","text":"## When to use it\n\n- Multiple app server instances for horizontal scaling\n- Need high availability—traffic must continue if one backend fails\n- Want to add/remove backends without client awareness\n- TLS termination or path-based routing required (L7 only)","tags":["load-balancer","default","use"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["use","multiple","app","server","instances","horizontal","scaling","need","high","availability","traffic","continue"]}
{"id":"load_balancer#4","title":"Tradeoffs","text":"## Tradeoffs\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| Round robin | Simple, stateless | Ignores load; long requests can skew distribution |\n| Least connections | Adapts to request duration | Requires connection tracking |\n| IP hash | Sticky without app support | Poor distribution if clients cluster; hot spots |\n| L4 | Fast, low overhead | No HTTP awareness, limited routing |\n| L7 | Path routing, header inspection, TLS | Higher latency, more CPU |","tags":["load-balancer","default","tradeoffs"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["------","distribution","routing","tradeoffs","approach","pros","cons","----------","round","robin","simple","stateless"]}
{"id":"load_balancer#5","title":"Failure scenarios","text":"## Failure scenarios\n\n- LB itself fails → single point of failure. Use multiple LBs behind DNS or anycast.\n- Health check too aggressive → flapping, backends removed unnecessarily.\n- Health check too slow → traffic to dead backend until detected.\n- Sticky sessions → backend crash loses session; failover complexity.","tags":["load-balancer","default","failure","scenarios"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["failure","health","check","too","backend","scenarios","itself","fails","single","point","use","multiple"]}
{"id":"load_balancer#6","title":"Scaling considerations","text":"## Scaling considerations\n\n- LB throughput limits (connections/sec, bandwidth). Scale vertically or add LBs.\n- Session state: avoid if possible; use external store if needed.\n- Backend capacity: add instances; LB auto-discovers via health checks.\n- Geographic: global LB (DNS, anycast) routes to nearest region.","tags":["load-balancer","default","scaling","considerations"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["add","scaling","considerations","throughput","limits","connections","sec","bandwidth","scale","vertically","lbs","session"]}
{"id":"load_balancer#7","title":"Metrics to monitor","text":"## Metrics to monitor\n\n- Request rate, error rate, latency p50/p99 per backend pool\n- Active connections per backend\n- Health check pass/fail rate\n- LB CPU, memory, connection count\n- Backend count, in/out of rotation","tags":["load-balancer","default","metrics","monitor"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["rate","backend","per","count","metrics","monitor","request","error","latency","p50","p99","pool"]}
{"id":"load_balancer#8","title":"Real-world examples","text":"## Real-world examples\n\n- NGINX, HAProxy: software LBs, L4/L7\n- AWS ALB/NLB: managed, auto-scaling\n- Cloudflare: global anycast, DDoS mitigation\n- Sticky sessions: e-commerce cart; stateful WebSocket","tags":["load-balancer","default","real-world","examples"],"topic":"load-balancer","component":"default","source":"load_balancer","docId":"load_balancer","keywords":["real-world","examples","nginx","haproxy","software","lbs","aws","alb","nlb","managed","auto-scaling","cloudflare"]}
{"id":"message_queue#1","title":"message queue","text":"# Message Queue","tags":["message-queue","default"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["message","queue"]}
{"id":"message_queue#2","title":"What it is","text":"## What it is\n\nAsynchronous buffer between producers and consumers. Producers publish messages; consumers process when ready. Decouples services, absorbs spikes, enables async workflows.","tags":["message-queue","default","what"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["producers","consumers","what","asynchronous","buffer","between","publish","messages","process","ready","decouples","services"]}
{"id":"message_queue#3","title":"When to use it","text":"## When to use it\n\n- Decouple services; producer doesn't wait for consumer\n- Absorb traffic spikes; queue buffers bursts\n- Async processing (email, notifications, background jobs)\n- Event-driven architecture; multiple consumers per event","tags":["message-queue","default","use"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["use","decouple","services","producer","doesn","wait","consumer","absorb","traffic","spikes","queue","buffers"]}
{"id":"message_queue#4","title":"Tradeoffs","text":"## Tradeoffs\n\n| Semantics | Duplicates | Complexity |\n|-----------|------------|------------|\n| At-least-once | Possible | Low |\n| At-most-once | No; may lose | Low |\n| Exactly-once | No | High; idempotency, dedup |","tags":["message-queue","default","tradeoffs"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["------------","low","tradeoffs","semantics","duplicates","complexity","-----------","at-least-once","possible","at-most-once","lose","exactly-once"]}
{"id":"message_queue#5","title":"Failure scenarios","text":"## Failure scenarios\n\n- Consumer slow: queue grows. Backpressure: block/reject producers.\n- Consumer crash: unacked messages re-queued. At-least-once = duplicates.\n- Queue full: producers blocked or reject. Need capacity planning.\n- Message poison: bad message crashes consumer repeatedly. DLQ.\n- Ordering: partition by key; global order expensive.","tags":["message-queue","default","failure","scenarios"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["consumer","queue","reject","producers","message","failure","scenarios","slow","grows","backpressure","block","crash"]}
{"id":"message_queue#6","title":"Scaling considerations","text":"## Scaling considerations\n\n- Partition by key for parallelism; order within partition.\n- Consumer groups: each partition consumed by one consumer in group.\n- Add partitions for more parallelism; rebalancing overhead.\n- Retention: longer = more storage; shorter = replay window.","tags":["message-queue","default","scaling","considerations"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["partition","parallelism","consumer","more","scaling","considerations","key","order","within","groups","each","consumed"]}
{"id":"message_queue#7","title":"Metrics to monitor","text":"## Metrics to monitor\n\n- Queue depth, lag (messages behind)\n- Publish rate, consume rate\n- Latency: produce ack, end-to-end\n- DLQ depth, dead-letter rate\n- Consumer lag per partition\n- Error rate, retry count","tags":["message-queue","default","metrics","monitor"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["rate","depth","lag","metrics","monitor","queue","messages","behind","publish","consume","latency","produce"]}
{"id":"message_queue#8","title":"Real-world examples","text":"## Real-world examples\n\n- Kafka: event log, high throughput\n- RabbitMQ: flexible routing, various protocols\n- SQS: managed, at-least-once\n- Order processing: queue orders; inventory service consumes\n- Notifications: fan-out to email, push, SMS","tags":["message-queue","default","real-world","examples"],"topic":"message-queue","component":"default","source":"message_queue","docId":"message_queue","keywords":["real-world","examples","kafka","event","log","high","throughput","rabbitmq","flexible","routing","various","protocols"]}
{"id":"observability#1","title":"observability","text":"# Observability","tags":["observability","default"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["observability"]}
{"id":"observability#2","title":"What it is","text":"## What it is\n\nLogging, metrics, tracing to understand system behavior, debug issues, and meet SLOs.","tags":["observability","default","what"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["what","logging","metrics","tracing","understand","system","behavior","debug","issues","meet","slos"]}
{"id":"observability#3","title":"When to use","text":"## When to use\n\n- Production systems\n- Debugging incidents\n- SLO/SLI tracking","tags":["observability","default","use"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["use","production","systems","debugging","incidents","slo","sli","tracking"]}
{"id":"observability#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Verbosity vs storage cost\n- Sampling vs completeness\n- Cardinality vs query performance","tags":["observability","default","tradeoffs"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["tradeoffs","verbosity","storage","cost","sampling","completeness","cardinality","query","performance"]}
{"id":"observability#5","title":"Failure modes","text":"## Failure modes\n\n- Log explosion (no sampling)\n- Missing correlation IDs\n- No alerting on key metrics\n- High cardinality (user IDs in tags)","tags":["observability","default","failure","modes"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["ids","failure","modes","log","explosion","sampling","missing","correlation","alerting","key","metrics","high"]}
{"id":"observability#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Retention: logs 7–30 days, metrics 90 days\n- Sampling: 1% or 10% for traces\n- SLO: 99.9% availability, p99 <200ms\n- Alert thresholds","tags":["observability","default","numbers","mention"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["days","numbers","mention","retention","logs","metrics","sampling","traces","slo","availability","p99","200ms"]}
{"id":"observability#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"What metrics do you alert on?\"\n- \"How do you debug a production issue?\"\n- \"What's your SLO?\"","tags":["observability","default","interview","prompts"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["what","you","interview","prompts","metrics","alert","how","debug","production","issue","your","slo"]}
{"id":"observability#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Three pillars: logs, metrics, traces\n2. Key metrics: latency, error rate, throughput\n3. Alerting: what, thresholds, runbooks\n4. Tracing: correlation IDs, span sampling\n5. SLOs and error budget","tags":["observability","default","strong","answer","outline"],"topic":"observability","component":"default","source":"observability","docId":"observability","keywords":["metrics","error","strong","answer","outline","three","pillars","logs","traces","key","latency","rate"]}
{"id":"queues#1","title":"queues","text":"# Queues (Message Queues)","tags":["messaging","queue"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["queues","message"]}
{"id":"queues#2","title":"What it is","text":"## What it is\n\nAsynchronous messaging between producers and consumers. Decouples components and buffers work for processing.","tags":["messaging","queue","what"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["what","asynchronous","messaging","between","producers","consumers","decouples","components","buffers","work","processing"]}
{"id":"queues#3","title":"When to use","text":"## When to use\n\n- Async processing (emails, notifications)\n- Peak load buffering\n- Decoupling services\n- Event-driven architecture","tags":["messaging","queue","use"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["use","async","processing","emails","notifications","peak","load","buffering","decoupling","services","event-driven","architecture"]}
{"id":"queues#4","title":"Tradeoffs","text":"## Tradeoffs\n\n| Pattern | Ordering | Duplicates | Complexity |\n|---------|----------|------------|------------|\n| At-least-once | No guarantee | Possible | Lower |\n| Exactly-once | Per-partition | No | Higher |","tags":["messaging","queue","tradeoffs"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["------------","tradeoffs","pattern","ordering","duplicates","complexity","---------","----------","at-least-once","guarantee","possible","lower"]}
{"id":"queues#5","title":"Failure modes","text":"## Failure modes\n\n- Consumer lag: queue grows; need to scale consumers\n- Poison messages: DLQ, retries\n- Ordering: partition key choice\n- Message loss: replication, acknowledgments","tags":["messaging","queue","failure","modes"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["failure","modes","consumer","lag","queue","grows","need","scale","consumers","poison","messages","dlq"]}
{"id":"queues#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Throughput: messages/sec per partition\n- Lag: consumer offset behind producer\n- Retention: e.g. 7 days Kafka\n- Retry count, DLQ threshold","tags":["messaging","queue","numbers","mention"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["numbers","mention","throughput","messages","sec","per","partition","lag","consumer","offset","behind","producer"]}
{"id":"queues#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"At-least-once or exactly-once? Why?\"\n- \"How do you handle duplicate processing?\"\n- \"What if a message fails 5 times?\"\n- \"How do you handle consumer lag?\"","tags":["messaging","queue","interview","prompts"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["how","you","handle","interview","prompts","at-least-once","exactly-once","why","duplicate","processing","what","message"]}
{"id":"queues#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Delivery semantics and why\n2. Idempotency for duplicate handling\n3. DLQ and retry strategy\n4. Partition key and ordering\n5. Monitoring: lag, error rate","tags":["messaging","queue","strong","answer","outline"],"topic":"messaging","component":"queue","source":"queues","docId":"queues","keywords":["strong","answer","outline","delivery","semantics","why","idempotency","duplicate","handling","dlq","retry","strategy"]}
{"id":"reliability#1","title":"reliability","text":"# Reliability","tags":["reliability","default"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["reliability"]}
{"id":"reliability#2","title":"What it is","text":"## What it is\n\nDesigning systems to continue operating correctly under failure conditions. Includes redundancy, failover, and graceful degradation.","tags":["reliability","default","what"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["what","designing","systems","continue","operating","correctly","under","failure","conditions","includes","redundancy","failover"]}
{"id":"reliability#3","title":"When to use","text":"## When to use\n\n- High-availability requirements (99.9%+)\n- Mission-critical systems\n- Multi-datacenter deployment","tags":["reliability","default","use"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["use","high-availability","requirements","mission-critical","systems","multi-datacenter","deployment"]}
{"id":"reliability#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Consistency vs availability\n- Cost of redundancy vs blast radius\n- Complexity of failover logic","tags":["reliability","default","tradeoffs"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["tradeoffs","consistency","availability","cost","redundancy","blast","radius","complexity","failover","logic"]}
{"id":"reliability#5","title":"Failure modes","text":"## Failure modes\n\n- Node/instance failure\n- Network partition\n- Cascading failure from overload\n- Data corruption or loss","tags":["reliability","default","failure","modes"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["failure","modes","node","instance","network","partition","cascading","from","overload","data","corruption","loss"]}
{"id":"reliability#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Availability targets: 99.9% (3 nines), 99.99% (4 nines)\n- RTO (recovery time objective), RPO (recovery point objective)\n- Replication lag in ms\n- Health check interval (e.g. 10s)","tags":["reliability","default","numbers","mention"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["nines","recovery","objective","numbers","mention","availability","targets","rto","time","rpo","point","replication"]}
{"id":"reliability#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"What happens when a node fails?\"\n- \"How do you detect and recover?\"\n- \"What's your RTO and RPO?\"","tags":["reliability","default","interview","prompts"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["what","interview","prompts","happens","node","fails","how","you","detect","recover","your","rto"]}
{"id":"reliability#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Redundancy: replicas, multi-AZ\n2. Detection: health checks, circuit breakers\n3. Failover: automated vs manual, failover time\n4. Degradation: what breaks, what keeps working\n5. RTO/RPO and how you achieve them","tags":["reliability","default","strong","answer","outline"],"topic":"reliability","component":"default","source":"reliability","docId":"reliability","keywords":["failover","what","strong","answer","outline","redundancy","replicas","multi-az","detection","health","checks","circuit"]}
{"id":"security#1","title":"security","text":"# Security","tags":["security","default"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["security"]}
{"id":"security#2","title":"What it is","text":"## What it is\n\nAuthentication, authorization, encryption, and protection of sensitive data in distributed systems.","tags":["security","default","what"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["what","authentication","authorization","encryption","protection","sensitive","data","distributed","systems"]}
{"id":"security#3","title":"When to use","text":"## When to use\n\n- User-facing systems\n- PII, financial data\n- Compliance (GDPR, HIPAA)","tags":["security","default","use"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["use","user-facing","systems","pii","financial","data","compliance","gdpr","hipaa"]}
{"id":"security#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Security vs UX (MFA, session length)\n- Encryption vs performance (TLS overhead)\n- Centralized auth vs per-service","tags":["security","default","tradeoffs"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["tradeoffs","security","mfa","session","length","encryption","performance","tls","overhead","centralized","auth","per-service"]}
{"id":"security#5","title":"Failure modes","text":"## Failure modes\n\n- Credential leak\n- Injection (SQL, NoSQL)\n- Man-in-the-middle (no TLS)\n- Excessive permissions","tags":["security","default","failure","modes"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["failure","modes","credential","leak","injection","sql","nosql","man-in-the-middle","tls","excessive","permissions"]}
{"id":"security#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Session TTL\n- Token expiry (JWT)\n- Rate limits (auth attempts)\n- Key rotation period","tags":["security","default","numbers","mention"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["numbers","mention","session","ttl","token","expiry","jwt","rate","limits","auth","attempts","key"]}
{"id":"security#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"How do you handle authentication?\"\n- \"How is PII protected?\"\n- \"Encryption at rest and in transit?\"","tags":["security","default","interview","prompts"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["how","interview","prompts","you","handle","authentication","pii","protected","encryption","rest","transit"]}
{"id":"security#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Auth: OAuth2, JWT, session management\n2. Authorization: RBAC, least privilege\n3. Encryption: TLS in transit, AES at rest\n4. PII: masking, retention, deletion\n5. Audit logging","tags":["security","default","strong","answer","outline"],"topic":"security","component":"default","source":"security","docId":"security","keywords":["strong","answer","outline","auth","oauth2","jwt","session","management","authorization","rbac","least","privilege"]}
{"id":"sharding#1","title":"sharding","text":"# Sharding","tags":["sharding","shard"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["sharding"]}
{"id":"sharding#2","title":"What it is","text":"## What it is\n\nHorizontal partitioning of data across multiple DB nodes. Each shard holds a subset of data by partition key.","tags":["sharding","shard","what"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["data","what","horizontal","partitioning","across","multiple","nodes","each","shard","holds","subset","partition"]}
{"id":"sharding#3","title":"When to use","text":"## When to use\n\n- Data exceeds single-node capacity\n- Need horizontal write scale\n- Hot partition avoidance via key distribution","tags":["sharding","shard","use"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["use","data","exceeds","single-node","capacity","need","horizontal","write","scale","hot","partition","avoidance"]}
{"id":"sharding#4","title":"Tradeoffs","text":"## Tradeoffs\n\n- Partition key choice: avoid hot shards\n- Cross-shard queries: expensive or impossible\n- Resharding: complex migration","tags":["sharding","shard","tradeoffs"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["tradeoffs","partition","key","choice","avoid","hot","shards","cross-shard","queries","expensive","impossible","resharding"]}
{"id":"sharding#5","title":"Failure modes","text":"## Failure modes\n\n- Hot shard: one partition gets disproportionate load\n- Resharding: data migration, downtime risk\n- Cross-shard transactions: 2PC complexity","tags":["sharding","shard","failure","modes"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["failure","modes","hot","shard","one","partition","gets","disproportionate","load","resharding","data","migration"]}
{"id":"sharding#6","title":"Numbers to mention","text":"## Numbers to mention\n\n- Shard count, QPS per shard\n- Partition key cardinality\n- Rebalancing time\n- Cross-shard query cost","tags":["sharding","shard","numbers","mention"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["shard","numbers","mention","count","qps","per","partition","key","cardinality","rebalancing","time","cross-shard"]}
{"id":"sharding#7","title":"Interview prompts","text":"## Interview prompts\n\n- \"How do you choose a partition key?\"\n- \"What if one shard is hot?\"\n- \"How do you add shards?\"\n- \"Cross-shard transactions?\"","tags":["sharding","shard","interview","prompts"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["how","you","interview","prompts","choose","partition","key","what","one","shard","hot","add"]}
{"id":"sharding#8","title":"Strong answer outline","text":"## Strong answer outline\n\n1. Partition key and why (avoid hot spots)\n2. Shard count and growth\n3. Hot partition mitigation\n4. Resharding strategy\n5. Cross-shard queries: avoid or accept cost","tags":["sharding","shard","strong","answer","outline"],"topic":"sharding","component":"shard","source":"sharding","docId":"sharding","keywords":["partition","avoid","hot","strong","answer","outline","key","why","spots","shard","count","growth"]}