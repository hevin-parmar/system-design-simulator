{
  "questions": [
    {
      "id": "design-1-instagram-lets-design-a-photo-sharing-se",
      "title": "Designing Instagram  Let's design a photo-sharing service like Instagram, where users can upload photos to share them with  other users. Similar Services: Flickr, Picasa Difficulty Level: Medium  1. What is Instagram?  Instagram is a social networking service which enables its users to upload and share their photos and  videos with other users. Instagram users can choose to share information either publicly or privately.  Anything shared publicly can be seen by any other user, whereas privately shared content can only be  accessed by a specified set of people. Instagram also enables its users to share through many other  social networking platforms, such as Facebook, Twitter, Flickr, and Tumblr.  For the sake of this exercise, we plan to design a simpler version of Instagram, where a user can share  photos and can also follow other users. The ‚ÄòNews Feed‚Äô for each user will consist of top photos of all  the people the user follows.  2. Requirements and Goals of the System  We‚Äôll focus on the following set of requirements while designing the Instagram:  Functional Requirements  1.   Users should be able to upload/download/view photos.  2.   Users can perform searches based on photo/video titles.  3.   Users can follow other users.  4.   The system should be able to generate and display a user‚Äôs News Feed consisting of top photos  from all the people the user follows.  Non-functional Requirements  1.   Our service needs to be highly available.  2.   The acceptable latency of the system is 200ms for News Feed generation.  3.   Consistency can take a hit (in the interest of availability), if a user doesn‚Äôt see a photo for a  while; it should be fine.  4.   The system should be highly reliable; any uploaded photo or video should never be lost.  Not in scope:   Adding tags to photos, searching photos on tags, commenting on photos, tagging users to  photos, who to follow, etc.  3. Some Design Considerations  The system would be read-heavy, so we will focus on building a system that can retrieve photos  quickly.  1.   Practically, users can upload as many photos as they like. Efficient management of storage  should be a crucial factor while designing this system.",
      "functional": [
        "Users should be able to upload/download/view photos.  2.   Users can perform searches based on photo/video titles.  3.   Users can follow other users.  4.   The system should be able to generate and display a user‚Äôs News Feed consisting of top photos  from all the people the user follows."
      ],
      "nonFunctional": [
        "Our service needs to be highly available.  2.   The acceptable latency of the system is 200ms for News Feed generation.  3.   Consistency can take a hit (in the interest of availability), if a user doesn‚Äôt see a photo for a  while; it should be fine.  4.   The system should be highly reliable; any uploaded photo or video should never be lost.  Not in scope:   Adding tags to photos, searching photos on tags, commenting on photos, tagging users to  photos, who to follow, etc.  3. Some Design Considerations  The system would be read-heavy, so we will focus on building a system that can retrieve photos  quickly.  1.   Practically, users can upload as many photos as they like. Efficient management of storage  should be a crucial factor while designing this system.",
        "Low latency is expected while viewing photos.  3.   Data should be 100% reliable. If a user uploads a photo, the system will guarantee that it will  never be lost.  4. Capacity Estimation and Constraints  ‚Ä¢   Let‚Äôs assume we have 500M total users, with 1M daily active users.  ‚Ä¢   2M new photos every day, 23 new photos every second.  ‚Ä¢   Average photo file size => 200KB  ‚Ä¢   Total space required for 1 day of photos  2M * 200KB => 400 GB  ‚Ä¢   Total space required for 10 years:  400GB * 365 (days a year) * 10 (years) ~= 1425TB  5. High Level System Design  At a high-level, we need to support two scenarios, one to upload photos and the other to view/search  photos. Our service would need some   object storage   servers to store photos and also some database  servers to store metadata information about the photos.  6. Database Schema  üêÄ   Defining the DB schema in the early stages of the interview would help to understand the data  flow among various components and later would guide towards data partitioning.  We need to store data about users, their uploaded photos, and people they follow. Photo table will store  all data related to a photo; we need to have an index on (PhotoID, CreationDate) since we need to fetch  recent photos first.",
        "A straightforward approach for storing the above schema would be to use an RDBMS like MySQL  since we require joins. But relational databases come with their challenges, especially when we need to  scale them. For details, please take a look at   SQL vs. NoSQL .  We can store photos in a distributed file storage like   HDFS   or   S3 .  We can store the above schema in a distributed key-value store to enjoy the benefits offered by NoSQL.  All the metadata related to photos can go to a table where the ‚Äòkey‚Äô would be the ‚ÄòPhotoID‚Äô and the  ‚Äòvalue‚Äô would be an object containing PhotoLocation, UserLocation, CreationTimestamp, etc.  We need to store relationships between users and photos, to know who owns which photo. We also  need to store the list of people a user follows. For both of these tables, we can use a wide-column  datastore like   Cassandra . For the ‚ÄòUserPhoto‚Äô table, the ‚Äòkey‚Äô would be ‚ÄòUserID‚Äô and the ‚Äòvalue‚Äô would  be the list of ‚ÄòPhotoIDs‚Äô the user owns, stored in different columns. We will have a similar scheme for  the ‚ÄòUserFollow‚Äô table.  Cassandra or key-value stores in general, always maintain a certain number of replicas to offer  reliability. Also, in such data stores, deletes don‚Äôt get applied instantly, data is retained for certain days  (to support undeleting) before getting removed from the system permanently.  7. Data Size Estimation  Let‚Äôs estimate how much data will be going into each table and how much total storage we will need  for 10 years.  User:   Assuming each ‚Äúint‚Äù and ‚ÄúdateTime‚Äù is four bytes, each row in the User‚Äôs table will be of 68  bytes:  UserID (4 bytes) + Name (20 bytes) + Email (32 bytes) + DateOfBirth (4 bytes) + CreationDate (4  bytes) + LastLogin (4 bytes) = 68 bytes  If we have 500 million users, we will need 32GB of total storage.  500 million * 68 ~= 32GB",
        "Photo:   Each row in Photo‚Äôs table will be of 284 bytes:  PhotoID (4 bytes) + UserID (4 bytes) + PhotoPath (256 bytes) + PhotoLatitude (4 bytes) +  PhotLongitude(4 bytes) + UserLatitude (4 bytes) + UserLongitude (4 bytes) + CreationDate (4 bytes) =  284 bytes  If 2M new photos get uploaded every day, we will need 0.5GB of storage for one day:  2M * 284 bytes ~= 0.5GB per day  For 10 years we will need 1.88TB of storage.  UserFollow:   Each row in the UserFollow table will consist of 8 bytes. If we have 500 million users  and on average each user follows 500 users. We would need 1.82TB of storage for the UserFollow  table:  500 million users * 500 followers * 8 bytes ~= 1.82TB  Total space required for all tables for 10 years will be 3.7TB:  32GB + 1.88TB + 1.82TB ~= 3.7TB  8. Component Design  Photo uploads (or writes) can be slow as they have to go to the disk, whereas reads will be faster,  especially if they are being served from cache.  Uploading users can consume all the available connections, as uploading is a slow process. This means  that ‚Äòreads‚Äô cannot be served if the system gets busy with all the write requests. We should keep in mind  that web servers have a connection limit before designing our system. If we assume that a web server  can have a maximum of 500 connections at any time, then it can‚Äôt have more than 500 concurrent  uploads or reads. To handle this bottleneck we can split reads and writes into separate services. We will  have dedicated servers for reads and different servers for writes to ensure that uploads don‚Äôt hog the  system.  Separating photos‚Äô read and write requests will also allow us to scale and optimize each of these  operations independently.",
        "Reliability and Redundancy  Losing files is not an option for our service. Therefore, we will store multiple copies of each file so that  if one storage server dies we can retrieve the photo from the other copy present on a different storage  server.  This same principle also applies to other components of the system. If we want to have high availability  of the system, we need to have multiple replicas of services running in the system, so that if a few  services die down the system still remains available and running. Redundancy removes the single point  of failure in the system.  If only one instance of a service is required to run at any point, we can run a redundant secondary copy  of the service that is not serving any traffic, but it can take control after the failover when primary has a  problem.  Creating redundancy in a system can remove single points of failure and provide a backup or spare  functionality if needed in a crisis. For example, if there are two instances of the same service running in  production and one fails or degrades, the system can failover to the healthy copy. Failover can happen  automatically or require manual intervention.",
        "Data Sharding  Let‚Äôs discuss different schemes for metadata sharding:  a. Partitioning based on UserID   Let‚Äôs assume we shard based on the ‚ÄòUserID‚Äô so that we can keep all  photos of a user on the same shard. If one DB shard is 1TB, we will need four shards to store 3.7TB of  data. Let‚Äôs assume for better performance and scalability we keep 10 shards.  So we‚Äôll find the shard number by UserID % 10 and then store the data there. To uniquely identify any  photo in our system, we can append shard number with each PhotoID.  How can we generate PhotoIDs?   Each DB shard can have its own auto-increment sequence for  PhotoIDs and since we will append ShardID with each PhotoID, it will make it unique throughout our  system.  What are the different issues with this partitioning scheme?  1.   How would we handle hot users? Several people follow such hot users and a lot of other people  see any photo they upload.  2.   Some users will have a lot of photos compared to others, thus making a non-uniform  distribution of storage.  3.   What if we cannot store all pictures of a user on one shard? If we distribute photos of a user  onto multiple shards will it cause higher latencies?  4.   Storing all photos of a user on one shard can cause issues like unavailability of all of the user‚Äôs  data if that shard is down or higher latency if it is serving high load etc.  b. Partitioning based on PhotoID   If we can generate unique PhotoIDs first and then find a shard  number through ‚ÄúPhotoID % 10‚Äù, the above problems will have been solved. We would not need to  append ShardID with PhotoID in this case as PhotoID will itself be unique throughout the system.",
        "How can we generate PhotoIDs?   Here we cannot have an auto-incrementing sequence in each shard  to define PhotoID because we need to know PhotoID first to find the shard where it will be stored. One  solution could be that we dedicate a separate database instance to generate auto-incrementing IDs. If  our PhotoID can fit into 64 bits, we can define a table containing only a 64 bit ID field. So whenever  we would like to add a photo in our system, we can insert a new row in this table and take that ID to be  our PhotoID of the new photo.  Wouldn‚Äôt this key generating DB be a single point of failure?   Yes, it would be. A workaround for  that could be defining two such databases with one generating even numbered IDs and the other odd  numbered. For the MySQL, the following script can define such sequences:  KeyGeneratingServer1:  auto-increment-increment = 2  auto-increment-offset = 1  KeyGeneratingServer2:  auto-increment-increment = 2  auto-increment-offset = 2  We can put a load balancer in front of both of these databases to round robin between them and to deal  with downtime. Both these servers could be out of sync with one generating more keys than the other,  but this will not cause any issue in our system. We can extend this design by defining separate ID tables  for Users, Photo-Comments, or other objects present in our system.  Alternately,   we can implement a ‚Äòkey‚Äô generation scheme similar to what we have discussed in  Designing a URL Shortening service like TinyURL .  How can we plan for the future growth of our system?   We can have a large number of logical  partitions to accommodate future data growth, such that in the beginning, multiple logical partitions  reside on a single physical database server. Since each database server can have multiple database  instances on it, we can have separate databases for each logical partition on any server. So whenever  we feel that a particular database server has a lot of data, we can migrate some logical partitions from it  to another server. We can maintain a config file (or a separate database) that can map our logical  partitions to database servers; this will enable us to move partitions around easily. Whenever we want  to move a partition, we only have to update the config file to announce the change.  11. Ranking and News Feed Generation  To create the News Feed for any given user, we need to fetch the latest, most popular and relevant  photos of the people the user follows.  For simplicity, let‚Äôs assume we need to fetch top 100 photos for a user‚Äôs News Feed. Our application  server will first get a list of people the user follows and then fetch metadata info of latest 100 photos  from each user. In the final step, the server will submit all these photos to our ranking algorithm which  will determine the top 100 photos (based on recency, likeness, etc.) and return them to the user. A  possible problem with this approach would be higher latency as we have to query multiple tables and  perform sorting/merging/ranking on the results. To improve the efficiency, we can pre-generate the  News Feed and store it in a separate table.",
        "Pre-generating the News Feed:   We can have dedicated servers that are continuously generating users‚Äô  News Feeds and storing them in a ‚ÄòUserNewsFeed‚Äô table. So whenever any user needs the latest photos  for their News Feed, we will simply query this table and return the results to the user.  Whenever these servers need to generate the News Feed of a user, they will first query the  UserNewsFeed table to find the last time the News Feed was generated for that user. Then, new News  Feed data will be generated from that time onwards (following the steps mentioned above).  What are the different approaches for sending News Feed contents to the users?  1. Pull:   Clients can pull the News Feed contents from the server on a regular basis or manually  whenever they need it. Possible problems with this approach are a) New data might not be shown to the  users until clients issue a pull request b) Most of the time pull requests will result in an empty response  if there is no new data.  2. Push:   Servers can push new data to the users as soon as it is available. To efficiently manage this,  users have to maintain a   Long Poll   request with the server for receiving the updates. A possible  problem with this approach is, a user who follows a lot of people or a celebrity user who has millions  of followers; in this case, the server has to push updates quite frequently.  3. Hybrid:   We can adopt a hybrid approach. We can move all the users who have a high number of  follows to a pull-based model and only push data to those users who have a few hundred (or thousand)  follows. Another approach could be that the server pushes updates to all the users not more than a  certain frequency, letting users with a lot of follows/updates to regularly pull data.  For a detailed discussion about News Feed generation, take a look at   Designing Facebook‚Äôs Newsfeed .  12. News Feed Creation with Sharded Data  One of the most important requirement to create the News Feed for any given user is to fetch the latest  photos from all people the user follows. For this, we need to have a mechanism to sort photos on their  time of creation. To efficiently do this, we can make photo creation time part of the PhotoID. As we  will have a primary index on PhotoID, it will be quite quick to find the latest PhotoIDs.  We can use epoch time for this. Let‚Äôs say our PhotoID will have two parts; the first part will be  representing epoch time and the second part will be an auto-incrementing sequence. So to make a new  PhotoID, we can take the current epoch time and append an auto-incrementing ID from our key-  generating DB. We can figure out shard number from this PhotoID ( PhotoID % 10) and store the photo  there.  What could be the size of our PhotoID ? Let‚Äôs say our epoch time starts today, how many bits we  would need to store the number of seconds for next 50 years?  86400 sec/day * 365 (days a year) * 50 (years) => 1.6 billion seconds",
        "We would need 31 bits to store this number. Since on the average, we are expecting 23 new photos per  second; we can allocate 9 bits to store auto incremented sequence. So every second we can store (2^9  => 512) new photos. We can reset our auto incrementing sequence every second.  We will discuss more details about this technique under ‚ÄòData Sharding‚Äô in   Designing Twitter .  13. Cache and Load balancing  Our service would need a massive-scale photo delivery system to serve the globally distributed users.  Our service should push its content closer to the user using a large number of geographically  distributed photo cache servers and use CDNs (for details see   Caching ).  We can introduce a cache for metadata servers to cache hot database rows. We can use Memcache to  cache the data and Application servers before hitting database can quickly check if the cache has  desired rows. Least Recently Used (LRU) can be a reasonable cache eviction policy for our system.  Under this policy, we discard the least recently viewed row first.  How can we build more intelligent cache?   If we go with 80-20 rule, i.e., 20% of daily read volume  for photos is generating 80% of traffic which means that certain photos are so popular that the majority  of people read them. This dictates that we can try caching 20% of daily read volume of photos and  metadata.  Designing Dropbox  Let's design a file hosting service like Dropbox or Google Drive. Cloud file storage enables users to  store their data on remote servers. Usually, these servers are maintained by cloud storage providers and  made available to users over a network (typically through the Internet). Users pay for their cloud data  storage on a monthly basis. Similar Services: OneDrive, Google Drive Difficulty Level: Medium  1. Why Cloud Storage?  Cloud file storage services have become very popular recently as they simplify the storage and  exchange of digital resources among multiple devices. The shift from using single personal computers  to using multiple devices with different platforms and operating systems such as smartphones and  tablets each with portable access from various geographical locations at any time, is believed to be  accountable for the huge popularity of cloud storage services. Following are some of the top benefits of  such services:  Availability:   The motto of cloud storage services is to have data availability anywhere, anytime. Users  can access their files/photos from any device whenever and wherever they like.  Reliability and Durability:   Another benefit of cloud storage is that it offers 100% reliability and  durability of data. Cloud storage ensures that users will never lose their data by keeping multiple copies  of the data stored on different geographically located servers.",
        "Scalability:   Users will never have to worry about getting out of storage space. With cloud storage you  have unlimited storage as long as you are ready to pay for it.  If you haven‚Äôt used   dropbox.com   before, we would highly recommend creating an account there and  uploading/editing a file and also going through the different options their service offers. This will help  you a lot in understanding this chapter.  2. Requirements and Goals of the System  üêÄ   You should always clarify requirements at the beginning of the interview. Be sure to ask  questions to find the exact scope of the system that the interviewer has in mind.  What do we wish to achieve from a Cloud Storage system? Here are the top-level requirements for our  system:  1.   Users should be able to upload and download their files/photos from any device.  2.   Users should be able to share files or folders with other users.  3.   Our service should support automatic synchronization between devices, i.e., after updating a file  on one device, it should get synchronized on all devices.  4.   The system should support storing large files up to a GB.  5.   ACID-ity is required. Atomicity, Consistency, Isolation and Durability of all file operations  should be guaranteed.  6.   Our system should support offline editing. Users should be able to add/delete/modify files while  offline, and as soon as they come online, all their changes should be synced to the remote  servers and other online devices.  Extended Requirements  ‚Ä¢   The system should support snapshotting of the data, so that users can go back to any version of  the files.  3. Some Design Considerations  ‚Ä¢   We should expect huge read and write volumes.  ‚Ä¢   Read to write ratio is expected to be nearly the same.  ‚Ä¢   Internally, files can be stored in small parts or chunks (say 4MB); this can provide a lot of  benefits i.e. all failed operations shall only be retried for smaller parts of a file. If a user fails to  upload a file, then only the failing chunk will be retried.  ‚Ä¢   We can reduce the amount of data exchange by transferring updated chunks only.  ‚Ä¢   By removing duplicate chunks, we can save storage space and bandwidth usage.  ‚Ä¢   Keeping a local copy of the metadata (file name, size, etc.) with the client can save us a lot of  round trips to the server.  ‚Ä¢   For small changes, clients can intelligently upload the diffs instead of the whole chunk.",
        "Capacity Estimation and Constraints  ‚Ä¢   Let‚Äôs assume that we have 500M total users, and 100M daily active users (DAU).  ‚Ä¢   Let‚Äôs assume that on average each user connects from three different devices.  ‚Ä¢   On average if a user has 200 files/photos, we will have 100 billion total files.  ‚Ä¢   Let‚Äôs assume that average file size is 100KB, this would give us ten petabytes of total storage.  100B * 100KB => 10PB  ‚Ä¢   Let‚Äôs also assume that we will have one million active connections per minute.",
        "Object 1",
        "High Level Design  The user will specify a folder as the workspace on their device. Any file/photo/folder placed in this  folder will be uploaded to the cloud, and whenever a file is modified or deleted, it will be reflected in  the same way in the cloud storage. The user can specify similar workspaces on all their devices and any  modification done on one device will be propagated to all other devices to have the same view of the  workspace everywhere.  At a high level, we need to store files and their metadata information like File Name, File Size,  Directory, etc., and who this file is shared with. So, we need some servers that can help the clients to  upload/download files to Cloud Storage and some servers that can facilitate updating metadata about  files and users. We also need some mechanism to notify all clients whenever an update happens so they  can synchronize their files.  As shown in the diagram below, Block servers will work with the clients to upload/download files from  cloud storage and Metadata servers will keep metadata of files updated in a SQL or NoSQL database.  Synchronization servers will handle the workflow of notifying all clients about different changes for  synchronization.  High level design for Dropbox  6. Component Design  Let‚Äôs go through the major components of our system one by one:  a. Client  The Client Application monitors the workspace folder on the user‚Äôs machine and syncs all files/folders  in it with the remote Cloud Storage. The client application will work with the storage servers to upload,  download, and modify actual files to backend Cloud Storage. The client also interacts with the remote",
        "Synchronization Service to handle any file metadata updates, e.g., change in the file name, size,  modification date, etc.  Here are some of the essential operations for the client:  1.   Upload and download files.  2.   Detect file changes in the workspace folder.  3.   Handle conflict due to offline or concurrent updates.  How do we handle file transfer efficiently?   As mentioned above, we can break each file into smaller  chunks so that we transfer only those chunks that are modified and not the whole file. Let‚Äôs say we  divide each file into fixed sizes of 4MB chunks. We can statically calculate what could be an optimal  chunk size based on 1) Storage devices we use in the cloud to optimize space utilization and  input/output operations per second (IOPS) 2) Network bandwidth 3) Average file size in the storage etc.  In our metadata, we should also keep a record of each file and the chunks that constitute it.  Should we keep a copy of metadata with Client?   Keeping a local copy of metadata not only enable  us to do offline updates but also saves a lot of round trips to update remote metadata.  How can clients efficiently listen to changes happening with other clients?   One solution could be  that the clients periodically check with the server if there are any changes. The problem with this  approach is that we will have a delay in reflecting changes locally as clients will be checking for  changes periodically compared to a server notifying whenever there is some change. If the client  frequently checks the server for changes, it will not only be wasting bandwidth, as the server has to  return an empty response most of the time, but will also be keeping the server busy. Pulling information  in this manner is not scalable.  A solution to the above problem could be to use HTTP long polling. With long polling the client  requests information from the server with the expectation that the server may not respond immediately.  If the server has no new data for the client when the poll is received, instead of sending an empty  response, the server holds the request open and waits for response information to become available.  Once it does have new information, the server immediately sends an HTTP/S response to the client,  completing the open HTTP/S Request. Upon receipt of the server response, the client can immediately  issue another server request for future updates.  Based on the above considerations, we can divide our client into following four parts:  I.   Internal Metadata Database   will keep track of all the files, chunks, their versions, and their  location in the file system.  II.   Chunker   will split the files into smaller pieces called chunks. It will also be responsible for  reconstructing a file from its chunks. Our chunking algorithm will detect the parts of the files that have  been modified by the user and only transfer those parts to the Cloud Storage; this will save us  bandwidth and synchronization time.",
        "III.   Watcher   will monitor the local workspace folders and notify the Indexer (discussed below) of any  action performed by the users, e.g. when users create, delete, or update files or folders. Watcher also  listens to any changes happening on other clients that are broadcasted by Synchronization service.  IV.   Indexer   will process the events received from the Watcher and update the internal metadata  database with information about the chunks of the modified files. Once the chunks are successfully  submitted/downloaded to the Cloud Storage, the Indexer will communicate with the remote  Synchronization Service to broadcast changes to other clients and update remote metadata database.  How should clients handle slow servers?   Clients should exponentially back-off if the server is  busy/not-responding. Meaning, if a server is too slow to respond, clients should delay their retries and  this delay should increase exponentially.  Should mobile clients sync remote changes immediately?   Unlike desktop or web clients, mobile  clients usually sync on demand to save user‚Äôs bandwidth and space.  b. Metadata Database  The Metadata Database is responsible for maintaining the versioning and metadata information about  files/chunks, users, and workspaces. The Metadata Database can be a relational database such as  MySQL, or a NoSQL database service such as DynamoDB. Regardless of the type of the database, the  Synchronization Service should be able to provide a consistent view of the files using a database,  especially if more than one user is working with the same file simultaneously. Since NoSQL data stores  do not support ACID properties in favor of scalability and performance, we need to incorporate the  support for ACID properties programmatically in the logic of our Synchronization Service in case we",
        "opt for this kind of database. However, using a relational database can simplify the implementation of  the Synchronization Service as they natively support ACID properties.  The metadata Database should be storing information about following objects:  1.   Chunks  2.   Files  3.   User  4.   Devices  5.   Workspace (sync folders)  c. Synchronization Service  The Synchronization Service is the component that processes file updates made by a client and applies  these changes to other subscribed clients. It also synchronizes clients‚Äô local databases with the  information stored in the remote Metadata DB. The Synchronization Service is the most important part  of the system architecture due to its critical role in managing the metadata and synchronizing users‚Äô  files. Desktop clients communicate with the Synchronization Service to either obtain updates from the  Cloud Storage or send files and updates to the Cloud Storage and, potentially, other users. If a client  was offline for a period, it polls the system for new updates as soon as they come online. When the  Synchronization Service receives an update request, it checks with the Metadata Database for  consistency and then proceeds with the update. Subsequently, a notification is sent to all subscribed  users or devices to report the file update.  The Synchronization Service should be designed in such a way that it transmits less data between  clients and the Cloud Storage to achieve a better response time. To meet this design goal, the  Synchronization Service can employ a differencing algorithm to reduce the amount of the data that  needs to be synchronized. Instead of transmitting entire files from clients to the server or vice versa, we  can just transmit the difference between two versions of a file. Therefore, only the part of the file that  has been changed is transmitted. This also decreases bandwidth consumption and cloud data storage for  the end user. As described above, we will be dividing our files into 4MB chunks and will be  transferring modified chunks only. Server and clients can calculate a hash (e.g., SHA-256) to see  whether to update the local copy of a chunk or not. On the server, if we already have a chunk with a  similar hash (even from another user), we don‚Äôt need to create another copy, we can use the same  chunk. This is discussed in detail later under Data Deduplication.  To be able to provide an efficient and scalable synchronization protocol we can consider using a  communication middleware between clients and the Synchronization Service. The messaging  middleware should provide scalable message queuing and change notifications to support a high  number of clients using pull or push strategies. This way, multiple Synchronization Service instances  can receive requests from a global request   Queue , and the communication middleware will be able to  balance its load.",
        "d. Message Queuing Service  An important part of our architecture is a messaging middleware that should be able to handle a  substantial number of requests. A scalable Message Queuing Service that supports asynchronous  message-based communication between clients and the Synchronization Service best fits the  requirements of our application. The Message Queuing Service supports asynchronous and loosely  coupled message-based communication between distributed components of the system. The Message  Queuing Service should be able to efficiently store any number of messages in a highly available,  reliable and scalable queue.  The Message Queuing Service will implement two types of queues in our system. The Request Queue  is a global queue and all clients will share it. Clients‚Äô requests to update the Metadata Database will be  sent to the Request Queue first, from there the Synchronization Service will take it to update metadata.  The Response Queues that correspond to individual subscribed clients are responsible for delivering the  update messages to each client. Since a message will be deleted from the queue once received by a  client, we need to create separate Response Queues for each subscribed client to share update  messages.  e. Cloud/Block Storage  Cloud/Block Storage stores chunks of files uploaded by the users. Clients directly interact with the  storage to send and receive objects from it. Separation of the metadata from storage enables us to use  any storage either in the cloud or in-house.",
        "Detailed component design for Dropbox  7. File Processing Workflow  The sequence below shows the interaction between the components of the application in a scenario  when Client A updates a file that is shared with Client B and C, so they should receive the update too.  If the other clients are not online at the time of the update, the Message Queuing Service keeps the  update notifications in separate response queues for them until they come online later.  1.   Client A uploads chunks to cloud storage.  2.   Client A updates metadata and commits changes.  3.   Client A gets confirmation and notifications are sent to Clients B and C about the changes.  4.   Client B and C receive metadata changes and download updated chunks.  8. Data Deduplication  Data deduplication is a technique used for eliminating duplicate copies of data to improve storage  utilization. It can also be applied to network data transfers to reduce the number of bytes that must be  sent. For each new incoming chunk, we can calculate a hash of it and compare that hash with all the  hashes of the existing chunks to see if we already have the same chunk present in our storage.  We can implement deduplication in two ways in our system:",
        "a. Post-process deduplication  With post-process deduplication, new chunks are first stored on the storage device and later some  process analyzes the data looking for duplication. The benefit is that clients will not need to wait for the  hash calculation or lookup to complete before storing the data, thereby ensuring that there is no  degradation in storage performance. Drawbacks of this approach are 1) We will unnecessarily be  storing duplicate data, though for a short time, 2) Duplicate data will be transferred consuming  bandwidth.  b. In-line deduplication  Alternatively, deduplication hash calculations can be done in real-time as the clients are entering data  on their device. If our system identifies a chunk that it has already stored, only a reference to the  existing chunk will be added in the metadata, rather than a full copy of the chunk. This approach will  give us optimal network and storage usage.  9. Metadata Partitioning  To scale out metadata DB, we need to partition it so that it can store information about millions of users  and billions of files/chunks. We need to come up with a partitioning scheme that would divide and store  our data in different DB servers.  1. Vertical Partitioning:   We can partition our database in such a way that we store tables related to one  particular feature on one server. For example, we can store all the user related tables in one database  and all files/chunks related tables in another database. Although this approach is straightforward to  implement it has some issues:  1.   Will we still have scale issues? What if we have trillions of chunks to be stored and our database  cannot support storing such a huge number of records? How would we further partition such  tables?  2.   Joining two tables in two separate databases can cause performance and consistency issues.  How frequently do we have to join user and file tables?  2. Range Based Partitioning:   What if we store files/chunks in separate partitions based on the first  letter of the File Path? In that case, we save all the files starting with the letter ‚ÄòA‚Äô in one partition and  those that start with the letter ‚ÄòB‚Äô into another partition and so on. This approach is called range based  partitioning. We can even combine certain less frequently occurring letters into one database partition.  We should come up with this partitioning scheme statically so that we can always store/find a file in a  predictable manner.  The main problem with this approach is that it can lead to unbalanced servers. For example, if we  decide to put all files starting with the letter ‚ÄòE‚Äô into a DB partition, and later we realize that we have  too many files that start with the letter ‚ÄòE‚Äô, to such an extent that we cannot fit them into one DB  partition.  3. Hash-Based Partitioning:   In this scheme we take a hash of the object we are storing and based on  this hash we figure out the DB partition to which this object should go. In our case, we can take the",
        "hash of the ‚ÄòFileID‚Äô of the File object we are storing to determine the partition the file will be stored.  Our hashing function will randomly distribute objects into different partitions, e.g., our hashing  function can always map any ID to a number between [1‚Ä¶256], and this number would be the partition  we will store our object.  This approach can still lead to overloaded partitions, which can be solved by using   Consistent Hashing .  10. Caching  We can have two kinds of caches in our system. To deal with hot files/chunks we can introduce a cache  for Block storage. We can use an off-the-shelf solution like   Memcached   that can store whole chunks  with its respective IDs/Hashes and Block servers before hitting Block storage can quickly check if the  cache has desired chunk. Based on clients‚Äô usage pattern we can determine how many cache servers we  need. A high-end commercial server can have 144GB of memory; one such server can cache 36K  chunks.  Which cache replacement policy would best fit our needs?   When the cache is full, and we want to  replace a chunk with a newer/hotter chunk, how would we choose? Least Recently Used (LRU) can be  a reasonable policy for our system. Under this policy, we discard the least recently used chunk first.  Load Similarly, we can have a cache for Metadata DB.  11. Load Balancer (LB)  We can add the Load balancing layer at two places in our system: 1) Between Clients and Block servers  and 2) Between Clients and Metadata servers. Initially, a simple Round Robin approach can be adopted  that distributes incoming requests equally among backend servers. This LB is simple to implement and  does not introduce any overhead. Another benefit of this approach is if a server is dead, LB will take it  out of the rotation and will stop sending any traffic to it. A problem with Round Robin LB is, it won‚Äôt  take server load into consideration. If a server is overloaded or slow, the LB will not stop sending new  requests to that server. To handle this, a more intelligent LB solution can be placed that periodically  queries backend server about their load and adjusts traffic based on that.  12. Security, Permissions and File Sharing  One of the primary concerns users will have while storing their files in the cloud is the privacy and  security of their data, especially since in our system users can share their files with other users or even  make them public to share it with everyone. To handle this, we will be storing the permissions of each  file in our metadata DB to reflect what files are visible or modifiable by any user."
      ]
    },
    {
      "id": "design-2-facebook-messenger-lets-design-an-instan",
      "title": "Designing Facebook Messenger  Let's design an instant messaging service like Facebook Messenger where users can send text messages  to each other through web and mobile interfaces.  1. What is Facebook Messenger?  Facebook Messenger is a software application which provides text-based instant messaging services to  its users. Messenger users can chat with their Facebook friends both from cell-phones and Facebook‚Äôs  website.  2. Requirements and Goals of the System  Our Messenger should meet the following requirements:  Functional Requirements:  1.   Messenger should support one-on-one conversations between users.  2.   Messenger should keep track of the online/offline statuses of its users.  3.   Messenger should support persistent storage of chat history.  Non-functional Requirements:  1.   Users should have real-time chat experience with minimum latency.  2.   Our system should be highly consistent; users should be able to see the same chat history on all  their devices.  3.   Messenger‚Äôs high availability is desirable; we can tolerate lower availability in the interest of  consistency.  Extended Requirements:  ‚Ä¢   Group Chats: Messenger should support multiple people talking to each other in a group.  ‚Ä¢   Push notifications: Messenger should be able to notify users of new messages when they are  offline.  3. Capacity Estimation and Constraints  Let‚Äôs assume that we have 500 million daily active users and on average each user sends 40 messages  daily; this gives us 20 billion messages per day.  Storage Estimation:   Let‚Äôs assume that on average a message is 100 bytes, so to store all the messages  for one day we would need 2TB of storage.  20 billion messages * 100 bytes => 2 TB/day  To store five years of chat history, we would need 3.6 petabytes of storage.  2 TB * 365 days * 5 years ~= 3.6 PB",
      "functional": [
        "Messenger should support one-on-one conversations between users.  2.   Messenger should keep track of the online/offline statuses of its users.  3.   Messenger should support persistent storage of chat history."
      ],
      "nonFunctional": [
        "Users should have real-time chat experience with minimum latency.  2.   Our system should be highly consistent; users should be able to see the same chat history on all  their devices.  3.   Messenger‚Äôs high availability is desirable; we can tolerate lower availability in the interest of  consistency.  Extended Requirements:  ‚Ä¢   Group Chats: Messenger should support multiple people talking to each other in a group.  ‚Ä¢   Push notifications: Messenger should be able to notify users of new messages when they are  offline.  3. Capacity Estimation and Constraints  Let‚Äôs assume that we have 500 million daily active users and on average each user sends 40 messages  daily; this gives us 20 billion messages per day.  Storage Estimation:   Let‚Äôs assume that on average a message is 100 bytes, so to store all the messages  for one day we would need 2TB of storage.  20 billion messages * 100 bytes => 2 TB/day  To store five years of chat history, we would need 3.6 petabytes of storage.  2 TB * 365 days * 5 years ~= 3.6 PB",
        "Other than the chat messages, we would also need to store users‚Äô information, messages‚Äô metadata (ID,  Timestamp, etc.). Not to mention, the above calculation doesn‚Äôt take data compression and replication  in consideration.  Bandwidth Estimation:   If our service is getting 2TB of data every day, this will give us 25MB of  incoming data for each second.  2 TB / 86400 sec ~= 25 MB/s  Since each incoming message needs to go out to another user, we will need the same amount of  bandwidth 25MB/s for both upload and download.  High level estimates:  Total messages   20 billion per day  Storage for each day   2TB  Storage for 5 years   3.6PB  Incomming data   25MB/s  Outgoing data   25MB/s  4. High Level Design  At a high-level, we will need a chat server that will be the central piece, orchestrating all the  communications between users. When a user wants to send a message to another user, they will connect  to the chat server and send the message to the server; the server then passes that message to the other  user and also stores it in the database.  The detailed workflow would look like this:  1.   User-A sends a message to User-B through the chat server.  2.   The server receives the message and sends an acknowledgment to User-A.  3.   The server stores the message in its database and sends the message to User-B.  4.   User-B receives the message and sends the acknowledgment to the server.",
        "The server notifies User-A that the message has been delivered successfully to User-B.  Request flow for sending a message  1   of 8  5. Detailed Component Design  Let‚Äôs try to build a simple solution first where everything runs on one server. At the high level our  system needs to handle the following use cases:  1.   Receive incoming messages and deliver outgoing messages.  2.   Store and retrieve messages from the database.  3.   Keep a record of which user is online or has gone offline, and notify all the relevant users about  these status changes.  Let‚Äôs talk about these scenarios one by one:  a. Messages Handling  How would we efficiently send/receive messages?   To send messages, a user needs to connect to the  server and post messages for the other users. To get a message from the server, the user has two  options:  1.   Pull model:   Users can periodically ask the server if there are any new messages for them.  2.   Push model:   Users can keep a connection open with the server and can depend upon the server  to notify them whenever there are new messages.  If we go with our first approach, then the server needs to keep track of messages that are still waiting to  be delivered, and as soon as the receiving user connects to the server to ask for any new message, the  server can return all the pending messages. To minimize latency for the user, they have to check the  server quite frequently, and most of the time they will be getting an empty response if there are no  pending message. This will waste a lot of resources and does not look like an efficient solution.  If we go with our second approach, where all the active users keep a connection open with the server,  then as soon as the server receives a message it can immediately pass the message to the intended user.  This way, the server does not need to keep track of the pending messages, and we will have minimum  latency, as the messages are delivered instantly on the opened connection.  How will clients maintain an open connection with the server?   We can use HTTP   Long Polling   or  WebSockets . In long polling, clients can request information from the server with the expectation that  the server may not respond immediately. If the server has no new data for the client when the poll is  received, instead of sending an empty response, the server holds the request open and waits for",
        "response information to become available. Once it does have new information, the server immediately  sends the response to the client, completing the open request. Upon receipt of the server response, the  client can immediately issue another server request for future updates. This gives a lot of improvements  in latencies, throughputs, and performance. The long polling request can timeout or can receive a  disconnect from the server, in that case, the client has to open a new request.  How can the server keep track of all the opened connection to redirect messages to the users  efficiently?   The server can maintain a hash table, where ‚Äúkey‚Äù would be the UserID and ‚Äúvalue‚Äù would  be the connection object. So whenever the server receives a message for a user, it looks up that user in  the hash table to find the connection object and sends the message on the open request.  What will happen when the server receives a message for a user who has gone offline?   If the  receiver has disconnected, the server can notify the sender about the delivery failure. If it is a  temporary disconnect, e.g., the receiver‚Äôs long-poll request just timed out, then we should expect a  reconnect from the user. In that case, we can ask the sender to retry sending the message. This retry  could be embedded in the client‚Äôs logic so that users don‚Äôt have to retype the message. The server can  also store the message for a while and retry sending it once the receiver reconnects.  How many chat servers we need?   Let‚Äôs plan for 500 million connections at any time. Assuming a  modern server can handle 50K concurrent connections at any time, we would need 10K such servers.  How do we know which server holds the connection to which user?   We can introduce a software  load balancer in front of our chat servers; that can map each UserID to a server to redirect the request.  How should the server process a ‚Äòdeliver message‚Äô request?   The server needs to do the following  things upon receiving a new message: 1) Store the message in the database 2) Send the message to the  receiver and 3) Send an acknowledgment to the sender.  The chat server will first find the server that holds the connection for the receiver and pass the message  to that server to send it to the receiver. The chat server can then send the acknowledgment to the  sender; we don‚Äôt need to wait for storing the message in the database (this can happen in the  background). Storing the message is discussed in the next section.  How does the messenger maintain the sequencing of the messages?   We can store a timestamp with  each message, which is the time the message is received by the server. This will still not ensure correct  ordering of messages for clients. The scenario where the server timestamp cannot determine the exact  order of messages would look like this:  1.   User-1 sends a message M1 to the server for User-2.  2.   The server receives M1 at T1.  3.   Meanwhile, User-2 sends a message M2 to the server for User-1.  4.   The server receives the message M2 at T2, such that T2 > T1.  5.   The server sends message M1 to User-2 and M2 to User-1.  So User-1 will see M1 first and then M2, whereas User-2 will see M2 first and then M1.",
        "To resolve this, we need to keep a sequence number with every message for each client. This sequence  number will determine the exact ordering of messages for EACH user. With this solution both clients  will see a different view of the message sequence, but this view will be consistent for them on all  devices.  b. Storing and retrieving the messages from the database  Whenever the chat server receives a new message, it needs to store it in the database. To do so, we have  two options:  1.   Start a separate thread, which will work with the database to store the message.  2.   Send an asynchronous request to the database to store the message.  We have to keep certain things in mind while designing our database:  1.   How to efficiently work with the database connection pool.  2.   How to retry failed requests.  3.   Where to log those requests that failed even after some retries.  4.   How to retry these logged requests (that failed after the retry) when all the issues have resolved.  Which storage system we should use?   We need to have a database that can support a very high rate of  small updates and also fetch a range of records quickly. This is required because we have a huge  number of small messages that need to be inserted in the database and, while querying, a user is mostly  interested in sequentially accessing the messages.  We cannot use RDBMS like MySQL or NoSQL like MongoDB because we cannot afford to read/write  a row from the database every time a user receives/sends a message. This will not only make the basic  operations of our service run with high latency, but also create a huge load on databases.  Both of our requirements can be easily met with a wide-column database solution like   HBase . HBase is  a column-oriented key-value NoSQL database that can store multiple values against one key into  multiple columns. HBase is modeled after Google‚Äôs   BigTable   and runs on top of Hadoop Distributed  File System ( HDFS ). HBase groups data together to store new data in a memory buffer and, once the  buffer is full, it dumps the data to the disk. This way of storage not only helps storing a lot of small data  quickly, but also fetching rows by the key or scanning ranges of rows. HBase is also an efficient  database to store variably sized data, which is also required by our service.  How should clients efficiently fetch data from the server?   Clients should paginate while fetching  data from the server. Page size could be different for different clients, e.g., cell phones have smaller  screens, so we need a fewer number of message/conversations in the viewport.  c. Managing user‚Äôs status  We need to keep track of user‚Äôs online/offline status and notify all the relevant users whenever a status  change happens. Since we are maintaining a connection object on the server for all active users, we can  easily figure out the user‚Äôs current status from this. With 500M active users at any time, if we have to",
        "broadcast each status change to all the relevant active users, it will consume a lot of resources. We can  do the following optimization around this:  1.   Whenever a client starts the app, it can pull the current status of all users in their friends‚Äô list.  2.   Whenever a user sends a message to another user that has gone offline, we can send a failure to  the sender and update the status on the client.  3.   Whenever a user comes online, the server can always broadcast that status with a delay of a few  seconds to see if the user does not go offline immediately.  4.   Client‚Äôs can pull the status from the server about those users that are being shown on the user‚Äôs  viewport. This should not be a frequent operation, as the server is broadcasting the online status  of users and we can live with the stale offline status of users for a while.  5.   Whenever the client starts a new chat with another user, we can pull the status at that time.  Detailed component design for Facebook messenger  Design Summary:   Clients will open a connection to the chat server to send a message; the server will  then pass it to the requested user. All the active users will keep a connection open with the server to  receive messages. Whenever a new message arrives, the chat server will push it to the receiving user on  the long poll request. Messages can be stored in HBase, which supports quick small updates, and range",
        "based searches. The servers can broadcast the online status of a user to other relevant users. Clients can  pull status updates for users who are visible in the client‚Äôs viewport on a less frequent basis.  6. Data partitioning  Since we will be storing a lot of data (3.6PB for five years), we need to distribute it onto multiple  database servers. What will be our partitioning scheme?  Partitioning based on UserID:   Let‚Äôs assume we partition based on the hash of the UserID so that we  can keep all messages of a user on the same database. If one DB shard is 4TB, we will have  ‚Äú3.6PB/4TB ~= 900‚Äù shards for five years. For simplicity, let‚Äôs assume we keep 1K shards. So we will  find the shard number by ‚Äúhash(UserID) % 1000‚Äù and then store/retrieve the data from there. This  partitioning scheme will also be very quick to fetch chat history for any user.  In the beginning, we can start with fewer database servers with multiple shards residing on one  physical server. Since we can have multiple database instances on a server, we can easily store multiple  partitions on a single server. Our hash function needs to understand this logical partitioning scheme so  that it can map multiple logical partitions on one physical server.  Since we will store an unlimited history of messages, we can start with a big number of logical  partitions, which will be mapped to fewer physical servers, and as our storage demand increases, we  can add more physical servers to distribute our logical partitions.  Partitioning based on MessageID:   If we store different messages of a user on separate database  shards, fetching a range of messages of a chat would be very slow, so we should not adopt this scheme.  7. Cache  We can cache a few recent messages (say last 15) in a few recent conversations that are visible in a  user‚Äôs viewport (say last 5). Since we decided to store all of the user‚Äôs messages on one shard, cache for  a user should entirely reside on one machine too.  8. Load balancing  We will need a load balancer in front of our chat servers; that can map each UserID to a server that  holds the connection for the user and then direct the request to that server. Similarly, we would need a  load balancer for our cache servers.  9. Fault tolerance and Replication  What will happen when a chat server fails?   Our chat servers are holding connections with the users.  If a server goes down, should we devise a mechanism to transfer those connections to some other  server? It‚Äôs extremely hard to failover TCP connections to other servers; an easier approach can be to  have clients automatically reconnect if the connection is lost.  Should we store multiple copies of user messages?   We cannot have only one copy of the user‚Äôs data,  because if the server holding the data crashes or is down permanently, we don‚Äôt have any mechanism to",
        "recover that data. For this, either we have to store multiple copies of the data on different servers or use  techniques like Reed-Solomon encoding to distribute and replicate it.  10. Extended Requirements  a. Group chat  We can have separate group-chat objects in our system that can be stored on the chat servers. A group-  chat object is identified by GroupChatID and will also maintain a list of people who are part of that  chat. Our load balancer can direct each group chat message based on GroupChatID and the server  handling that group chat can iterate through all the users of the chat to find the server handling the  connection of each user to deliver the message.  In databases, we can store all the group chats in a separate table partitioned based on GroupChatID.  b. Push notifications  In our current design user‚Äôs can only send messages to active users and if the receiving user is offline,  we send a failure to the sending user. Push notifications will enable our system to send messages to  offline users.  For Push notifications, each user can opt-in from their device (or a web browser) to get notifications  whenever there is a new message or event. Each manufacturer maintains a set of servers that handles  pushing these notifications to the user.  To have push notifications in our system, we would need to set up a Notification server, which will take  the messages for offline users and send them to the manufacture‚Äôs push notification server, which will  then send them to the user‚Äôs device.  Designing Twitter  Let's design a Twitter-like social networking service. Users of the service will be able to post tweets,  follow other people, and favorite tweets. Difficulty Level: Medium  1. What is Twitter?  Twitter is an online social networking service where users post and read short 140-character messages  called \"tweets.\" Registered users can post and read tweets, but those who are not registered can only  read them. Users access Twitter through their website interface, SMS, or mobile app.  2. Requirements and Goals of the System  We will be designing a simpler version of Twitter with the following requirements:  Functional Requirements",
        "Users should be able to post new tweets.  2.   A user should be able to follow other users.  3.   Users should be able to mark tweets as favorites.  4.   The service should be able to create and display a user‚Äôs timeline consisting of top tweets from  all the people the user follows.  5.   Tweets can contain photos and videos.  Non-functional Requirements  1.   Our service needs to be highly available.  2.   Acceptable latency of the system is 200ms for timeline generation.  3.   Consistency can take a hit (in the interest of availability); if a user doesn‚Äôt see a tweet for a  while, it should be fine.  Extended Requirements  1.   Searching for tweets.  2.   Replying to a tweet.  3.   Trending topics ‚Äì current hot topics/searches.  4.   Tagging other users.  5.   Tweet Notification.  6.   Who to follow? Suggestions?  7.   Moments.  3. Capacity Estimation and Constraints  Let‚Äôs assume we have one billion total users with 200 million daily active users (DAU). Also assume  we have 100 million new tweets every day and on average each user follows 200 people.  How many favorites per day?   If, on average, each user favorites five tweets per day we will have:  200M users * 5 favorites => 1B favorites  How many total tweet-views will our system generate?   Let‚Äôs assume on average a user visits their  timeline two times a day and visits five other people‚Äôs pages. On each page if a user sees 20 tweets,  then our system will generate 28B/day total tweet-views:  200M DAU * ((2 + 5) * 20 tweets) => 28B/day  Storage Estimates   Let‚Äôs say each tweet has 140 characters and we need two bytes to store a character  without compression. Let‚Äôs assume we need 30 bytes to store metadata with each tweet (like ID,  timestamp, user ID, etc.). Total storage we would need:  100M * (280 + 30) bytes => 30GB/day  What would our storage needs be for five years? How much storage we would need for users‚Äô data,  follows, favorites? We will leave this for the exercise.",
        "Not all tweets will have media, let‚Äôs assume that on average every fifth tweet has a photo and every  tenth has a video. Let‚Äôs also assume on average a photo is 200KB and a video is 2MB. This will lead us  to have 24TB of new media every day.  (100M/5 photos * 200KB) + (100M/10 videos * 2MB) ~= 24TB/day  Bandwidth Estimates   Since total ingress is 24TB per day, this would translate into 290MB/sec.  Remember that we have 28B tweet views per day. We must show the photo of every tweet (if it has a  photo), but let‚Äôs assume that the users watch every 3rd video they see in their timeline. So, total egress  will be:  (28B * 280 bytes) / 86400s of text => 93MB/s  + (28B/5 * 200KB ) / 86400s of photos => 13GB/S  + (28B/10/3 * 2MB ) / 86400s of Videos => 22GB/s  Total ~= 35GB/s  4. System APIs  üêÄ   Once we've finalized the requirements, it's always a good idea to define the system APIs. This  should explicitly state what is expected from the system.  We can have SOAP or REST APIs to expose the functionality of our service. Following could be the  definition of the API for posting a new tweet:  tweet(api_dev_key, tweet_data, tweet_location, user_location, media_ids,  maximum_results_to_return)  Parameters:  api_dev_key (string): The API developer key of a registered account. This will be used to, among other  things, throttle users based on their allocated quota.  tweet_data (string): The text of the tweet, typically up to 140 characters.  tweet_location (string): Optional location (longitude, latitude) this Tweet refers to. user_location  (string): Optional location (longitude, latitude) of the user adding the tweet.  media_ids (number[]): Optional list of media_ids to be associated with the Tweet. (All the media photo,  video, etc. need to be uploaded separately).  Returns:   (string)  A successful post will return the URL to access that tweet. Otherwise, an appropriate HTTP error is  returned.  5. High Level System Design  We need a system that can efficiently store all the new tweets, 100M/86400s => 1150 tweets per second  and read 28B/86400s => 325K tweets per second. It is clear from the requirements that this will be a  read-heavy system.",
        "At a high level, we need multiple application servers to serve all these requests with load balancers in  front of them for traffic distributions. On the backend, we need an efficient database that can store all  the new tweets and can support a huge number of reads. We also need some file storage to store photos  and videos.  Although our expected daily write load is 100 million and read load is 28 billion tweets. This means on  average our system will receive around 1160 new tweets and 325K read requests per second. This  traffic will be distributed unevenly throughout the day, though, at peak time we should expect at least a  few thousand write requests and around 1M read requests per second. We should keep this in mind  while designing the architecture of our system.  6. Database Schema  We need to store data about users, their tweets, their favorite tweets, and people they follow.  Tweet  <span>TweetID: int</span> PK  [Not supported by viewer]  <span>Content: varchar(140)</span>  [Not supported by viewer]  TweetLongitude: int<br>  [Not supported by viewer]  UserLongitude: int<br>  <span>CreationDate: datetime</span>  <span>NumFavorites</span>: int<br>  User  <span>UserID: int</span> PK  <span>Name: varchar(20)</span>  <span>Email: varchar(32)</span>  DateOfBirth: datetime<br>  CreationDate: datetime<br>  <span>LastLogin: datatime</span>  <span>UserFollow</span>  [Not supported by viewer] PK  Favorite  [Not supported by viewer] PK  CreationDate: datetime<br>",
        "For choosing between SQL and NoSQL databases to store the above schema, please see ‚ÄòDatabase  schema‚Äô under   Designing Instagram .  7. Data Sharding  Since we have a huge number of new tweets every day and our read load is extremely high too, we  need to distribute our data onto multiple machines such that we can read/write it efficiently. We have  many options to shard our data; let‚Äôs go through them one by one:  Sharding based on UserID:   We can try storing all the data of a user on one server. While storing, we  can pass the UserID to our hash function that will map the user to a database server where we will store  all of the user‚Äôs tweets, favorites, follows, etc. While querying for tweets/follows/favorites of a user, we  can ask our hash function where can we find the data of a user and then read it from there. This  approach has a couple of issues:  1.   What if a user becomes hot? There could be a lot of queries on the server holding the user. This  high load will affect the performance of our service.  2.   Over time some users can end up storing a lot of tweets or having a lot of follows compared to  others. Maintaining a uniform distribution of growing user data is quite difficult.  To recover from these situations either we have to repartition/redistribute our data or use consistent  hashing.  Sharding based on TweetID:   Our hash function will map each TweetID to a random server where we  will store that Tweet. To search for tweets, we have to query all servers, and each server will return a  set of tweets. A centralized server will aggregate these results to return them to the user. Let‚Äôs look into  timeline generation example; here are the number of steps our system has to perform to generate a  user‚Äôs timeline:  1.   Our application (app) server will find all the people the user follows.  2.   App server will send the query to all database servers to find tweets from these people.  3.   Each database server will find the tweets for each user, sort them by recency and return the top  tweets.  4.   App server will merge all the results and sort them again to return the top results to the user.  This approach solves the problem of hot users, but, in contrast to sharding by UserID, we have to query  all database partitions to find tweets of a user, which can result in higher latencies.  We can further improve our performance by introducing cache to store hot tweets in front of the  database servers.  Sharding based on Tweet creation time:   Storing tweets based on creation time will give us the  advantage of fetching all the top tweets quickly and we only have to query a very small set of servers.  The problem here is that the traffic load will not be distributed, e.g., while writing, all new tweets will  be going to one server and the remaining servers will be sitting idle. Similarly, while reading, the server  holding the latest data will have a very high load as compared to servers holding old data.",
        "What if we can combine sharding by TweedID and Tweet creation time?   If we don‚Äôt store tweet  creation time separately and use TweetID to reflect that, we can get benefits of both the approaches.  This way it will be quite quick to find the latest Tweets. For this, we must make each TweetID  universally unique in our system and each TweetID should contain a timestamp too.  We can use epoch time for this. Let‚Äôs say our TweetID will have two parts: the first part will be  representing epoch seconds and the second part will be an auto-incrementing sequence. So, to make a  new TweetID, we can take the current epoch time and append an auto-incrementing number to it. We  can figure out the shard number from this TweetID and store it there.  What could be the size of our TweetID? Let‚Äôs say our epoch time starts today, how many bits we would  need to store the number of seconds for the next 50 years?  86400 sec/day * 365 (days a year) * 50 (years) => 1.6B  We would need 31 bits to store this number. Since on average we are expecting 1150 new tweets per  second, we can allocate 17 bits to store auto incremented sequence; this will make our TweetID 48 bits  long. So, every second we can store (2^17 => 130K) new tweets. We can reset our auto incrementing  sequence every second. For fault tolerance and better performance, we can have two database servers  to generate auto-incrementing keys for us, one generating even numbered keys and the other generating  odd numbered keys.  If we assume our current epoch seconds are ‚Äú1483228800,‚Äù our TweetID will look like this:  1483228800 000001  1483228800 000002  1483228800 000003  1483228800 000004  ‚Ä¶  If we make our TweetID 64bits (8 bytes) long, we can easily store tweets for the next 100 years and  also store them for mili-seconds granularity.  In the above approach, we still have to query all the servers for timeline generation, but our reads (and  writes) will be substantially quicker.  1.   Since we don‚Äôt have any secondary index (on creation time) this will reduce our write latency.  2.   While reading, we don‚Äôt need to filter on creation-time as our primary key has epoch time  included in it.",
        "Cache  We can introduce a cache for database servers to cache hot tweets and users. We can use an off-the-  shelf solution like Memcache that can store the whole tweet objects. Application servers, before hitting  database, can quickly check if the cache has desired tweets. Based on clients‚Äô usage patterns we can  determine how many cache servers we need.  Which cache replacement policy would best fit our needs?   When the cache is full and we want to  replace a tweet with a newer/hotter tweet, how would we choose? Least Recently Used (LRU) can be a  reasonable policy for our system. Under this policy, we discard the least recently viewed tweet first.  How can we have a more intelligent cache?   If we go with 80-20 rule, that is 20% of tweets  generating 80% of read traffic which means that certain tweets are so popular that a majority of people  read them. This dictates that we can try to cache 20% of daily read volume from each shard.  What if we cache the latest data?   Our service can benefit from this approach. Let‚Äôs say if 80% of our  users see tweets from the past three days only; we can try to cache all the tweets from the past three  days. Let‚Äôs say we have dedicated cache servers that cache all the tweets from all the users from the  past three days. As estimated above, we are getting 100 million new tweets or 30GB of new data every  day (without photos and videos). If we want to store all the tweets from last three days, we will need  less than 100GB of memory. This data can easily fit into one server, but we should replicate it onto  multiple servers to distribute all the read traffic to reduce the load on cache servers. So whenever we  are generating a user‚Äôs timeline, we can ask the cache servers if they have all the recent tweets for that  user. If yes, we can simply return all the data from the cache. If we don‚Äôt have enough tweets in the  cache, we have to query the backend server to fetch that data. On a similar design, we can try caching  photos and videos from the last three days.  Our cache would be like a hash table where ‚Äòkey‚Äô would be ‚ÄòOwnerID‚Äô and ‚Äòvalue‚Äô would be a doubly  linked list containing all the tweets from that user in the past three days. Since we want to retrieve the  most recent data first, we can always insert new tweets at the head of the linked list, which means all  the older tweets will be near the tail of the linked list. Therefore, we can remove tweets from the tail to  make space for newer tweets.",
        "Timeline Generation  For a detailed discussion about timeline generation, take a look at   Designing Facebook‚Äôs Newsfeed .  10. Replication and Fault Tolerance  Since our system is read-heavy, we can have multiple secondary database servers for each DB partition.  Secondary servers will be used for read traffic only. All writes will first go to the primary server and  then will be replicated to secondary servers. This scheme will also give us fault tolerance, since  whenever the primary server goes down we can failover to a secondary server.  11. Load Balancing  We can add Load balancing layer at three places in our system 1) Between Clients and Application  servers 2) Between Application servers and database replication servers and 3) Between Aggregation  servers and Cache server. Initially, a simple Round Robin approach can be adopted; that distributes  incoming requests equally among servers. This LB is simple to implement and does not introduce any  overhead. Another benefit of this approach is that if a server is dead, LB will take it out of the rotation  and will stop sending any traffic to it. A problem with Round Robin LB is that it won‚Äôt take servers",
        "load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to  that server. To handle this, a more intelligent LB solution can be placed that periodically queries  backend server about their load and adjusts traffic based on that.  12. Monitoring  Having the ability to monitor our systems is crucial. We should constantly collect data to get an instant  insight into how our system is doing. We can collect following metrics/counters to get an understanding  of the performance of our service:  1.   New tweets per day/second, what is the daily peak?  2.   Timeline delivery stats, how many tweets per day/second our service is delivering.  3.   Average latency that is seen by the user to refresh timeline.  By monitoring these counters, we will realize if we need more replication, load balancing, or caching.  13. Extended Requirements  How do we serve feeds?   Get all the latest tweets from the people someone follows and merge/sort  them by time. Use pagination to fetch/show tweets. Only fetch top N tweets from all the people  someone follows. This N will depend on the client‚Äôs Viewport, since on a mobile we show fewer tweets  compared to a Web client. We can also cache next top tweets to speed things up.  Alternately, we can pre-generate the feed to improve efficiency; for details please see ‚ÄòRanking and  timeline generation‚Äô under   Designing Instagram .  Retweet:   With each Tweet object in the database, we can store the ID of the original Tweet and not  store any contents on this retweet object.  Trending Topics:   We can cache most frequently occurring hashtags or search queries in the last N  seconds and keep updating them after every M seconds. We can rank trending topics based on the  frequency of tweets or search queries or retweets or likes. We can give more weight to topics which are  shown to more people.  Who to follow? How to give suggestions?   This feature will improve user engagement. We can suggest  friends of people someone follows. We can go two or three levels down to find famous people for the  suggestions. We can give preference to people with more followers.  As only a few suggestions can be made at any time, use Machine Learning (ML) to shuffle and re-  prioritize. ML signals could include people with recently increased follow-ship, common followers if  the other person is following this user, common location or interests, etc.  Moments:   Get top news for different websites for past 1 or 2 hours, figure out related tweets, prioritize  them, categorize them (news, support, financial, entertainment, etc.) using ML ‚Äì supervised learning or  Clustering. Then we can show these articles as trending topics in Moments.  Search:   Search involves Indexing, Ranking, and Retrieval of tweets. A similar solution is discussed in  our next problem   Design Twitter Search ."
      ]
    },
    {
      "id": "design-3-youtube-or-netflix-lets-design-a-video-s",
      "title": "Designing Youtube or Netflix  Let's design a video sharing service like Youtube, where users will be able to upload/view/search  videos. Similar Services: netflix.com, vimeo.com, dailymotion.com, veoh.com Difficulty Level:  Medium  1. Why Youtube?  Youtube is one of the most popular video sharing websites in the world. Users of the service can  upload, view, share, rate, and report videos as well as add comments on videos.  2. Requirements and Goals of the System  For the sake of this exercise, we plan to design a simpler version of Youtube with following  requirements:  Functional Requirements:  1.   Users should be able to upload videos.  2.   Users should be able to share and view videos.  3.   Users should be able to perform searches based on video titles.  4.   Our services should be able to record stats of videos, e.g., likes/dislikes, total number of views,  etc.  5.   Users should be able to add and view comments on videos.  Non-Functional Requirements:  1.   The system should be highly reliable, any video uploaded should not be lost.  2.   The system should be highly available. Consistency can take a hit (in the interest of  availability); if a user doesn‚Äôt see a video for a while, it should be fine.  3.   Users should have a real time experience while watching videos and should not feel any lag.  Not in scope:   Video recommendations, most popular videos, channels, subscriptions, watch later,  favorites, etc.  3. Capacity Estimation and Constraints  Let‚Äôs assume we have 1.5 billion total users, 800 million of whom are daily active users. If, on average,  a user views five videos per day then the total video-views per second would be:  800M * 5 / 86400 sec => 46K videos/sec  Let‚Äôs assume our upload:view ratio is 1:200, i.e., for every video upload we have 200 videos viewed,  giving us 230 videos uploaded per second.  46K / 200 => 230 videos/sec",
      "functional": [
        "Users should be able to upload videos.  2.   Users should be able to share and view videos.  3.   Users should be able to perform searches based on video titles.  4.   Our services should be able to record stats of videos, e.g., likes/dislikes, total number of views,  etc.  5.   Users should be able to add and view comments on videos."
      ],
      "nonFunctional": [
        "The system should be highly reliable, any video uploaded should not be lost.  2.   The system should be highly available. Consistency can take a hit (in the interest of  availability); if a user doesn‚Äôt see a video for a while, it should be fine.  3.   Users should have a real time experience while watching videos and should not feel any lag.  Not in scope:   Video recommendations, most popular videos, channels, subscriptions, watch later,  favorites, etc.  3. Capacity Estimation and Constraints  Let‚Äôs assume we have 1.5 billion total users, 800 million of whom are daily active users. If, on average,  a user views five videos per day then the total video-views per second would be:  800M * 5 / 86400 sec => 46K videos/sec  Let‚Äôs assume our upload:view ratio is 1:200, i.e., for every video upload we have 200 videos viewed,  giving us 230 videos uploaded per second.  46K / 200 => 230 videos/sec",
        "Storage Estimates:   Let‚Äôs assume that every minute 500 hours worth of videos are uploaded to  Youtube. If on average, one minute of video needs 50MB of storage (videos need to be stored in  multiple formats), the total storage needed for videos uploaded in a minute would be:  500 hours * 60 min * 50MB => 1500 GB/min (25 GB/sec)  These numbers are estimated with ignoring video compression and replication, which would change  our estimates.  Bandwidth estimates:   With 500 hours of video uploads per minute and assuming each video upload  takes a bandwidth of 10MB/min, we would be getting 300GB of uploads every minute.  500 hours * 60 mins * 10MB => 300GB/min (5GB/sec)  Assuming an upload:view ratio of 1:200, we would need 1TB/s outgoing bandwidth.  4. System APIs  We can have SOAP or REST APIs to expose the functionality of our service. The following could be  the definitions of the APIs for uploading and searching videos:  uploadVideo(api_dev_key, video_title, vide_description, tags[], category_id,  default_language,  recording_details, video_contents)  Parameters:  api_dev_key (string): The API developer key of a registered account. This will be used to, among other  things, throttle users based on their allocated quota.  video_title (string): Title of the video.  vide_description (string): Optional description of the video.  tags (string[]): Optional tags for the video.  category_id (string): Category of the video, e.g., Film, Song, People, etc.  default_language (string): For example English, Mandarin, Hindi, etc.  recording_details (string): Location where the video was recorded.  video_contents (stream): Video to be uploaded.  Returns:   (string)  A successful upload will return HTTP 202 (request accepted) and once the video encoding is completed  the user is notified through email with a link to access the video. We can also expose a queryable API  to let users know the current status of their uploaded video.  searchVideo(api_dev_key, search_query, user_location, maximum_videos_to_return,  page_token)  Parameters:  api_dev_key (string): The API developer key of a registered account of our service.  search_query (string): A string containing the search terms.  user_location (string): Optional location of the user performing the search.  maximum_videos_to_return (number): Maximum number of results returned in one request.  page_token (string): This token will specify a page in the result set that should be returned.",
        "Returns:   (JSON)  A JSON containing information about the list of video resources matching the search query. Each video  resource will have a video title, a thumbnail, a video creation date, and a view count.  streamVideo(api_dev_key, video_id, offset, codec, resolution)  Parameters:  api_dev_key (string): The API developer key of a registered account of our service.  video_id (string): A string to identify the video.  offset (number): We should be able to stream video from any offset; this offset would be a time in  seconds from the beginning of the video. If we support playing/pausing a video from multiple devices,  we will need to store the offset on the server. This will enable the users to start watching a video on any  device from the same point where they left off.  codec (string) & resolution(string): We should send the codec and resolution info in the API from the  client to support play/pause from multiple devices. Imagine you are watching a video on your TV‚Äôs  Netflix app, paused it, and started watching it on your phone‚Äôs Netflix app. In this case, you would need  codec and resolution, as both these devices have a different resolution and use a different codec.  Returns:   (STREAM)  A media stream (a video chunk) from the given offset.  5. High Level Design  At a high-level we would need the following components:  1.   Processing Queue:   Each uploaded video will be pushed to a processing queue to be de-queued  later for encoding, thumbnail generation, and storage.  2.   Encoder:   To encode each uploaded video into multiple formats.  3.   Thumbnails generator:   To generate a few thumbnails for each video.  4.   Video and Thumbnail storage:   To store video and thumbnail files in some distributed file  storage.  5.   User Database:   To store user‚Äôs information, e.g., name, email, address, etc.  6.   Video metadata storage:   A metadata database to store all the information about videos like  title, file path in the system, uploading user, total views, likes, dislikes, etc. It will also be used  to store all the video comments.",
        "High level design of Youtube  6. Database Schema  Video metadata storage - MySql  Videos metadata can be stored in a SQL database. The following information should be stored with  each video:  ‚Ä¢   VideoID  ‚Ä¢   Title  ‚Ä¢   Description  ‚Ä¢   Size  ‚Ä¢   Thumbnail  ‚Ä¢   Uploader/User  ‚Ä¢   Total number of likes  ‚Ä¢   Total number of dislikes  ‚Ä¢   Total number of views  For each video comment, we need to store following information:  ‚Ä¢   CommentID  ‚Ä¢   VideoID  ‚Ä¢   UserID  ‚Ä¢   Comment  ‚Ä¢   TimeOfCreation  User data storage - MySql  ‚Ä¢   UserID, Name, email, address, age, registration details etc.",
        "Detailed Component Design  The service would be read-heavy, so we will focus on building a system that can retrieve videos  quickly. We can expect our read:write ratio to be 200:1, which means for every video upload there are  200 video views.  Where would videos be stored?   Videos can be stored in a distributed file storage system like   HDFS   or  GlusterFS .  How should we efficiently manage read traffic?   We should segregate our read traffic from write  traffic. Since we will have multiple copies of each video, we can distribute our read traffic on different  servers. For metadata, we can have master-slave configurations where writes will go to master first and  then gets applied at all the slaves. Such configurations can cause some staleness in data, e.g., when a  new video is added, its metadata would be inserted in the master first and before it gets applied at the  slave our slaves would not be able to see it; and therefore it will be returning stale results to the user.  This staleness might be acceptable in our system as it would be very short-lived and the user would be  able to see the new videos after a few milliseconds.  Where would thumbnails be stored?   There will be a lot more thumbnails than videos. If we assume  that every video will have five thumbnails, we need to have a very efficient storage system that can  serve a huge read traffic. There will be two consideration before deciding which storage system should  be used for thumbnails:  1.   Thumbnails are small files with, say, a maximum 5KB each.  2.   Read traffic for thumbnails will be huge compared to videos. Users will be watching one video  at a time, but they might be looking at a page that has 20 thumbnails of other videos.  Let‚Äôs evaluate storing all the thumbnails on a disk. Given that we have a huge number of files, we have  to perform a lot of seeks to different locations on the disk to read these files. This is quite inefficient  and will result in higher latencies.  Bigtable   can be a reasonable choice here as it combines multiple files into one block to store on the  disk and is very efficient in reading a small amount of data. Both of these are the two most significant  requirements of our service. Keeping hot thumbnails in the cache will also help in improving the  latencies and, given that thumbnails files are small in size, we can easily cache a large number of such  files in memory.  Video Uploads:   Since videos could be huge, if while uploading the connection drops we should  support resuming from the same point.  Video Encoding:   Newly uploaded videos are stored on the server and a new task is added to the  processing queue to encode the video into multiple formats. Once all the encoding will be completed  the uploader will be notified and the video is made available for view/sharing.",
        "Detailed component design of Youtube  8. Metadata Sharding  Since we have a huge number of new videos every day and our read load is extremely high, therefore,  we need to distribute our data onto multiple machines so that we can perform read/write operations  efficiently. We have many options to shard our data. Let‚Äôs go through different strategies of sharding  this data one by one:  Sharding based on UserID:   We can try storing all the data for a particular user on one server. While  storing, we can pass the UserID to our hash function which will map the user to a database server  where we will store all the metadata for that user‚Äôs videos. While querying for videos of a user, we can  ask our hash function to find the server holding the user‚Äôs data and then read it from there. To search  videos by titles we will have to query all servers and each server will return a set of videos. A  centralized server will then aggregate and rank these results before returning them to the user.  This approach has a couple of issues:  1.   What if a user becomes popular? There could be a lot of queries on the server holding that user;  this could create a performance bottleneck. This will also affect the overall performance of our  service.  2.   Over time, some users can end up storing a lot of videos compared to others. Maintaining a  uniform distribution of growing user data is quite tricky.  To recover from these situations either we have to repartition/redistribute our data or used consistent  hashing to balance the load between servers.",
        "Sharding based on VideoID:   Our hash function will map each VideoID to a random server where we  will store that Video‚Äôs metadata. To find videos of a user we will query all servers and each server will  return a set of videos. A centralized server will aggregate and rank these results before returning them  to the user. This approach solves our problem of popular users but shifts it to popular videos.  We can further improve our performance by introducing a cache to store hot videos in front of the  database servers.  9. Video Deduplication  With a huge number of users uploading a massive amount of video data our service will have to deal  with widespread video duplication. Duplicate videos often differ in aspect ratios or encodings, can  contain overlays or additional borders, or can be excerpts from a longer original video. The  proliferation of duplicate videos can have an impact on many levels:  1.   Data Storage: We could be wasting storage space by keeping multiple copies of the same video.  2.   Caching: Duplicate videos would result in degraded cache efficiency by taking up space that  could be used for unique content.  3.   Network usage: Duplicate videos will also increase the amount of data that must be sent over  the network to in-network caching systems.  4.   Energy consumption: Higher storage, inefficient cache, and network usage could result in  energy wastage.  For the end user, these inefficiencies will be realized in the form of duplicate search results, longer  video startup times, and interrupted streaming.  For our service, deduplication makes most sense early; when a user is uploading a video as compared  to post-processing it to find duplicate videos later. Inline deduplication will save us a lot of resources  that can be used to encode, transfer, and store the duplicate copy of the video. As soon as any user starts  uploading a video, our service can run video matching algorithms (e.g.,   Block Matching ,   Phase  Correlation , etc.) to find duplications. If we already have a copy of the video being uploaded, we can  either stop the upload and use the existing copy or continue the upload and use the newly uploaded  video if it is of higher quality. If the newly uploaded video is a subpart of an existing video or, vice  versa, we can intelligently divide the video into smaller chunks so that we only upload the parts that are  missing.  10. Load Balancing  We should use   Consistent Hashing   among our cache servers, which will also help in balancing the load  between cache servers. Since we will be using a static hash-based scheme to map videos to hostnames  it can lead to an uneven load on the logical replicas due to the different popularity of each video. For  instance, if a video becomes popular, the logical replica corresponding to that video will experience  more traffic than other servers. These uneven loads for logical replicas can then translate into uneven  load distribution on corresponding physical servers. To resolve this issue any busy server in one",
        "location can redirect a client to a less busy server in the same cache location. We can use dynamic  HTTP redirections for this scenario.  However, the use of redirections also has its drawbacks. First, since our service tries to load balance  locally, it leads to multiple redirections if the host that receives the redirection can‚Äôt serve the video.  Also, each redirection requires a client to make an additional HTTP request; it also leads to higher  delays before the video starts playing back. Moreover, inter-tier (or cross data-center) redirections lead  a client to a distant cache location because the higher tier caches are only present at a small number of  locations.  11. Cache  To serve globally distributed users, our service needs a massive-scale video delivery system. Our  service should push its content closer to the user using a large number of geographically distributed  video cache servers. We need to have a strategy that will maximize user performance and also evenly  distributes the load on its cache servers.  We can introduce a cache for metadata servers to cache hot database rows. Using Memcache to cache  the data and Application servers before hitting database can quickly check if the cache has the desired  rows. Least Recently Used (LRU) can be a reasonable cache eviction policy for our system. Under this  policy, we discard the least recently viewed row first.  How can we build more intelligent cache?   If we go with 80-20 rule, i.e., 20% of daily read volume  for videos is generating 80% of traffic, meaning that certain videos are so popular that the majority of  people view them; it follows that we can try caching 20% of daily read volume of videos and metadata.  12. Content Delivery Network (CDN)  A CDN is a system of distributed servers that deliver web content to a user based in the geographic  locations of the user, the origin of the web page and a content delivery server. Take a look at ‚ÄòCDN‚Äô  section in our   Caching   chapter.  Our service can move popular videos to CDNs:  ‚Ä¢   CDNs replicate content in multiple places. There‚Äôs a better chance of videos being closer to the  user and, with fewer hops, videos will stream from a friendlier network.  ‚Ä¢   CDN machines make heavy use of caching and can mostly serve videos out of memory.  Less popular videos (1-20 views per day) that are not cached by CDNs can be served by our servers in  various data centers.  13. Fault Tolerance  We should use   Consistent Hashing   for distribution among database servers. Consistent hashing will not  only help in replacing a dead server, but also help in distributing load among servers."
      ]
    },
    {
      "id": "design-4-typeahead-suggestion-lets-design-a-real-",
      "title": "Designing Typeahead Suggestion  Let's design a real-time suggestion service, which will recommend terms to users as they enter text for  searching. Similar Services: Auto-suggestions, Typeahead search Difficulty: Medium  1. What is Typeahead Suggestion?  Typeahead suggestions enable users to search for known and frequently searched terms. As the user  types into the search box, it tries to predict the query based on the characters the user has entered and  gives a list of suggestions to complete the query. Typeahead suggestions help the user to articulate their  search queries better. It‚Äôs not about speeding up the search process but rather about   guiding   the users  and lending them a helping hand in constructing their search query.  2. Requirements and Goals of the System  Functional Requirements:   As the user types in their query, our service should suggest top 10 terms  starting with whatever the user has typed.  Non-function Requirements:   The suggestions should appear in real-time. The user should be able to  see the suggestions within 200ms.  3. Basic System Design and Algorithm  The problem we are solving is that we have a lot of ‚Äòstrings‚Äô that we need to store in such a way that  users can search with any prefix. Our service will suggest next terms that will match the given prefix.  For example, if our database contains the following terms: cap, cat, captain, or capital and the user has  typed in ‚Äòcap‚Äô, our system should suggest ‚Äòcap‚Äô, ‚Äòcaptain‚Äô and ‚Äòcapital‚Äô.  Since we‚Äôve got to serve a lot of queries with minimum latency, we need to come up with a scheme that  can efficiently store our data such that it can be queried quickly. We can‚Äôt depend upon some database  for this; we need to store our index in memory in a highly efficient data structure.  One of the most appropriate data structures that can serve our purpose is the Trie (pronounced ‚Äútry‚Äù). A  trie is a tree-like data structure used to store phrases where each node stores a character of the phrase in  a sequential manner. For example, if we need to store ‚Äòcap, cat, caption, captain, capital‚Äô in the trie, it  would look like:",
      "functional": [
        "As the user types in their query, our service should suggest top 10 terms  starting with whatever the user has typed.  Non-function Requirements:   The suggestions should appear in real-time. The user should be able to  see the suggestions within 200ms.  3. Basic System Design and Algorithm  The problem we are solving is that we have a lot of ‚Äòstrings‚Äô that we need to store in such a way that  users can search with any prefix. Our service will suggest next terms that will match the given prefix.  For example, if our database contains the following terms: cap, cat, captain, or capital and the user has  typed in ‚Äòcap‚Äô, our system should suggest ‚Äòcap‚Äô, ‚Äòcaptain‚Äô and ‚Äòcapital‚Äô.  Since we‚Äôve got to serve a lot of queries with minimum latency, we need to come up with a scheme that  can efficiently store our data such that it can be queried quickly. We can‚Äôt depend upon some database  for this; we need to store our index in memory in a highly efficient data structure.  One of the most appropriate data structures that can serve our purpose is the Trie (pronounced ‚Äútry‚Äù). A  trie is a tree-like data structure used to store phrases where each node stores a character of the phrase in  a sequential manner. For example, if we need to store ‚Äòcap, cat, caption, captain, capital‚Äô in the trie, it  would look like:",
        "Now if the user has typed ‚Äòcap‚Äô, our service can traverse the trie to go to the node ‚ÄòP‚Äô to find all the  terms that start with this prefix (e.g., cap-tion, cap-ital etc).  We can merge nodes that have only one branch to save storage space. The above trie can be stored like  this:",
        "Should we have case insensitive trie?   For simplicity and search use-case, let‚Äôs assume our data is case  insensitive.  How to find top suggestion?   Now that we can find all the terms given a prefix, how can we know  what the top 10 terms are that we should suggest? One simple solution could be to store the count of  searches that terminated at each node, e.g., if users have searched about ‚ÄòCAPTAIN‚Äô 100 times and  ‚ÄòCAPTION‚Äô 500 times, we can store this number with the last character of the phrase. So now if the  user has typed ‚ÄòCAP‚Äô we know the top most searched word under the prefix ‚ÄòCAP‚Äô is ‚ÄòCAPTION‚Äô. So,  given a prefix, we can traverse the sub-tree under it to find the top suggestions.  Given a prefix, how much time will it take to traverse its sub-tree?   Given the amount of data we  need to index, we should expect a huge tree. Even traversing a sub-tree would take really long, e.g., the  phrase ‚Äòsystem design interview questions‚Äô is 30 levels deep. Since we have very strict latency  requirements we do need to improve the efficiency of our solution.  Can we store top suggestions with each node?   This can surely speed up our searches but will require  a lot of extra storage. We can store top 10 suggestions at each node that we can return to the user. We  have to bear the big increase in our storage capacity to achieve the required efficiency.  We can optimize our storage by storing only references of the terminal nodes rather than storing the  entire phrase. To find the suggested terms we need to traverse back using the parent reference from the  terminal node. We will also need to store the frequency with each reference to keep track of top  suggestions.",
        "How would we build this trie?   We can efficiently build our trie bottom up. Each parent node will  recursively call all the child nodes to calculate their top suggestions and their counts. Parent nodes will  combine top suggestions from all of their children to determine their top suggestions.  How to update the trie?   Assuming five billion searches every day, which would give us  approximately 60K queries per second. If we try to update our trie for every query it‚Äôll be extremely  resource intensive and this can hamper our read requests, too. One solution to handle this could be to  update our trie offline after a certain interval.  As the new queries come in we can log them and also track their frequencies. Either we can log every  query or do sampling and log every 1000th query. For example, if we don‚Äôt want to show a term which  is searched for less than 1000 times, it‚Äôs safe to log every 1000th searched term.  We can have a   Map-Reduce (MR)   set-up to process all the logging data periodically say every hour.  These MR jobs will calculate frequencies of all searched terms in the past hour. We can then update our  trie with this new data. We can take the current snapshot of the trie and update it with all the new terms  and their frequencies. We should do this offline as we don‚Äôt want our read queries to be blocked by  update trie requests. We can have two options:  1.   We can make a copy of the trie on each server to update it offline. Once done we can switch to  start using it and discard the old one.  2.   Another option is we can have a master-slave configuration for each trie server. We can update  slave while the master is serving traffic. Once the update is complete, we can make the slave our  new master. We can later update our old master, which can then start serving traffic, too.  How can we update the frequencies of typeahead suggestions?   Since we are storing frequencies of  our typeahead suggestions with each node, we need to update them too. We can update only differences  in frequencies rather than recounting all search terms from scratch. If we‚Äôre keeping count of all the  terms searched in last 10 days, we‚Äôll need to subtract the counts from the time period no longer  included and add the counts for the new time period being included. We can add and subtract  frequencies based on   Exponential Moving Average (EMA)   of each term. In EMA, we give more weight  to the latest data. It‚Äôs also known as the exponentially weighted moving average.  After inserting a new term in the trie, we‚Äôll go to the terminal node of the phrase and increase its  frequency. Since we‚Äôre storing the top 10 queries in each node, it is possible that this particular search  term jumped into the top 10 queries of a few other nodes. So, we need to update the top 10 queries of  those nodes then. We have to traverse back from the node to all the way up to the root. For every  parent, we check if the current query is part of the top 10. If so, we update the corresponding frequency.  If not, we check if the current query‚Äôs frequency is high enough to be a part of the top 10. If so, we  insert this new term and remove the term with the lowest frequency.  How can we remove a term from the trie?   Let‚Äôs say we have to remove a term from the trie because  of some legal issue or hate or piracy etc. We can completely remove such terms from the trie when the  regular update happens, meanwhile, we can add a filtering layer on each server which will remove any  such term before sending them to users.",
        "What could be different ranking criteria for suggestions?   In addition to a simple count, for terms  ranking, we have to consider other factors too, e.g., freshness, user location, language, demographics,  personal history etc.  4. Permanent Storage of the Trie  How to store trie in a file so that we can rebuild our trie easily - this will be needed when a  machine restarts?   We can take a snapshot of our trie periodically and store it in a file. This will enable  us to rebuild a trie if the server goes down. To store, we can start with the root node and save the trie  level-by-level. With each node, we can store what character it contains and how many children it has.  Right after each node, we should put all of its children. Let‚Äôs assume we have the following trie:  If we store this trie in a file with the above-mentioned scheme, we will have: ‚ÄúC2,A2,R1,T,P,O1,D‚Äù.  From this, we can easily rebuild our trie.  If you‚Äôve noticed, we are not storing top suggestions and their counts with each node. It is hard to store  this information; as our trie is being stored top down, we don‚Äôt have child nodes created before the  parent, so there is no easy way to store their references. For this, we have to recalculate all the top  terms with counts. This can be done while we are building the trie. Each node will calculate its top  suggestions and pass it to its parent. Each parent node will merge results from all of its children to  figure out its top suggestions.  5. Scale Estimation  If we are building a service that has the same scale as that of Google we can expect 5 billion searches  every day, which would give us approximately 60K queries per second.",
        "Since there will be a lot of duplicates in 5 billion queries, we can assume that only 20% of these will be  unique. If we only want to index the top 50% of the search terms, we can get rid of a lot of less  frequently searched queries. Let‚Äôs assume we will have 100 million unique terms for which we want to  build an index.  Storage Estimation:   If on the average each query consists of 3 words and if the average length of a  word is 5 characters, this will give us 15 characters of average query size. Assuming we need 2 bytes to  store a character, we will need 30 bytes to store an average query. So total storage we will need:  100 million * 30 bytes => 3 GB  We can expect some growth in this data every day, but we should also be removing some terms that are  not searched anymore. If we assume we have 2% new queries every day and if we are maintaining our  index for the last one year, total storage we should expect:  3GB + (0.02 * 3 GB * 365 days) => 25 GB  6. Data Partition  Although our index can easily fit on one server, we can still partition it in order to meet our  requirements of higher efficiency and lower latencies. How can we efficiently partition our data to  distribute it onto multiple servers?  a. Range Based Partitioning:   What if we store our phrases in separate partitions based on their first  letter. So we save all the terms starting with the letter ‚ÄòA‚Äô in one partition and those that start with the  letter ‚ÄòB‚Äô into another partition and so on. We can even combine certain less frequently occurring letters  into one database partition. We should come up with this partitioning scheme statically so that we can  always store and search terms in a predictable manner.  The main problem with this approach is that it can lead to unbalanced servers, for instance, if we decide  to put all terms starting with the letter ‚ÄòE‚Äô into a DB partition, but later we realize that we have too  many terms that start with letter ‚ÄòE‚Äô that we can‚Äôt fit into one DB partition.  We can see that the above problem will happen with every statically defined scheme. It is not possible  to calculate if each of our partitions will fit on one server statically.  b. Partition based on the maximum capacity of the server:   Let‚Äôs say we partition our trie based on  the maximum memory capacity of the servers. We can keep storing data on a server as long as it has  memory available. Whenever a sub-tree cannot fit into a server, we break our partition there to assign  that range to this server and move on the next server to repeat this process. Let‚Äôs say if our first trie  server can store all terms from ‚ÄòA‚Äô to ‚ÄòAABC‚Äô, which mean our next server will store from ‚ÄòAABD‚Äô  onwards. If our second server could store up to ‚ÄòBXA‚Äô, the next server will start from ‚ÄòBXB‚Äô, and so  on. We can keep a hash table to quickly access this partitioning scheme:  Server 1, A-AABC  Server 2, AABD-BXA  Server 3, BXB-CDA",
        "For querying, if the user has typed ‚ÄòA‚Äô we have to query both server 1 and 2 to find the top suggestions.  When the user has typed ‚ÄòAA‚Äô, we still have to query server 1 and 2, but when the user has typed  ‚ÄòAAA‚Äô we only need to query server 1.  We can have a load balancer in front of our trie servers which can store this mapping and redirect  traffic. Also, if we are querying from multiple servers, either we need to merge the results at the server  side to calculate overall top results or make our clients do that. If we prefer to do this on the server side,  we need to introduce another layer of servers between load balancers and trie severs (let‚Äôs call them  aggregator). These servers will aggregate results from multiple trie servers and return the top results to  the client.  Partitioning based on the maximum capacity can still lead us to hotspots, e.g., if there are a lot of  queries for terms starting with ‚Äòcap‚Äô, the server holding it will have a high load compared to others.  c. Partition based on the hash of the term:   Each term will be passed to a hash function, which will  generate a server number and we will store the term on that server. This will make our term distribution  random and hence minimize hotspots. To find typeahead suggestions for a term we have to ask all the  servers and then aggregate the results.  7. Cache  We should realize that caching the top searched terms will be extremely helpful in our service. There  will be a small percentage of queries that will be responsible for most of the traffic. We can have  separate cache servers in front of the trie servers holding most frequently searched terms and their  typeahead suggestions. Application servers should check these cache servers before hitting the trie  servers to see if they have the desired searched terms.  We can also build a simple Machine Learning (ML) model that can try to predict the engagement on  each suggestion based on simple counting, personalization, or trending data etc., and cache these terms.  8. Replication and Load Balancer  We should have replicas for our trie servers both for load balancing and also for fault tolerance. We  also need a load balancer that keeps track of our data partitioning scheme and redirects traffic based on  the prefixes.  9. Fault Tolerance  What will happen when a trie server goes down?   As discussed above we can have a master-slave  configuration; if the master dies, the slave can take over after failover. Any server that comes back up,  can rebuild the trie based on the last snapshot.  10. Typeahead Client  We can perform the following optimizations on the client to improve user‚Äôs experience:  1.   The client should only try hitting the server if the user has not pressed any key for 50ms.",
        "If the user is constantly typing, the client can cancel the in-progress requests.  3.   Initially, the client can wait until the user enters a couple of characters.  4.   Clients can pre-fetch some data from the server to save future requests.  5.   Clients can store the recent history of suggestions locally. Recent history has a very high rate of  being reused.  6.   Establishing an early connection with the server turns out to be one of the most important  factors. As soon as the user opens the search engine website, the client can open a connection  with the server. So when a user types in the first character, the client doesn‚Äôt waste time in  establishing the connection.  7.   The server can push some part of their cache to CDNs and Internet Service Providers (ISPs) for  efficiency.  11. Personalization  Users will receive some typeahead suggestions based on their historical searches, location, language,  etc. We can store the personal history of each user separately on the server and cache them on the client  too. The server can add these personalized terms in the final set before sending it to the user.  Personalized searches should always come before others.  Designing an API Rate Limiter  Let's design an API Rate Limiter which will throttle users based upon the number of the requests they  are sending. Difficulty Level: Medium  1. What is a Rate   Limiter?  Imagine we have a service which is receiving a huge number of requests, but it can only serve a limited  number of requests per second. To handle this problem we would need some kind of throttling or rate  limiting mechanism that would allow only a certain number of requests so our service can respond to  all of them. A rate limiter, at a high-level, limits the number of events an entity (user, device, IP, etc.)  can perform in a particular time window. For example:  ‚Ä¢   A user can send only one message per second.  ‚Ä¢   A user is allowed only three failed credit card transactions per day.  ‚Ä¢   A single IP can only create twenty accounts per day.  In general, a rate limiter caps how many requests a sender can issue in a specific time window. It then  blocks requests once the cap is reached.",
        "Why do we need API rate limiting?  Rate Limiting helps to protect services against abusive behaviors targeting the application layer like  Denial-of-service (DOS)   attacks, brute-force password attempts, brute-force credit card transactions,  etc. These attacks are usually a barrage of HTTP/S requests which may look like they are coming from  real users, but are typically generated by machines (or bots). As a result, these attacks are often harder  to detect and can more easily bring down a service, application, or an API.  Rate limiting is also used to prevent revenue loss, to reduce infrastructure costs, to stop spam, and to  stop online harassment. Following is a list of scenarios that can benefit from Rate limiting by making a  service (or API) more reliable:  ‚Ä¢   Misbehaving clients/scripts:   Either intentionally or unintentionally, some entities can  overwhelm a service by sending a large number of requests. Another scenario could be when a  user is sending a lot of lower-priority requests and we want to make sure that it doesn‚Äôt affect  the high-priority traffic. For example, users sending a high volume of requests for analytics data  should not be allowed to hamper critical transactions for other users.  ‚Ä¢   Security:   By limiting the number of the second-factor attempts (in 2-factor auth) that the users  are allowed to perform, for example, the number of times they‚Äôre allowed to try with a wrong  password.  ‚Ä¢   To prevent abusive behavior and bad design practices:   Without API limits, developers of  client applications would use sloppy development tactics, for example, requesting the same  information over and over again.  ‚Ä¢   To keep costs and resource usage under control:   Services are generally designed for normal  input behavior, for example, a user writing a single post in a minute. Computers could easily  push thousands/second through an API. Rate limiter enables controls on service APIs.  ‚Ä¢   Revenue:   Certain services might want to limit operations based on the tier of their customer‚Äôs  service and thus create a revenue model based on rate limiting. There could be default limits for  all the APIs a service offers. To go beyond that, the user has to buy higher limits  ‚Ä¢   To eliminate spikiness in traffic:   Make sure the service stays up for everyone else.  3. Requirements and Goals of the System  Our Rate Limiter should meet the following requirements:  Functional Requirements:  1.   Limit the number of requests an entity can send to an API within a time window, e.g., 15  requests per second.  2.   The APIs are accessible through a cluster, so the rate limit should be   considered across different  servers. The user should get an error message whenever the   defined threshold is crossed within  a single server or across a combination of servers."
      ],
      "nonFunctional": [
        "The system should be highly available. The rate limiter should always work since it protects our  service from external attacks.  2.   Our rate limiter should not introduce substantial latencies affecting the user experience.  4. How to do Rate Limiting?  Rate Limiting   is a process that is used to define the rate and speed at which consumers can access  APIs.   Throttling   is the process of controlling the usage of the APIs by customers during a given  period. Throttling can be defined at the application level and/or API level. When a throttle limit is  crossed,   the server returns HTTP status ‚Äú429 - Too many requests\".  5. What are different types of throttling?  Here are the three famous throttling types that are used by different services:  Hard Throttling:   The number of API requests cannot exceed the throttle limit.  Soft Throttling:   In this type, we can set the API request limit to exceed a certain percentage. For  example, if we have rate-limit of 100 messages a minute and 10% exceed-limit, our rate limiter will  allow up to 110 messages per minute.  Elastic or Dynamic Throttling : Under Elastic throttling, the number of requests can go beyond the  threshold if the system has some resources available. For example, if a user is allowed only 100  messages a minute, we can let the user send more than 100 messages a minute when there are free  resources available in the system.  6. What are different types of algorithms used for Rate Limiting?  Following are the two types of algorithms used for Rate Limiting:  Fixed Window Algorithm:   In this algorithm, the time window is considered from the start of the time-  unit to the end of the time-unit. For example, a period would be considered 0-60 seconds for a minute  irrespective of the time frame at which the API request has been made. In the diagram below, there are  two messages between 0-1 second and three messages between 1-2 seconds. If we have a rate limiting  of two messages a second, this algorithm will throttle only ‚Äòm5‚Äô.  0.0s   1.0s   2.0s  m1   m2   m3   m4   m5  Fixed Window - 2 messages   Fixed Window - 3 messages  Rolling Window - 4 messages",
        "Rolling Window Algorithm:   In this algorithm, the time window is considered from the fraction of the  time at which the request is made plus the time window length. For example, if there are two messages  sent at the 300th   millisecond and 400th   millisecond of a second, we‚Äôll count them as two messages  from the 300th   millisecond of that second up to the 300th   millisecond of next second.   In the above  diagram, keeping two messages a second, we‚Äôll throttle ‚Äòm3‚Äô and ‚Äòm4‚Äô.  7. High level design for Rate Limiter  Rate Limiter will be responsible for deciding which request will be served by the API servers and  which request will be declined. Once a new request arrives, the Web Server first asks the Rate Limiter  to decide if it will be served or throttled. If the request is not throttled, then it‚Äôll be passed to the API  servers.  High level design for Rate Limiter  8. Basic System Design and Algorithm  Let‚Äôs take the example where we want to limit the number of requests per user. Under this scenario, for  each unique user, we would keep a count representing how many requests the user has made and a  timestamp when we started counting the requests. We can keep it in a hashtable, where the ‚Äòkey‚Äô would  be the ‚ÄòUserID‚Äô and ‚Äòvalue‚Äô would be a structure containing an integer for the ‚ÄòCount‚Äô and an integer for  the Epoch time:",
        "Key   Value  UserID <span>{ Count, StartTime }</sp  Kristie <span>{ 3,&nbsp;1499818564 }</s  :  :  :  E.g.,  Let‚Äôs assume our rate limiter is allowing three requests per minute per user, so whenever a new request  comes in, our rate limiter will perform the following steps:  1.   If the ‚ÄòUserID‚Äô is not present in the hash-table, insert it, set the ‚ÄòCount‚Äô to 1, set ‚ÄòStartTime‚Äô to  the current time (normalized to a minute), and allow the request.  2.   Otherwise, find the record of the ‚ÄòUserID‚Äô and if   CurrentTime ‚Äì StartTime >=   1  min , set the ‚ÄòStartTime‚Äô to the current time, ‚ÄòCount‚Äô to 1, and allow the request.  3.   If   CurrentTime - StartTime <= 1 min   and  ‚Ä¢   If ‚ÄòCount < 3‚Äô, increment the Count and allow the request.  ‚Ä¢   If ‚ÄòCount >= 3‚Äô, reject the request.",
        "\"Kristie\" : { \"Count\": 1, \"StartTime\":&nbsp;1499828400 }  Request at 03:00:00 AM  Insert into hashtable  Allow request  Rate Limiter allowing three requests per minute for user \"Kristie\"  [Not supported by viewer]  Request at 03:00:10 AM  Increment Count  \"Kristie\" : { <font color=\"#000000\">\"Count\": 1, \"StartTime\":&nbsp;1499828460</font>&nbsp;}  Request at 03:01:05 AM  Reset Count and StartTime  [Not supported by viewer]  Request at 03:01:20 AM  Increment Count  [Not supported by viewer]  Request at 03:01:45 AM  Increment Count  [Not supported by viewer]  Request at 03:01:50 AM  Reject request  Allow request  Allow request  Allow request  Allow request  What are some of the problems with our algorithm?  1.   This is a   Fixed Window   algorithm since we‚Äôre resetting the ‚ÄòStartTime‚Äô at the end of every  minute, which means it can potentially allow twice the number of requests per minute. Imagine  if Kristie sends three requests at the last second of a minute, then she can immediately send",
        "three more requests at the very first second of the next minute, resulting in 6 requests in the  span of two seconds. The solution to this problem would be a sliding window algorithm which  we‚Äôll discuss later.  0.0min   1.0min   2.0min  3 Requests   <span>3 Requests</span>  6 Requests  [Not supported by viewer] [Not supported by viewer]  2.   Atomicity:   In a distributed environment, the ‚Äúread-and-then-write‚Äù behavior can create a race  condition. Imagine if Kristie‚Äôs current ‚ÄòCount‚Äô is ‚Äú2‚Äù and that she issues two more requests. If  two separate processes served each of these requests and concurrently read the Count before  either of them updated it, each process would think that Kristie could have one more request  and that she had not hit the rate limit.  [Not supported by viewer]  [Not supported by viewer]  Time  If we are using   Redis   to store our key-value, one solution to resolve the atomicity problem is to use  Redis lock   for the duration of the read-update operation. This, however, would come at the expense of  slowing down concurrent requests from the same user and introducing another layer of complexity. We  can use   Memcached , but it would have comparable complications.  If we are using a simple hash-table, we can have a custom implementation for ‚Äòlocking‚Äô each record to  solve our atomicity problems.  How much memory would we need to store all of the user data?   Let‚Äôs assume the simple solution  where we are keeping all of the data in a hash-table.  Let‚Äôs assume ‚ÄòUserID‚Äô takes 8 bytes. Let‚Äôs also assume a 2 byte ‚ÄòCount‚Äô, which can count up to 65k, is  sufficient for our use case. Although epoch time will need 4 bytes, we can choose to store only the  minute and second part, which can fit into 2 bytes. Hence, we need a total of 12 bytes to store a user‚Äôs  data:  8 + 2 + 2 = 12 bytes",
        "Let‚Äôs assume our hash-table has an overhead of 20 bytes for each record. If we need to track one  million users at any time, the total memory we would need would be 32MB:  (12 + 20) bytes * 1 million => 32MB  If we assume that we would need a 4-byte number to lock each user‚Äôs record to resolve our atomicity  problems, we would require a total 36MB memory.  This can easily fit on a single server; however we would not like to route all of our traffic through a  single machine. Also, if we assume a rate limit of 10 requests per second, this would translate into 10  million QPS for our rate limiter! This would be too much for a single server. Practically, we can assume  we would use a Redis or Memcached kind of a solution in a distributed setup. We‚Äôll be storing all the  data in the remote Redis servers and all the Rate Limiter servers will read (and update) these servers  before serving or throttling any request.  9. Sliding Window algorithm  We can maintain a sliding window if we can keep track of each request per user. We can store the  timestamp of each request in a Redis   Sorted Set   in our ‚Äòvalue‚Äô field of hash-table.  Key   Value  UserID <span>{ Sorted Set &lt;UnixTime&gt; }</span>  Kristie <span>{ 1499818000, &nbsp;</span>1499818500, 1499818860&nbsp;<span>}</span>  :  :  :  E.g.,  Let‚Äôs assume our rate limiter is allowing three requests per minute per user, so, whenever a new request  comes in, the Rate Limiter will perform following steps:  1.   Remove all the timestamps from the Sorted Set that are older than ‚ÄúCurrentTime - 1 minute‚Äù.  2.   Count the total number of elements in the sorted set. Reject the request if this count is greater  than our throttling limit of ‚Äú3‚Äù.  3.   Insert the current time in the sorted set and accept the request.",
        "\"Kristie\" : { 1499828400 }  Request at 03:00:00 AM  Insert into hashtable  Allow request  Rate Limiter allowing three requests per minute for user \"Kristie\"  [Not supported by viewer]  Request at 03:01:05 AM  Remove old timestamps and insert the current time  [Not supported by viewer]  Request at 03:01:20 AM  Insert the current time  [Not supported by viewer]  Request at 03:01:45 AM  Insert the current time  <font color=\"#ffffff\">\"Kristie\" : { 1499828465,&nbsp;1499828480,1499828505&nbsp;}</font><br>  Request at 03:01:50 AM  Reject request  [Not supported by viewer]  Request at 03:02:10 AM  Remove old timestamps and insert the current time  Allow request  Allow request  Allow request  Allow request  How much memory would we need to store all of the user data for sliding window?   Let‚Äôs assume  ‚ÄòUserID‚Äô takes 8 bytes. Each epoch time will require 4 bytes. Let‚Äôs suppose we need a rate limiting of  500 requests per hour. Let‚Äôs assume 20 bytes overhead for hash-table and 20 bytes overhead for the  Sorted Set. At max, we would need a total of 12KB to store one user‚Äôs data:",
        "8 + (4 + 20 (sorted set overhead)) * 500 + 20 (hash-table overhead) = 12KB  Here we are reserving 20 bytes overhead per element. In a sorted set, we can assume that we need at  least two pointers to maintain order among elements ‚Äî one pointer to the previous element and one to  the next element. On a 64bit machine, each pointer will cost 8 bytes. So we will need 16 bytes for  pointers. We added an extra word (4 bytes) for storing other overhead.  If we need to track one million users at any time, total memory we would need would be 12GB:  12KB * 1 million ~= 12GB  Sliding Window Algorithm takes a lot of memory compared to the Fixed Window; this would be a  scalability issue. What if we can combine the above two algorithms to optimize our memory usage?  10. Sliding Window with Counters  What if we keep track of request counts for each user using multiple fixed time windows, e.g., 1/60th  the size of our rate limit‚Äôs time window. For example, if we have an hourly rate limit we can keep a  count for each minute and calculate the sum of all counters in the past hour when we receive a new  request to calculate the throttling limit. This would reduce our memory footprint. Let‚Äôs take an example  where we rate-limit at 500 requests per hour with an additional limit of 10 requests per minute. This  means that when the sum of the counters with timestamps in the past hour exceeds the request  threshold (500), Kristie has exceeded the rate limit. In addition to that, she can‚Äôt send more than ten  requests per minute. This would be a reasonable and practical consideration, as none of the real users  would send frequent requests. Even if they do, they will see success with retries since their limits get  reset every minute.  We can store our counters in a   Redis Hash   since it offers incredibly efficient storage for fewer than 100  keys. When each request increments a counter in the hash, it also sets the hash to   expire   an hour later.  We will normalize each ‚Äòtime‚Äô to a minute.",
        "\"Kristie\" : { 1499828400: 1 }  Request at 03:00:00 AM  Insert into hashtable  Allow request  Rate Limiter allowing three requests per minute for user \"Kristie\"  [Not supported by viewer]  Request at 03:01:05 AM  Insert another timestamp  Request at 03:01:20 AM  Increment counter for current timestamp  Request at 03:01:45 AM  Increment counter for current timestamp  Request at 03:01:50 AM  Reject request  [Not supported by viewer]  Request at 04:01:00 AM  Remove old timestamps and insert the current time  Allow request  Allow request  Allow request  Allow request  [Not supported by viewer]  [Not supported by viewer]  [Not supported by viewer]  How much memory we would need to store all the user data for sliding window with counters?  Let‚Äôs assume ‚ÄòUserID‚Äô takes 8 bytes. Each epoch time will need 4 bytes, and the Counter would need 2  bytes. Let‚Äôs suppose we need a rate limiting of 500 requests per hour. Assume 20 bytes overhead for  hash-table and 20 bytes for Redis hash. Since we‚Äôll keep a count for each minute, at max, we would  need 60 entries for each user. We would need a total of 1.6KB to store one user‚Äôs data:",
        "8 + (4 + 2 + 20 (Redis hash overhead)) * 60 + 20 (hash-table overhead) = 1.6KB  If we need to track one million users at any time, total memory we would need would be 1.6GB:  1.6KB * 1 million ~= 1.6GB  So, our ‚ÄòSliding Window with Counters‚Äô algorithm uses 86% less memory than the simple sliding  window algorithm.  11. Data Sharding and Caching  We can shard based on the ‚ÄòUserID‚Äô to distribute the user‚Äôs data. For fault tolerance and replication we  should use   Consistent Hashing . If we want to have different throttling limits for different APIs, we can  choose to shard per user per API. Take the example of   URL Shortener ; we can have different rate  limiter for   createURL()   and   deleteURL()   APIs for each user or IP.  If our APIs are partitioned, a practical consideration could be to have a separate (somewhat smaller)  rate limiter for each API shard as well. Let‚Äôs take the example of our URL Shortener where we want to  limit each user not to create more than 100 short URLs per hour. Assuming we are using   Hash-Based  Partitioning   for our   createURL()   API, we can rate limit each partition to allow a user to create not  more than three short URLs per minute in addition to 100 short URLs per hour.  Our system can get huge benefits from caching recent active users. Application servers can quickly  check if the cache has the desired record before hitting backend servers. Our rate limiter can  significantly benefit from the   Write-back cache   by updating all counters and timestamps in cache  only. The write to the permanent storage can be done at fixed intervals. This way we can ensure  minimum latency added to the user‚Äôs requests by the rate limiter. The reads can always hit the cache  first; which will be extremely useful once the user has hit their maximum limit and the rate limiter will  only be reading data without any updates.  Least Recently Used (LRU) can be a reasonable cache eviction policy for our system.  12. Should we rate limit by IP or by user?  Let‚Äôs discuss the pros and cons of using each one of these schemes:  IP:   In this scheme, we throttle requests per-IP; although it‚Äôs not optimal in terms of differentiating  between ‚Äògood‚Äô and ‚Äòbad‚Äô actors, it‚Äôs still better than not have rate limiting at all. The biggest problem  with IP based throttling is when multiple users share a single public IP like in an internet cafe or  smartphone users that are using the same gateway. One bad user can cause throttling to other users.  Another issue could arise while caching IP-based limits, as there are a huge number of IPv6 addresses  available to a hacker from even one computer, it‚Äôs trivial to make a server run out of memory tracking  IPv6 addresses!  User:   Rate limiting can be done on APIs after user authentication. Once authenticated, the user will be  provided with a token which the user will pass with each request. This will ensure that we will rate  limit against a particular API that has a valid authentication token. But what if we have to rate limit on",
        "the login API itself? The weakness of this rate-limiting would be that a hacker can perform a denial of  service attack against a user by entering wrong credentials up to the limit; after that the actual user will  not be able to log-in.  How about if we combine the above two schemes?  Hybrid:   A right approach could be to do both per-IP and per-user rate limiting, as they both have  weaknesses when implemented alone, though, this will result in more cache entries with more details  per entry, hence requiring more memory and storage.  Designing Twitter Search  Twitter is one of the largest social networking service where users can share photos, news, and text-  based messages. In this chapter, we will design a service that can store and search user tweets. Similar  Problems: Tweet search. Difficulty Level: Medium  1. What is Twitter Search?  Twitter users can update their status whenever they like. Each status (called tweet) consists of plain text  and our goal is to design a system that allows searching over all the user tweets.  2. Requirements and Goals of the System  ‚Ä¢   Let‚Äôs assume Twitter has 1.5 billion total users with 800 million daily active users.  ‚Ä¢   On average Twitter gets 400 million tweets every day.  ‚Ä¢   The average size of a tweet is 300 bytes.  ‚Ä¢   Let‚Äôs assume there will be 500M searches every day.  ‚Ä¢   The search query will consist of multiple words combined with AND/OR.  We need to design a system that can efficiently store and query tweets.  3. Capacity Estimation and Constraints  Storage Capacity:   Since we have 400 million new tweets every day and each tweet on average is 300  bytes, the total storage we need, will be:  400M * 300 => 120GB/day  Total storage per second:  120GB / 24hours / 3600sec ~= 1.38MB/second",
        "System APIs  We can have SOAP or REST APIs to expose functionality of our service; following could be the  definition of the search API:  search(api_dev_key, search_terms, maximum_results_to_return, sort, page_token)  Parameters:  api_dev_key (string): The API developer key of a registered account. This will be used to, among other  things, throttle users based on their allocated quota.  search_terms (string): A string containing the search terms.  maximum_results_to_return (number): Number of tweets to return.  sort (number): Optional sort mode: Latest first (0 - default), Best matched (1), Most liked (2).  page_token (string): This token will specify a page in the result set that should be returned.  Returns:   (JSON)  A JSON containing information about a list of tweets matching the search query. Each result entry can  have the user ID & name, tweet text, tweet ID, creation time, number of likes, etc.  5. High Level Design  At the high level, we need to store all the statues in a database and also build an index that can keep  track of which word appears in which tweet. This index will help us quickly find tweets that users are  trying to search.  High level design for Twitter search  6. Detailed Component Design  1. Storage:   We need to store 120GB of new data every day. Given this huge amount of data, we need  to come up with a data partitioning scheme that will be efficiently distributing the data onto multiple  servers. If we plan for next five years, we will need the following storage:  120GB * 365days * 5years ~= 200TB  If we never want to be more than 80% full at any time, we approximately will need 250TB of total  storage. Let‚Äôs assume that we want to keep an extra copy of all tweets for fault tolerance; then, our total",
        "storage requirement will be 500TB. If we assume a modern server can store up to 4TB of data, we  would need 125 such servers to hold all of the required data for the next five years.  Let‚Äôs start with a simplistic design where we store the tweets in a MySQL database. We can assume that  we store the tweets in a table having two columns, TweetID and TweetText. Let‚Äôs assume we partition  our data based on TweetID. If our TweetIDs are unique system-wide, we can define a hash function that  can map a TweetID to a storage server where we can store that tweet object.  How can we create system-wide unique TweetIDs?   If we are getting 400M new tweets each day,  then how many tweet objects we can expect in five years?  400M * 365 days * 5 years => 730 billion  This means we would need a five bytes number to identify TweetIDs uniquely. Let‚Äôs assume we have a  service that can generate a unique TweetID whenever we need to store an object (The TweetID  discussed here will be similar to TweetID discussed in   Designing Twitter ). We can feed the TweetID to  our hash function to find the storage server and store our tweet object there.  2. Index:   What should our index look like? Since our tweet queries will consist of words, let‚Äôs build the  index that can tell us which word comes in which tweet object. Let‚Äôs first estimate how big our index  will be. If we want to build an index for all the English words and some famous nouns like people  names, city names, etc., and if we assume that we have around 300K English words and 200K nouns,  then we will have 500k total words in our index. Let‚Äôs assume that the average length of a word is five  characters. If we are keeping our index in memory, we need 2.5MB of memory to store all the words:  500K * 5 => 2.5 MB  Let‚Äôs assume that we want to keep the index in memory for all the tweets from only past two years.  Since we will be getting 730B tweets in 5 years, this will give us 292B tweets in two years. Given that  each TweetID will be 5 bytes, how much memory will we need to store all the TweetIDs?  292B * 5 => 1460 GB  So our index would be like a big distributed hash table, where ‚Äòkey‚Äô would be the word and ‚Äòvalue‚Äô will  be a list of TweetIDs of all those tweets which contain that word. Assuming on average we have 40  words in each tweet and since we will not be indexing prepositions and other small words like ‚Äòthe‚Äô,  ‚Äòan‚Äô, ‚Äòand‚Äô etc., let‚Äôs assume we will have around 15 words in each tweet that need to be indexed. This  means each TweetID will be stored 15 times in our index. So total memory we will need to store our  index:  (1460 * 15) + 2.5MB ~= 21 TB  Assuming a high-end server has 144GB of memory, we would need 152 such servers to hold our index.  We can shard our data based on two criteria:",
        "Sharding based on Words:   While building our index, we will iterate through all the words of a tweet  and calculate the hash of each word to find the server where it would be indexed. To find all tweets  containing a specific word we have to query only the server which contains this word.  We have a couple of issues with this approach:  1.   What if a word becomes hot? Then there will be a lot of queries on the server holding that word.  This high load will affect the performance of our service.  2.   Over time, some words can end up storing a lot of TweetIDs compared to others, therefore,  maintaining a uniform distribution of words while tweets are growing is quite tricky.  To recover from these situations we either have to repartition our data or use   Consistent Hashing .  Sharding based on the tweet object:   While storing, we will pass the TweetID to our hash function to  find the server and index all the words of the tweet on that server. While querying for a particular word,  we have to query all the servers, and each server will return a set of TweetIDs. A centralized server will  aggregate these results to return them to the user.  Detailed component design  7. Fault Tolerance  What will happen when an index server dies? We can have a secondary replica of each server and if the  primary server dies it can take control after the failover. Both primary and secondary servers will have  the same copy of the index.  What if both primary and secondary servers die at the same time? We have to allocate a new server and  rebuild the same index on it. How can we do that? We don‚Äôt know what words/tweets were kept on this  server. If we were using ‚ÄòSharding based on the tweet object‚Äô, the brute-force solution would be to  iterate through the whole database and filter TweetIDs using our hash function to figure out all the  required tweets that would be stored on this server. This would be inefficient and also during the time",
        "when the server was being rebuilt we would not be able to serve any query from it, thus missing some  tweets that should have been seen by the user.  How can we efficiently retrieve a mapping between tweets and the index server? We have to build a  reverse index that will map all the TweetID to their index server. Our Index-Builder server can hold this  information. We will need to build a Hashtable where the ‚Äòkey‚Äô will be the index server number and the  ‚Äòvalue‚Äô will be a HashSet containing all the TweetIDs being kept at that index server. Notice that we are  keeping all the TweetIDs in a HashSet; this will enable us to add/remove tweets from our index  quickly. So now, whenever an index server has to rebuild itself, it can simply ask the Index-Builder  server for all the tweets it needs to store and then fetch those tweets to build the index. This approach  will surely be fast. We should also have a replica of the Index-Builder server for fault tolerance.  8. Cache  To deal with hot tweets we can introduce a cache in front of our database. We can use   Memcached ,  which can store all such hot tweets in memory. Application servers, before hitting the backend  database, can quickly check if the cache has that tweet. Based on clients‚Äô usage patterns, we can adjust  how many cache servers we need. For cache eviction policy, Least Recently Used (LRU) seems  suitable for our system.  9. Load Balancing  We can add a load balancing layer at two places in our system 1) Between Clients and Application  servers and 2) Between Application servers and Backend server. Initially, a simple Round Robin  approach can be adopted; that distributes incoming requests equally among backend servers. This LB is  simple to implement and does not introduce any overhead. Another benefit of this approach is LB will  take dead servers out of the rotation and will stop sending any traffic to it. A problem with Round  Robin LB is it won‚Äôt take server load into consideration. If a server is overloaded or slow, the LB will  not stop sending new requests to that server. To handle this, a more intelligent LB solution can be  placed that periodically queries the backend server about their load and adjust traffic based on that.  10. Ranking  How about if we want to rank the search results by social graph distance, popularity, relevance, etc?  Let‚Äôs assume we want to rank tweets by popularity, like how many likes or comments a tweet is getting,  etc. In such a case, our ranking algorithm can calculate a ‚Äòpopularity number‚Äô (based on the number of  likes etc.) and store it with the index. Each partition can sort the results based on this popularity number  before returning results to the aggregator server. The aggregator server combines all these results, sorts  them based on the popularity number, and sends the top results to the user."
      ]
    },
    {
      "id": "design-5-a-web-crawler-lets-design-a-web-crawler-",
      "title": "Designing a Web Crawler  Let's design a Web Crawler that will systematically browse and download the World Wide Web. Web  crawlers are also known as web spiders, robots, worms, walkers, and bots. Difficulty Level: Hard  1. What is a Web Crawler?  A web crawler is a software program which browses the World Wide Web in a methodical and  automated manner. It collects documents by recursively fetching links from a set of starting pages.  Many sites, particularly search engines, use web crawling as a means of providing up-to-date data.  Search engines download all the pages to create an index on them to perform faster searches.  Some other uses of web crawlers are:  ‚Ä¢   To test web pages and links for valid syntax and structure.  ‚Ä¢   To monitor sites to see when their structure or contents change.  ‚Ä¢   To maintain mirror sites for popular Web sites.  ‚Ä¢   To search for copyright infringements.  ‚Ä¢   To build a special-purpose index, e.g., one that has some understanding of the content stored in  multimedia files on the Web.  2. Requirements and Goals of the System  Let‚Äôs assume we need to crawl all the web.  Scalability:   Our service needs to be scalable such that it can crawl the entire Web and can be used to  fetch hundreds of millions of Web documents.  Extensibility:   Our service should be designed in a modular way with the expectation that new  functionality will be added to it. There could be newer document types that needs to be downloaded  and processed in the future.  3. Some Design Considerations  Crawling the web is a complex task, and there are many ways to go about it. We should be asking a few  questions before going any further:  Is it a crawler for HTML pages only? Or should we fetch and store other types of media, such as  sound files, images, videos, etc.?   This is important because the answer can change the design. If we  are writing a general-purpose crawler to download different media types, we might want to break down  the parsing module into different sets of modules: one for HTML, another for images, or another for  videos, where each module extracts what is considered interesting for that media type.  Let‚Äôs assume for now that our crawler is going to deal with HTML only, but it should be extensible and  make it easy to add support for new media types.",
      "functional": [
        "Newsfeed will be generated based on the posts from the people, pages, and groups that a user  follows.  2.   A user may have many friends and follow a large number of pages/groups.  3.   Feeds may contain images, videos, or just text.  4.   Our service should support appending new posts as they arrive to the newsfeed for all active  users."
      ],
      "nonFunctional": [
        "Our system should be able to generate any user‚Äôs newsfeed in real-time - maximum latency seen  by the end user would be 2s.  2.   A post shouldn‚Äôt take more than 5s to make it to a user‚Äôs feed assuming a new newsfeed request  comes in.  3. Capacity Estimation and Constraints  Let‚Äôs assume on average a user has 300 friends and follows 200 pages.  Traffic estimates:   Let‚Äôs assume 300M daily active users with each user fetching their timeline an  average of five times a day. This will result in 1.5B newsfeed requests per day or approximately 17,500  requests per second.  Storage estimates:   On average, let‚Äôs assume we need to have around 500 posts in every user‚Äôs feed  that we want to keep in memory for a quick fetch. Let‚Äôs also assume that on average each post would  be 1KB in size. This would mean that we need to store roughly 500KB of data per user. To store all this  data for all the active users we would need 150TB of memory. If a server can hold 100GB we would  need around 1500 machines to keep the top 500 posts in memory for all active users.  4. System APIs  üêÄ   Once we have finalized the requirements, it‚Äôs always a good idea to define the system APIs.  This should explicitly state what is expected from the system.  We can have SOAP or REST APIs to expose the functionality of our service. The following could be  the definition of the API for getting the newsfeed:  getUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies)  Parameters:  api_dev_key (string): The API developer key of a registered can be used to, among other things,",
        "throttle users based on their allocated quota.  user_id (number):   The ID of the user for whom the system will generate the newsfeed.  since_id (number):   Optional; returns results with an ID higher than (that is, more recent than) the  specified ID.  count (number):   Optional; specifies the number of feed items to try and retrieve up to a maximum of  200 per distinct request.  max_id (number):   Optional; returns results with an ID less than (that is, older than) or equal to the  specified ID.  exclude_replies(boolean):   Optional; this parameter will prevent replies from appearing in the returned  timeline.  Returns:   (JSON) Returns a JSON object containing a list of feed items.  5. Database Design  There are three primary objects: User, Entity (e.g. page, group, etc.), and FeedItem (or Post). Here are  some observations about the relationships between these entities:  ‚Ä¢   A User can follow other entities and can become friends with other users.  ‚Ä¢   Both users and entities can post FeedItems which can contain text, images, or videos.  ‚Ä¢   Each FeedItem will have a UserID which will point to the User who created it. For simplicity,  let‚Äôs assume that only users can create feed items, although, on Facebook Pages can post feed  item too.  ‚Ä¢   Each FeedItem can optionally have an EntityID pointing to the page or the group where that  post was created.  If we are using a relational database, we would need to model two relations: User-Entity relation and  FeedItem-Media relation. Since each user can be friends with many people and follow a lot of entities,  we can store this relation in a separate table. The ‚ÄúType‚Äù column in ‚ÄúUserFollow‚Äù identifies if the  entity being followed is a User or Entity. Similarly, we can have a table for FeedMedia relation.",
        "High Level System Design  At a high level this problem can be divided into two parts:  Feed generation:   Newsfeed is generated from the posts (or feed items) of users and entities (pages and  groups) that a user follows. So, whenever our system receives a request to generate the feed for a user  (say Jane), we will perform the following steps:  1.   Retrieve IDs of all users and entities that Jane follows.  2.   Retrieve latest, most popular and relevant posts for those IDs. These are the potential posts that  we can show in Jane‚Äôs newsfeed.  3.   Rank these posts based on the relevance to Jane. This represents Jane‚Äôs current feed.  4.   Store this feed in the cache and return top posts (say 20) to be rendered on Jane‚Äôs feed.  5.   On the front-end, when Jane reaches the end of her current feed, she can fetch the next 20 posts  from the server and so on.  One thing to notice here is that we generated the feed once and stored it in the cache. What about new  incoming posts from people that Jane follows? If Jane is online, we should have a mechanism to rank",
        "and add those new posts to her feed. We can periodically (say every five minutes) perform the above  steps to rank and add the newer posts to her feed. Jane can then be notified that there are newer items in  her feed that she can fetch.  Feed publishing:   Whenever Jane loads her newsfeed page, she has to request and pull feed items from  the server. When she reaches the end of her current feed, she can pull more data from the server. For  newer items either the server can notify Jane and then she can pull, or the server can push, these new  posts. We will discuss these options in detail later.  At a high level, we will need following components in our Newsfeed service:  1.   Web servers:   To maintain a connection with the user. This connection will be used to transfer  data between the user and the server.  2.   Application server:   To execute the workflows of storing new posts in the database servers. We  will also need some application servers to retrieve and to push the newsfeed to the end user.  3.   Metadata database and cache:   To store the metadata about Users, Pages, and Groups.  4.   Posts database and cache:   To store metadata about posts and their contents.  5.   Video and photo storage, and cache:   Blob storage, to store all the media included in the posts.  6.   Newsfeed generation service:   To gather and rank all the relevant posts for a user to generate  newsfeed and store in the cache. This service will also receive live updates and will add these  newer feed items to any user‚Äôs timeline.  7.   Feed notification service:   To notify the user that there are newer items available for their  newsfeed.  Following is the high-level architecture diagram of our system. User B and C are following User A.",
        "Facebook Newsfeed Architecture  7. Detailed Component Design  Let‚Äôs discuss different components of our system in detail.  a. Feed generation  Let‚Äôs take the simple case of the newsfeed generation service fetching most recent posts from all the  users and entities that Jane follows; the query would look like this:  (SELECT FeedItemID FROM FeedItem WHERE UserID in (  SELECT EntityOrFriendID FROM UserFollow WHERE UserID = <current_user_id> and  type = 0(user))  )  UNION  (SELECT FeedItemID FROM FeedItem WHERE EntityID in (  SELECT EntityOrFriendID FROM UserFollow WHERE UserID = <current_user_id> and  type = 1(entity))  )  ORDER BY CreationDate DESC  LIMIT 100  Here are issues with this design for the feed generation service:",
        "Crazy slow for users with a lot of friends/follows as we have to perform  sorting/merging/ranking of a huge number of posts.  2.   We generate the timeline when a user loads their page. This would be quite slow and have a  high latency.  3.   For live updates, each status update will result in feed updates for all followers. This could  result in high backlogs in our Newsfeed Generation Service.  4.   For live updates, the server pushing (or notifying about) newer posts to users could lead to very  heavy loads, especially for people or pages that have a lot of followers. To improve the  efficiency, we can pre-generate the timeline and store it in a memory.  Offline generation for newsfeed:   We can have dedicated servers that are continuously generating  users‚Äô newsfeed and storing them in memory. So, whenever a user requests for the new posts for their  feed, we can simply serve it from the pre-generated, stored location. Using this scheme, user‚Äôs  newsfeed is not compiled on load, but rather on a regular basis and returned to users whenever they  request for it.  Whenever these servers need to generate the feed for a user, they will first query to see what was the  last time the feed was generated for that user. Then, new feed data would be generated from that time  onwards. We can store this data in a hash table where the ‚Äúkey‚Äù would be UserID and ‚Äúvalue‚Äù would be  a STRUCT like this:  Struct {  LinkedHashMap<FeedItemID, FeedItem> feedItems;  DateTime lastGenerated;  }  We can store FeedItemIDs in a data structure similar to   Linked HashMap   or   TreeMap , which can allow  us to not only jump to any feed item but also iterate through the map easily. Whenever users want to  fetch more feed items, they can send the last FeedItemID they currently see in their newsfeed, we can  then jump to that FeedItemID in our hash-map and return next batch/page of feed items from there.  How many feed items should we store in memory for a user‚Äôs feed?   Initially, we can decide to store  500 feed items per user, but this number can be adjusted later based on the usage pattern. For example,  if we assume that one page of a user‚Äôs feed has 20 posts and most of the users never browse more than  ten pages of their feed, we can decide to store only 200 posts per user. For any user who wants to see  more posts (more than what is stored in memory), we can always query backend servers.  Should we generate (and keep in memory) newsfeeds for all users?   There will be a lot of users that  don‚Äôt login frequently. Here are a few things we can do to handle this; 1) a more straightforward  approach could be, to use a LRU based cache that can remove users from memory that haven‚Äôt  accessed their newsfeed for a long time 2) a smarter solution can figure out the login pattern of users to  pre-generate their newsfeed, e.g., at what time of the day a user is active and which days of the week  does a user access their newsfeed? etc.  Let‚Äôs now discuss some solutions to our ‚Äúlive updates‚Äù problems in the following section.",
        "b. Feed publishing  The process of pushing a post to all the followers is called a fanout. By analogy, the push approach is  called fanout-on-write, while the pull approach is called fanout-on-load. Let‚Äôs discuss different options  for publishing feed data to users.  1.   ‚ÄúPull‚Äù model or Fan-out-on-load:   This method involves keeping all the recent feed data in  memory so that users can pull it from the server whenever they need it. Clients can pull the feed  data on a regular basis or manually whenever they need it. Possible problems with this approach  are a) New data might not be shown to the users until they issue a pull request, b) It‚Äôs hard to  find the right pull cadence, as most of the time pull requests will result in an empty response if  there is no new data, causing waste of resources.  2.   ‚ÄúPush‚Äù model or Fan-out-on-write:   For a push system, once a user has published a post, we  can immediately push this post to all the followers. The advantage is that when fetching feed  you don‚Äôt need to go through your friend‚Äôs list and get feeds for each of them. It significantly  reduces read operations. To efficiently handle this, users have to maintain a   Long Poll   request  with the server for receiving the updates. A possible problem with this approach is that when a  user has millions of followers (a celebrity-user) the server has to push updates to a lot of people.  3.   Hybrid:   An alternate method to handle feed data could be to use a hybrid approach, i.e., to do a  combination of fan-out-on-write and fan-out-on-load. Specifically, we can stop pushing posts  from users with a high number of followers (a celebrity user) and only push data for those users  who have a few hundred (or thousand) followers. For celebrity users, we can let the followers  pull the updates. Since the push operation can be extremely costly for users who have a lot of  friends or followers, by disabling fanout for them, we can save a huge number of resources.  Another alternate approach could be that, once a user publishes a post, we can limit the fanout  to only her online friends. Also, to get benefits from both the approaches, a combination of  ‚Äòpush to notify‚Äô and ‚Äòpull for serving‚Äô end users is a great way to go. Purely a push or pull model  is less versatile.  How many feed items can we return to the client in each request?   We should have a maximum limit  for the number of items a user can fetch in one request (say 20). But, we should let the client specify  how many feed items they want with each request as the user may like to fetch a different number of  posts depending on the device (mobile vs. desktop).  Should we always notify users if there are new posts available for their newsfeed?   It could be  useful for users to get notified whenever new data is available. However, on mobile devices, where data  usage is relatively expensive, it can consume unnecessary bandwidth. Hence, at least for mobile  devices, we can choose not to push data, instead, let users ‚ÄúPull to Refresh‚Äù to get new posts.  8. Feed Ranking  The most straightforward way to rank posts in a newsfeed is by the creation time of the posts, but  today‚Äôs ranking algorithms are doing a lot more than that to ensure ‚Äúimportant‚Äù posts are ranked higher.",
        "The high-level idea of ranking is first to select key ‚Äúsignals‚Äù that make a post important and then to  find out how to combine them to calculate a final ranking score.  More specifically, we can select features that are relevant to the importance of any feed item, e.g.,  number of likes, comments, shares, time of the update, whether the post has images/videos, etc., and  then, a score can be calculated using these features. This is generally enough for a simple ranking  system. A better ranking system can significantly improve itself by constantly evaluating if we are  making progress in user stickiness, retention, ads revenue, etc.  9. Data Partitioning  a. Sharding posts and metadata  Since we have a huge number of new posts every day and our read load is extremely high too, we need  to distribute our data onto multiple machines such that we can read/write it efficiently. For sharding our  databases that are storing posts and their metadata, we can have a similar design as discussed under  Designing Twitter .  b. Sharding feed data  For feed data, which is being stored in memory, we can partition it based on UserID.   We can try storing  all the data of a user on one server. When storing, we can pass the UserID to our hash function that will  map the user to a cache server where we will store the user‚Äôs feed objects. Also, for any given user,  since we don‚Äôt expect to store more than 500 FeedItmeIDs, we will not run into a scenario where feed  data for a user doesn‚Äôt fit on a single server. To get the feed of a user, we would always have to query  only one server. For future growth and replication, we must use   Consistent Hashing .  Designing Yelp or Nearby Friends  Let's design a Yelp like service, where users can search for nearby places like restaurants, theaters, or  shopping malls, etc., and can also add/view reviews of places. Similar Services: Proximity server.  Difficulty Level: Hard  1. Why Yelp or Proximity Server?  Proximity servers are used to discover nearby attractions like places, events, etc. If you haven‚Äôt used  yelp.com   before, please try it before proceeding (you can search for nearby restaurants, theaters, etc.)  and spend some time understanding different options that the website offers. This will help you a lot in  understanding this chapter better.  2. Requirements and Goals of the System  What do we wish to achieve from a Yelp like service?   Our service will be storing information about  different places so that users can perform a search on them. Upon querying, our service will return a list  of places around the user.",
        "Our Yelp-like service should meet the following requirements:  Functional Requirements:  1.   Users should be able to add/delete/update Places.  2.   Given their location (longitude/latitude), users should be able to find all nearby places within a  given radius.  3.   Users should be able to add feedback/review about a place. The feedback can have pictures,  text, and a rating.  Non-functional Requirements:  1.   Users should have a real-time search experience with minimum latency.  2.   Our service should support a heavy search load. There will be a lot of search requests compared  to adding a new place.  3. Scale Estimation  Let‚Äôs build our system assuming that we have 500M places and 100K queries per second (QPS). Let‚Äôs  also assume a 20% growth in the number of places and QPS each year.  4. Database Schema  Each location can have the following fields:  1.   LocationID (8 bytes): Uniquely identifies a location.  2.   Name (256 bytes)  3.   Latitude (8 bytes)  4.   Longitude (8 bytes)  5.   Description (512 bytes)  6.   Category (1 byte): E.g., coffee shop, restaurant, theater, etc.  Although a four bytes number can uniquely identify 500M locations, with future growth in mind, we  will go with 8 bytes for LocationID.  Total size: 8 + 256 + 8 + 8 + 512 + 1 => 793 bytes  We also need to store reviews, photos, and ratings of a Place. We can have a separate table to store  reviews for Places:  1.   LocationID (8 bytes)  2.   ReviewID (4 bytes): Uniquely identifies a review, assuming any location will not have more  than 2^32 reviews.  3.   ReviewText (512 bytes)  4.   Rating (1 byte): how many stars a place gets out of ten.  Similarly, we can have a separate table to store photos for Places and Reviews.",
        "System APIs  We can have SOAP or REST APIs to expose the functionality of our service. The following could be  the definition of the API for searching:  search(api_dev_key, search_terms, user_location, radius_filter,  maximum_results_to_return,  category_filter, sort, page_token)  Parameters:  api_dev_key (string): The API developer key of a registered account. This will be used to, among other  things, throttle users based on their allocated quota.  search_terms (string): A string containing the search terms.  user_location (string): Location of the user performing the search.  radius_filter (number): Optional search radius in meters.  maximum_results_to_return (number): Number of business results to return.  category_filter (string): Optional category to filter search results, e.g., Restaurants, Shopping Centers,  etc.  sort (number): Optional sort mode: Best matched (0 - default), Minimum distance (1), Highest rated  (2).  page_token (string): This token will specify a page in the result set that should be returned.  Returns:   (JSON)  A JSON containing information about a list of businesses matching the search query. Each result entry  will have the business name, address, category, rating, and thumbnail.  6. Basic System Design and Algorithm  At a high level, we need to store and index each dataset described above (places, reviews, etc.). For  users to query this massive database, the indexing should be read efficient, since while searching for  the nearby places users expect to see the results in real-time.  Given that the location of a place doesn‚Äôt change that often, we don‚Äôt need to worry about frequent  updates of the data. As a contrast, if we intend to build a service where objects do change their location  frequently, e.g., people or taxis, then we might come up with a very different design.  Let‚Äôs see what are different ways to store this data and also find out which method will suit best for our  use cases:  a. SQL solution  One simple solution could be to store all the data in a database like MySQL. Each place will be stored  in a separate row, uniquely identified by LocationID. Each place will have its longitude and latitude  stored separately in two different columns, and to perform a fast search; we should have indexes on  both these fields.  To find all the nearby places of a given location (X, Y) within a radius ‚ÄòD‚Äô, we can query like this:",
        "Select * from Places where Latitude between X-D and X+D and Longitude between Y-D and Y+D  The above query is not completely accurate, as we know that to find the distance between two points  we have to use the distance formula (Pythagorean theorem), but for simplicity let‚Äôs take this.  How efficient would this query be?   We have estimated 500M places to be stored in our service. Since  we have two separate indexes, each index can return a huge list of places and performing an  intersection on those two lists won‚Äôt be efficient. Another way to look at this problem is that there could  be too many locations between ‚ÄòX-D‚Äô and ‚ÄòX+D‚Äô, and similarly between ‚ÄòY-D‚Äô and ‚ÄòY+D‚Äô. If we can  somehow shorten these lists, it can improve the performance of our query.  b. Grids  We can divide the whole map into smaller grids to group locations into smaller sets. Each grid will  store all the Places residing within a specific range of longitude and latitude. This scheme would enable  us to query only a few grids to find nearby places. Based on a given location and radius, we can find all  the neighboring grids and then query these grids to find nearby places.  Let‚Äôs assume that GridID (a four bytes number) would uniquely identify grids in our system.  What could be a reasonable grid size?   Grid size could be equal to the distance we would like to  query since we also want to reduce the number of grids. If the grid size is equal to the distance we want  to query, then we only need to search within the grid which contains the given location and neighboring  eight grids. Since our grids would be statically defined (from the fixed grid size), we can easily find the  grid number of any location (lat, long) and its neighboring grids.",
        "In the database, we can store the GridID with each location and have an index on it, too, for faster  searching. Now, our query will look like:  Select * from Places where Latitude between X-D and X+D and Longitude between Y-D and Y+D and  GridID in (GridID, GridID1, GridID2, ..., GridID8)  This will undoubtedly improve the runtime of our query.  Should we keep our index in memory?   Maintaining the index in memory will improve the  performance of our service. We can keep our index in a hash table where ‚Äòkey‚Äô is the grid number and  ‚Äòvalue‚Äô is the list of places contained in that grid.  How much memory will we need to store the index?   Let‚Äôs assume our search radius is 10 miles;  given that the total area of the earth is around 200 million square miles, we will have 20 million grids.  We would need a four bytes number to uniquely identify each grid and, since LocationID is 8 bytes, we  would need 4GB of memory (ignoring hash table overhead) to store the index.  (4 * 20M) + (8 * 500M) ~= 4 GB  This solution can still run slow for those grids that have a lot of places since our places are not  uniformly distributed among grids. We can have a thickly dense area with a lot of places, and on the  other hand, we can have areas which are sparsely populated.  This problem can be solved if we can dynamically adjust our grid size such that whenever we have a  grid with a lot of places we break it down to create smaller grids. A couple of challenges with this  approach could be: 1) how to map these grids to locations and 2) how to find all the neighboring grids  of a grid.  c. Dynamic size grids  Let‚Äôs assume we don‚Äôt want to have more than 500 places in a grid so that we can have a faster  searching. So, whenever a grid reaches this limit, we break it down into four grids of equal size and  distribute places among them. This means thickly populated areas like downtown San Francisco will  have a lot of grids, and sparsely populated area like the Pacific Ocean will have large grids with places  only around the coastal lines.  What data-structure can hold this information?   A tree in which each node has four children can  serve our purpose. Each node will represent a grid and will contain information about all the places in  that grid. If a node reaches our limit of 500 places, we will break it down to create four child nodes  under it and distribute places among them. In this way, all the leaf nodes will represent the grids that  cannot be further broken down. So leaf nodes will keep a list of places with them. This tree structure in  which each node can have four children is called a   QuadTree",
        "How will we build a QuadTree?   We will start with one node that will represent the whole world in  one grid. Since it will have more than 500 locations, we will break it down into four nodes and  distribute locations among them. We will keep repeating this process with each child node until there  are no nodes left with more than 500 locations.  How will we find the grid for a given location?   We will start with the root node and search  downward to find our required node/grid. At each step, we will see if the current node we are visiting  has children. If it has, we will move to the child node that contains our desired location and repeat this  process. If the node does not have any children, then that is our desired node.  How will we find neighboring grids of a given grid?   Since only leaf nodes contain a list of locations,  we can connect all leaf nodes with a doubly linked list. This way we can iterate forward or backward  among the neighboring leaf nodes to find out our desired locations. Another approach for finding  adjacent grids would be through parent nodes. We can keep a pointer in each node to access its parent,  and since each parent node has pointers to all of its children, we can easily find siblings of a node. We  can keep expanding our search for neighboring grids by going up through the parent pointers.  Once we have nearby LocationIDs, we can query the backend database to find details about those  places.  What will be the search workflow?   We will first find the node that contains the user‚Äôs location. If that  node has enough desired places, we can return them to the user. If not, we will keep expanding to the  neighboring nodes (either through the parent pointers or doubly linked list) until either we find the  required number of places or exhaust our search based on the maximum radius.  How much memory will be needed to store the QuadTree?   For each Place, if we cache only  LocationID and Lat/Long, we would need 12GB to store all places.",
        "24 * 500M => 12 GB  Since each grid can have a maximum of 500 places, and we have 500M locations, how many total grids  we will have?  500M / 500 => 1M grids  Which means we will have 1M leaf nodes and they will be holding 12GB of location data. A QuadTree  with 1M leaf nodes will have approximately 1/3rd internal nodes, and each internal node will have 4  pointers (for its children). If each pointer is 8 bytes, then the memory we need to store all internal  nodes would be:  1M * 1/3 * 4 * 8 = 10 MB  So, total memory required to hold the whole QuadTree would be 12.01GB. This can easily fit into a  modern-day server.  How would we insert a new Place into our system?   Whenever a new Place is added by a user, we  need to insert it into the databases as well as in the QuadTree. If our tree resides on one server, it is easy  to add a new Place, but if the QuadTree is distributed among different servers, first we need to find the  grid/server of the new Place and then add it there (discussed in the next section).  7. Data Partitioning  What if we have a huge number of places such that our index does not fit into a single machine‚Äôs  memory? With 20% growth each year we will reach the memory limit of the server in the future. Also,  what if one server cannot serve the desired read traffic? To resolve these issues, we must partition our  QuadTree!  We will explore two solutions here (both of these partitioning schemes can be applied to databases,  too):  a. Sharding based on regions:   We can divide our places into regions (like zip codes), such that all  places belonging to a region will be stored on a fixed node. To store a place we will find the server  through its region and, similarly, while querying for nearby places we will ask the region server that  contains user‚Äôs location. This approach has a couple of issues:  1.   What if a region becomes hot? There would be a lot of queries on the server holding that region,  making it perform slow. This will affect the performance of our service.  2.   Over time, some regions can end up storing a lot of places compared to others. Hence,  maintaining a uniform distribution of places, while regions are growing is quite difficult.  To recover from these situations, either we have to repartition our data or use consistent hashing.  b. Sharding based on LocationID:   Our hash function will map each LocationID to a server where we  will store that place. While building our QuadTree, we will iterate through all the places and calculate  the hash of each LocationID to find a server where it would be stored. To find places near a location,",
        "we have to query all servers and each server will return a set of nearby places. A centralized server will  aggregate these results to return them to the user.  Will we have different QuadTree structure on different partitions?   Yes, this can happen since it is  not guaranteed that we will have an equal number of places in any given grid on all partitions.  However, we do make sure that all servers have approximately an equal number of Places. This  different tree structure on different servers will not cause any issue though, as we will be searching all  the neighboring grids within the given radius on all partitions.  The remaining part of this chapter assumes that we have partitioned our data based on LocationID.  8. Replication and Fault Tolerance  Having replicas of QuadTree servers can provide an alternate to data partitioning. To distribute read  traffic, we can have replicas of each QuadTree server. We can have a master-slave configuration where  replicas (slaves) will only serve read traffic; all write traffic will first go to the master and then applied  to slaves. Slaves might not have some recently inserted places (a few milliseconds delay will be there),  but this could be acceptable.  What will happen when a QuadTree server dies? We can have a secondary replica of each server and, if  primary dies, it can take control after the failover. Both primary and secondary servers will have the  same QuadTree structure.  What if both primary and secondary servers die at the same time?   We have to allocate a new  server and rebuild the same QuadTree on it. How can we do that, since we don‚Äôt know what places  were kept on this server? The brute-force solution would be to iterate through the whole database and  filter LocationIDs using our hash function to figure out all the required places that will be stored on this  server. This would be inefficient and slow; also, during the time when the server is being rebuilt, we  will not be able to serve any query from it, thus missing some places that should have been seen by  users.",
        "How can we efficiently retrieve a mapping between Places and QuadTree server?   We have to build  a reverse index that will map all the Places to their QuadTree server. We can have a separate QuadTree  Index server that will hold this information. We will need to build a HashMap where the ‚Äòkey‚Äô is the  QuadTree server number and the ‚Äòvalue‚Äô is a HashSet containing all the Places being kept on that  QuadTree server. We need to store LocationID and Lat/Long with each place because information  servers can build their QuadTrees through this. Notice that we are keeping Places‚Äô data in a HashSet,  this will enable us to add/remove Places from our index quickly. So now, whenever a QuadTree server  needs to rebuild itself, it can simply ask the QuadTree Index server for all the Places it needs to store.  This approach will surely be quite fast. We should also have a replica of the QuadTree Index server for  fault tolerance. If a QuadTree Index server dies, it can always rebuild its index from iterating through  the database.  9. Cache  To deal with hot Places, we can introduce a cache in front of our database. We can use an off-the-shelf  solution like Memcache, which can store all data about hot places. Application servers, before hitting  the backend database, can quickly check if the cache has that Place. Based on clients‚Äô usage pattern, we  can adjust how many cache servers we need. For cache eviction policy, Least Recently Used (LRU)  seems suitable for our system.  10. Load Balancing (LB)  We can add LB layer at two places in our system 1) Between Clients and Application servers and 2)  Between Application servers and Backend server. Initially, a simple Round Robin approach can be  adopted; that will distribute all incoming requests equally among backend servers. This LB is simple to  implement and does not introduce any overhead. Another benefit of this approach is if a server is dead  the load balancer will take it out of the rotation and will stop sending any traffic to it.  A problem with Round Robin LB is, it won‚Äôt take server load into consideration. If a server is  overloaded or slow, the load balancer will not stop sending new requests to that server. To handle this, a  more intelligent LB solution would be needed that periodically queries backend server about their load  and adjusts traffic based on that.  11. Ranking  How about if we want to rank the search results not just by proximity but also by popularity or  relevance?  How can we return most popular places within a given radius?   Let‚Äôs assume we keep track of the  overall popularity of each place. An aggregated number can represent this popularity in our system,  e.g., how many stars a place gets out of ten (this would be an average of different rankings given by  users)? We will store this number in the database as well as in the QuadTree. While searching for the  top 100 places within a given radius, we can ask each partition of the QuadTree to return the top 100",
        "places with maximum popularity. Then the aggregator server can determine the top 100 places among  all the places returned by different partitions.  Remember that we didn‚Äôt build our system to update place‚Äôs data frequently. With this design, how can  we modify the popularity of a place in our QuadTree? Although we can search a place and update its  popularity in the QuadTree, it would take a lot of resources and can affect search requests and system  throughput. Assuming the popularity of a place is not expected to reflect in the system within a few  hours, we can decide to update it once or twice a day, especially when the load on the system is  minimum.  Our next problem,   Designing Uber backend , discusses dynamic updates of the QuadTree in detail.  Designing Uber backend  Let's design a ride-sharing service like Uber, which connects passengers who need a ride with drivers  who have a car. Similar Services: Lyft, Didi, Via, Sidecar etc. Difficulty level: Hard Prerequisite:  Designing Yelp  1. What is Uber?  Uber enables its customers to book drivers for taxi rides. Uber drivers use their personal cars to drive  customers around. Both customers and drivers communicate with each other through their smartphones  using the Uber app.  2. Requirements and Goals of the System  Let‚Äôs start with building a simpler version of Uber.  There are two kinds of users in our system: 1) Drivers 2) Customers.  ‚Ä¢   Drivers need to regularly notify the service about their current location and their availability to  pick passengers.  ‚Ä¢   Passengers get to see all the nearby available drivers.  ‚Ä¢   Customer can request a ride; nearby drivers are notified that a customer is ready to be picked  up.  ‚Ä¢   Once a driver and a customer accept a ride, they can constantly see each other‚Äôs current location  until the trip finishes.  ‚Ä¢   Upon reaching the destination, the driver marks the journey complete to become available for  the next ride.  3. Capacity Estimation and Constraints  ‚Ä¢   Let‚Äôs assume we have 300M customers and 1M drivers with 1M daily active customers and  500K daily active drivers.",
        "Let‚Äôs assume 1M daily rides.  ‚Ä¢   Let‚Äôs assume that all active drivers notify their current location every three seconds.  ‚Ä¢   Once a customer puts in a request for a ride, the system should be able to contact drivers in real-  time.  4. Basic System Design and Algorithm  We will take the solution discussed in   Designing Yelp   and modify it to make it work for the above-  mentioned ‚ÄúUber‚Äù use cases. The biggest difference we have is that our QuadTree was not built  keeping in mind that there would be frequent updates to it. So, we have two issues with our Dynamic  Grid solution:  ‚Ä¢   Since all active drivers are reporting their locations every three seconds, we need to update our  data structures to reflect that. If we have to update the QuadTree for every change in the driver‚Äôs  position, it will take a lot of time and resources. To update a driver to its new location, we must  find the right grid based on the driver‚Äôs previous location. If the new position does not belong to  the current grid, we have to remove the driver from the current grid and move/reinsert the user  to the correct grid. After this move, if the new grid reaches the maximum limit of drivers, we  have to repartition it.  ‚Ä¢   We need to have a quick mechanism to propagate the current location of all the nearby drivers  to any active customer in that area. Also, when a ride is in progress, our system needs to notify  both the driver and passenger about the current location of the car.  Although our QuadTree helps us find nearby drivers quickly, a fast update in the tree is not guaranteed.  Do we need to modify our QuadTree every time a driver reports their location?   If we don‚Äôt update  our QuadTree with every update from the driver, it will have some old data and will not reflect the  current location of drivers correctly. If you recall, our purpose of building the QuadTree was to find  nearby drivers (or places) efficiently. Since all active drivers report their location every three seconds,  therefore there will be a lot more updates happening to our tree than querying for nearby drivers. So,  what if we keep the latest position reported by all drivers in a hash table and update our QuadTree a  little less frequently? Let‚Äôs assume we guarantee that a driver‚Äôs current location will be reflected in the  QuadTree within 15 seconds. Meanwhile, we will maintain a hash table that will store the current  location reported by drivers; let‚Äôs call this DriverLocationHT.  How much memory we need for DriverLocationHT?   We need to store DriveID, their present and  old location, in the hash table. So, we need a total of 35 bytes to store one record:  1.   DriverID (3 bytes - 1 million drivers)  2.   Old latitude (8 bytes)  3.   Old longitude (8 bytes)  4.   New latitude (8 bytes)  5.   New longitude (8 bytes) Total = 35 bytes  If we have 1 million total drivers, we need the following memory (ignoring hash table overhead):",
        "1 million * 35 bytes => 35 MB  How much bandwidth will our service consume to receive location updates from all drivers?   If we  get DriverID and their location, it will be (3+16 => 19 bytes). If we receive this information every three  seconds from one million drivers, we will be getting 19MB per three seconds.  Do we need to distribute DriverLocationHT onto multiple servers?   Although our memory and  bandwidth requirements don‚Äôt require this, since all this information can easily be stored on one server,  but, for scalability, performance, and fault tolerance, we should distribute DriverLocationHT onto  multiple servers. We can distribute based on the DriverID to make the distribution completely random.  Let‚Äôs call the machines holding DriverLocationHT the Driver Location server. Other than storing the  driver‚Äôs location, each of these servers will do two things:  1.   As soon as the server receives an update for a driver‚Äôs location, they will broadcast that  information to all the interested customers.  2.   The server needs to notify the respective QuadTree server to refresh the driver‚Äôs location. As  discussed above, this can happen every 10 seconds.  How can we efficiently broadcast the driver‚Äôs location to customers?   We can have a   Push Model  where the server will push the positions to all the relevant users. We can have a dedicated Notification  Service that can broadcast the current location of drivers to all the interested customers. We can build  our Notification service on a publisher/subscriber model. When a customer opens the Uber app on their  cell phone, they query the server to find nearby drivers. On the server side, before returning the list of  drivers to the customer, we will subscribe the customer for all the updates from those drivers. We can  maintain a list of customers (subscribers) interested in knowing the location of a driver and, whenever  we have an update in DriverLocationHT for that driver, we can broadcast the current location of the  driver to all subscribed customers. This way, our system makes sure that we always show the driver‚Äôs  current position to the customer.  How much memory will we need to store all these subscriptions?   As we have estimated above, we  will have 1M daily active customers and 500K daily active drivers. On average let‚Äôs assume that five  customers subscribe to one driver. Let‚Äôs assume we store all this information in a hash table so that we  can update it efficiently. We need to store driver and customer IDs to maintain the subscriptions.  Assuming we will need 3 bytes for DriverID and 8 bytes for CustomerID, we will need 21MB of  memory.  (500K * 3) + (500K * 5 * 8 ) ~= 21 MB  How much bandwidth will we need to broadcast the driver‚Äôs location to customers?   For every  active driver, we have five subscribers, so the total subscribers we have:  5 * 500K => 2.5M  To all these customers we need to send DriverID (3 bytes) and their location (16 bytes) every second,  so, we need the following bandwidth:",
        "5M * 19 bytes => 47.5 MB/s  How can we efficiently implement Notification service?   We can either use HTTP long polling or  push notifications.  How will the new publishers/drivers get added for a current customer?   As we have proposed  above, customers will be subscribed to nearby drivers when they open the Uber app for the first time,  what will happen when a new driver enters the area the customer is looking at? To add a new  customer/driver subscription dynamically, we need to keep track of the area the customer is watching.  This will make our solution complicated; how about if instead of pushing this information, clients pull  it from the server?  How about if clients pull information about nearby drivers from the server?   Clients can send their  current location, and the server will find all the nearby drivers from the QuadTree to return them to the  client. Upon receiving this information, the client can update their screen to reflect current positions of  the drivers. Clients can query every five seconds to limit the number of round trips to the server. This  solution looks simpler compared to the push model described above.  Do we need to repartition a grid as soon as it reaches the maximum limit?   We can have a cushion  to let each grid grow a little bigger beyond the limit before we decide to partition it. Let‚Äôs say our grids  can grow/shrink an extra 10% before we partition/merge them. This should decrease the load for a grid  partition or merge on high traffic grids.  How would ‚ÄúRequest Ride‚Äù use case work?  1.   The customer will put a request for a ride.  2.   One of the Aggregator servers will take the request and asks QuadTree servers to return nearby  drivers."
      ]
    }
  ],
  "baselines": {
    "analytics-pipeline": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Client"
          }
        },
        {
          "id": "load-balancer",
          "position": {
            "x": 250,
            "y": 100
          },
          "data": {
            "label": "Load Balancer"
          }
        },
        {
          "id": "app-server",
          "position": {
            "x": 250,
            "y": 200
          },
          "data": {
            "label": "App Server"
          }
        },
        {
          "id": "database",
          "position": {
            "x": 250,
            "y": 300
          },
          "data": {
            "label": "Database"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-client-load-balancer",
          "source": "client",
          "target": "load-balancer"
        },
        {
          "id": "e-1-load-balancer-app-server",
          "source": "load-balancer",
          "target": "app-server"
        },
        {
          "id": "e-2-app-server-database",
          "source": "app-server",
          "target": "database"
        }
      ]
    }
  },
  "drafts": {
    "design-1-instagram-lets-design-a-photo-sharing-se": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 480,
            "y": 280
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "className": "node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary",
          "selected": false,
          "dragging": false
        },
        {
          "id": "app-server",
          "position": {
            "x": 240,
            "y": 280
          },
          "data": {
            "label": "App Server",
            "description": "Handles business logic"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "selected": false
        },
        {
          "id": "shard-1",
          "position": {
            "x": 535,
            "y": 560
          },
          "data": {
            "label": "Shard 1",
            "description": "Stores subset of data (partitioned by user ID or hash)."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-2",
          "position": {
            "x": 295,
            "y": 560
          },
          "data": {
            "label": "Shard 2",
            "description": "Stores another subset of data."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "className": "node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary",
          "selected": false
        },
        {
          "id": "message-queue",
          "position": {
            "x": 55,
            "y": 560
          },
          "data": {
            "label": "Message Queue",
            "description": "Buffers and processes write requests asynchronously to prevent database overload."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 240,
            "y": 420
          },
          "data": {
            "label": "Cache",
            "description": "Stores frequently accessed data to reduce database load and latency."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "className": "node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary"
        },
        {
          "id": "primary-database",
          "position": {
            "x": 185,
            "y": 700
          },
          "data": {
            "label": "Primary Database",
            "description": "Handles writes."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "replica-database",
          "position": {
            "x": 0,
            "y": 840
          },
          "data": {
            "label": "Replica Database",
            "description": "Handles read replication and failover."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "client-mlmwzcxr",
          "position": {
            "x": 360,
            "y": 0
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "className": "node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary",
          "selected": false,
          "dragging": false
        },
        {
          "id": "load-balancer-mlmxrtal",
          "position": {
            "x": 360,
            "y": 140
          },
          "data": {
            "label": "Load Balancer",
            "description": "Distributes traffic across servers"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "className": "node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary node--unnecessary",
          "selected": true,
          "dragging": false
        }
      ],
      "edges": [
        {
          "id": "e-app-shard1",
          "source": "app-server",
          "target": "shard-1"
        },
        {
          "id": "e-app-shard2",
          "source": "app-server",
          "target": "shard-2"
        },
        {
          "id": "e-app-cache",
          "source": "app-server",
          "target": "cache"
        },
        {
          "id": "e-cache-shard1",
          "source": "cache",
          "target": "shard-1"
        },
        {
          "id": "e-cache-shard2",
          "source": "cache",
          "target": "shard-2"
        },
        {
          "id": "e-app-mq",
          "source": "app-server",
          "target": "message-queue",
          "label": "Write"
        },
        {
          "id": "e-mq-primary",
          "source": "message-queue",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-app-replica",
          "source": "app-server",
          "target": "replica-database",
          "label": "Read",
          "selected": false
        },
        {
          "id": "e-shard1-primary",
          "source": "shard-1",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-shard2-primary",
          "source": "shard-2",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-primary-replica",
          "source": "primary-database",
          "target": "replica-database"
        },
        {
          "type": "smoothstep",
          "source": "load-balancer-mlmxrtal",
          "target": "client",
          "id": "xy-edge__load-balancer-mlmxrtal-client"
        },
        {
          "type": "smoothstep",
          "source": "client-mlmwzcxr",
          "target": "load-balancer-mlmxrtal",
          "id": "xy-edge__client-mlmwzcxr-load-balancer-mlmxrtal"
        },
        {
          "type": "smoothstep",
          "source": "load-balancer-mlmxrtal",
          "target": "app-server",
          "id": "xy-edge__load-balancer-mlmxrtal-app-server"
        }
      ]
    },
    "design-2-facebook-messenger-lets-design-an-instan": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 185,
            "y": 0
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "load-balancer",
          "position": {
            "x": 185,
            "y": 140
          },
          "data": {
            "label": "Load Balancer",
            "description": "Distributes traffic across servers"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "app-server",
          "position": {
            "x": 185,
            "y": 280
          },
          "data": {
            "label": "App Server",
            "description": "Handles business logic"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-1",
          "position": {
            "x": 490,
            "y": 560
          },
          "data": {
            "label": "Shard 1",
            "description": "Stores subset of data (partitioned by user ID or hash)."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-2",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Shard 2",
            "description": "Stores another subset of data."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "message-queue",
          "position": {
            "x": 0,
            "y": 560
          },
          "data": {
            "label": "Message Queue",
            "description": "Buffers and processes write requests asynchronously to prevent database overload."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 185,
            "y": 420
          },
          "data": {
            "label": "Cache",
            "description": "Stores frequently accessed data to reduce database load and latency."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "primary-database",
          "position": {
            "x": 250,
            "y": 700
          },
          "data": {
            "label": "Primary Database",
            "description": "Handles writes."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "replica-database",
          "position": {
            "x": 65,
            "y": 840
          },
          "data": {
            "label": "Replica Database",
            "description": "Handles read replication and failover."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        }
      ],
      "edges": [
        {
          "id": "e-client-lb",
          "source": "client",
          "target": "load-balancer"
        },
        {
          "id": "e-lb-app",
          "source": "load-balancer",
          "target": "app-server"
        },
        {
          "id": "e-app-shard1",
          "source": "app-server",
          "target": "shard-1"
        },
        {
          "id": "e-app-shard2",
          "source": "app-server",
          "target": "shard-2"
        },
        {
          "id": "e-app-cache",
          "source": "app-server",
          "target": "cache"
        },
        {
          "id": "e-cache-shard1",
          "source": "cache",
          "target": "shard-1"
        },
        {
          "id": "e-cache-shard2",
          "source": "cache",
          "target": "shard-2"
        },
        {
          "id": "e-app-mq",
          "source": "app-server",
          "target": "message-queue",
          "label": "Write"
        },
        {
          "id": "e-mq-primary",
          "source": "message-queue",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-app-replica",
          "source": "app-server",
          "target": "replica-database",
          "label": "Read"
        },
        {
          "id": "e-shard1-primary",
          "source": "shard-1",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-shard2-primary",
          "source": "shard-2",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-primary-replica",
          "source": "primary-database",
          "target": "replica-database"
        }
      ]
    },
    "design-3-youtube-or-netflix-lets-design-a-video-s": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 185,
            "y": 0
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "load-balancer",
          "position": {
            "x": 185,
            "y": 140
          },
          "data": {
            "label": "Load Balancer",
            "description": "Distributes traffic across servers"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "app-server",
          "position": {
            "x": 185,
            "y": 280
          },
          "data": {
            "label": "App Server",
            "description": "Handles business logic"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-1",
          "position": {
            "x": 490,
            "y": 560
          },
          "data": {
            "label": "Shard 1",
            "description": "Stores subset of data (partitioned by user ID or hash)."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-2",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Shard 2",
            "description": "Stores another subset of data."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "message-queue",
          "position": {
            "x": 0,
            "y": 560
          },
          "data": {
            "label": "Message Queue",
            "description": "Buffers and processes write requests asynchronously to prevent database overload."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 185,
            "y": 420
          },
          "data": {
            "label": "Cache",
            "description": "Stores frequently accessed data to reduce database load and latency."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "primary-database",
          "position": {
            "x": 250,
            "y": 700
          },
          "data": {
            "label": "Primary Database",
            "description": "Handles writes."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "replica-database",
          "position": {
            "x": 65,
            "y": 840
          },
          "data": {
            "label": "Replica Database",
            "description": "Handles read replication and failover."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        }
      ],
      "edges": [
        {
          "id": "e-client-lb",
          "source": "client",
          "target": "load-balancer"
        },
        {
          "id": "e-lb-app",
          "source": "load-balancer",
          "target": "app-server"
        },
        {
          "id": "e-app-shard1",
          "source": "app-server",
          "target": "shard-1"
        },
        {
          "id": "e-app-shard2",
          "source": "app-server",
          "target": "shard-2"
        },
        {
          "id": "e-app-cache",
          "source": "app-server",
          "target": "cache"
        },
        {
          "id": "e-cache-shard1",
          "source": "cache",
          "target": "shard-1"
        },
        {
          "id": "e-cache-shard2",
          "source": "cache",
          "target": "shard-2"
        },
        {
          "id": "e-app-mq",
          "source": "app-server",
          "target": "message-queue",
          "label": "Write"
        },
        {
          "id": "e-mq-primary",
          "source": "message-queue",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-app-replica",
          "source": "app-server",
          "target": "replica-database",
          "label": "Read"
        },
        {
          "id": "e-shard1-primary",
          "source": "shard-1",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-shard2-primary",
          "source": "shard-2",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-primary-replica",
          "source": "primary-database",
          "target": "replica-database"
        }
      ]
    },
    "design-4-typeahead-suggestion-lets-design-a-real-": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 185,
            "y": 0
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "load-balancer",
          "position": {
            "x": 185,
            "y": 140
          },
          "data": {
            "label": "Load Balancer",
            "description": "Distributes traffic across servers"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "app-server",
          "position": {
            "x": 185,
            "y": 280
          },
          "data": {
            "label": "App Server",
            "description": "Handles business logic"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-1",
          "position": {
            "x": 490,
            "y": 560
          },
          "data": {
            "label": "Shard 1",
            "description": "Stores subset of data (partitioned by user ID or hash)."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-2",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Shard 2",
            "description": "Stores another subset of data."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "message-queue",
          "position": {
            "x": 0,
            "y": 560
          },
          "data": {
            "label": "Message Queue",
            "description": "Buffers and processes write requests asynchronously to prevent database overload."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 185,
            "y": 420
          },
          "data": {
            "label": "Cache",
            "description": "Stores frequently accessed data to reduce database load and latency."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "primary-database",
          "position": {
            "x": 250,
            "y": 700
          },
          "data": {
            "label": "Primary Database",
            "description": "Handles writes."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "replica-database",
          "position": {
            "x": 65,
            "y": 840
          },
          "data": {
            "label": "Replica Database",
            "description": "Handles read replication and failover."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        }
      ],
      "edges": [
        {
          "id": "e-client-lb",
          "source": "client",
          "target": "load-balancer"
        },
        {
          "id": "e-lb-app",
          "source": "load-balancer",
          "target": "app-server"
        },
        {
          "id": "e-app-shard1",
          "source": "app-server",
          "target": "shard-1"
        },
        {
          "id": "e-app-shard2",
          "source": "app-server",
          "target": "shard-2"
        },
        {
          "id": "e-app-cache",
          "source": "app-server",
          "target": "cache"
        },
        {
          "id": "e-cache-shard1",
          "source": "cache",
          "target": "shard-1"
        },
        {
          "id": "e-cache-shard2",
          "source": "cache",
          "target": "shard-2"
        },
        {
          "id": "e-app-mq",
          "source": "app-server",
          "target": "message-queue",
          "label": "Write"
        },
        {
          "id": "e-mq-primary",
          "source": "message-queue",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-app-replica",
          "source": "app-server",
          "target": "replica-database",
          "label": "Read"
        },
        {
          "id": "e-shard1-primary",
          "source": "shard-1",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-shard2-primary",
          "source": "shard-2",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-primary-replica",
          "source": "primary-database",
          "target": "replica-database"
        }
      ]
    },
    "design-5-a-web-crawler-lets-design-a-web-crawler-": {
      "nodes": [
        {
          "id": "client",
          "position": {
            "x": 185,
            "y": 0
          },
          "data": {
            "label": "Client",
            "description": "User device making requests"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "load-balancer",
          "position": {
            "x": 185,
            "y": 140
          },
          "data": {
            "label": "Load Balancer",
            "description": "Distributes traffic across servers"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "selected": true
        },
        {
          "id": "app-server",
          "position": {
            "x": 185,
            "y": 280
          },
          "data": {
            "label": "App Server",
            "description": "Handles business logic"
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "selected": false
        },
        {
          "id": "shard-1",
          "position": {
            "x": 490,
            "y": 560
          },
          "data": {
            "label": "Shard 1",
            "description": "Stores subset of data (partitioned by user ID or hash)."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "shard-2",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Shard 2",
            "description": "Stores another subset of data."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "message-queue",
          "position": {
            "x": 0,
            "y": 560
          },
          "data": {
            "label": "Message Queue",
            "description": "Buffers and processes write requests asynchronously to prevent database overload."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "selected": false,
          "dragging": false
        },
        {
          "id": "cache",
          "position": {
            "x": 185,
            "y": 420
          },
          "data": {
            "label": "Cache",
            "description": "Stores frequently accessed data to reduce database load and latency."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          },
          "selected": false,
          "dragging": false
        },
        {
          "id": "primary-database",
          "position": {
            "x": 250,
            "y": 700
          },
          "data": {
            "label": "Primary Database",
            "description": "Handles writes."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        },
        {
          "id": "replica-database",
          "position": {
            "x": 65,
            "y": 840
          },
          "data": {
            "label": "Replica Database",
            "description": "Handles read replication and failover."
          },
          "sourcePosition": "bottom",
          "targetPosition": "top",
          "measured": {
            "width": 150,
            "height": 36
          }
        }
      ],
      "edges": [
        {
          "id": "e-client-lb",
          "source": "client",
          "target": "load-balancer"
        },
        {
          "id": "e-lb-app",
          "source": "load-balancer",
          "target": "app-server"
        },
        {
          "id": "e-app-shard1",
          "source": "app-server",
          "target": "shard-1"
        },
        {
          "id": "e-app-shard2",
          "source": "app-server",
          "target": "shard-2"
        },
        {
          "id": "e-app-cache",
          "source": "app-server",
          "target": "cache"
        },
        {
          "id": "e-cache-shard1",
          "source": "cache",
          "target": "shard-1"
        },
        {
          "id": "e-cache-shard2",
          "source": "cache",
          "target": "shard-2"
        },
        {
          "id": "e-app-mq",
          "source": "app-server",
          "target": "message-queue",
          "label": "Write"
        },
        {
          "id": "e-mq-primary",
          "source": "message-queue",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-app-replica",
          "source": "app-server",
          "target": "replica-database",
          "label": "Read"
        },
        {
          "id": "e-shard1-primary",
          "source": "shard-1",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-shard2-primary",
          "source": "shard-2",
          "target": "primary-database",
          "label": "Write"
        },
        {
          "id": "e-primary-replica",
          "source": "primary-database",
          "target": "replica-database"
        }
      ]
    },
    "analytics-pipeline": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "pubsub",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Pub/Sub",
            "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
            "defaults": {
              "subscriptionFilters": "",
              "retention": "",
              "ackDeadline": "",
              "replay": ""
            },
            "notes": {
              "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
              "keyDecisions": [
                "Configure subscriptionFilters",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "slow consumer lag",
                "fanout amplification"
              ]
            }
          }
        },
        {
          "id": "search-index",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Search Index",
            "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
            "defaults": {
              "analyzers": "",
              "ranking": "",
              "shards": "",
              "replicas": "",
              "refreshInterval": ""
            },
            "notes": {
              "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
              "keyDecisions": [
                "Configure analyzers",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale index",
                "high write amplification"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "scheduler",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "Scheduler",
            "purpose": "Runs periodic jobs (cleanup, compaction, rollups, batch pipelines).",
            "defaults": {
              "interval": "",
              "jitter": "",
              "backfill": "",
              "lock": ""
            },
            "notes": {
              "purpose": "Runs periodic jobs (cleanup, compaction, rollups, batch pipelines).",
              "keyDecisions": [
                "Configure interval",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "double-run without locking",
                "missed runs"
              ]
            }
          }
        },
        {
          "id": "circuit-breaker",
          "position": {
            "x": 250,
            "y": 1520
          },
          "data": {
            "label": "Circuit Breaker",
            "purpose": "Stops calling failing dependencies to prevent cascading failures.",
            "defaults": {
              "errorThreshold": "",
              "openDuration": "",
              "halfOpenProbes": "",
              "fallback": ""
            },
            "notes": {
              "purpose": "Stops calling failing dependencies to prevent cascading failures.",
              "keyDecisions": [
                "Configure errorThreshold",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad thresholds causing flapping",
                "no fallback path"
              ]
            }
          }
        },
        {
          "id": "retry-policy",
          "position": {
            "x": 250,
            "y": 1600
          },
          "data": {
            "label": "Retry Policy",
            "purpose": "Retries transient failures safely using backoff + jitter; must avoid amplification.",
            "defaults": {
              "maxRetries": "",
              "backoff": "",
              "jitter": "",
              "retryBudget": ""
            },
            "notes": {
              "purpose": "Retries transient failures safely using backoff + jitter; must avoid amplification.",
              "keyDecisions": [
                "Configure maxRetries",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "retry storms",
                "retrying non-idempotent ops"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1680
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1760
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "tracing",
          "position": {
            "x": 250,
            "y": 1840
          },
          "data": {
            "label": "Tracing",
            "purpose": "Distributed tracing to understand request paths and latency contributors.",
            "defaults": {
              "sampling": "",
              "propagation": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Distributed tracing to understand request paths and latency contributors.",
              "keyDecisions": [
                "Sample 1‚Äì10% of requests",
                "Propagate trace context across services"
              ],
              "failureModes": [
                "Missing propagation",
                "Sampling hides tail latencies"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1920
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-pubsub",
          "source": "app-service",
          "target": "pubsub"
        },
        {
          "id": "e-9-app-service-search-index",
          "source": "app-service",
          "target": "search-index"
        },
        {
          "id": "e-10-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-11-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-12-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-13-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-14-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-15-app-service-tracing",
          "source": "app-service",
          "target": "tracing"
        },
        {
          "id": "e-16-app-service-circuit-breaker",
          "source": "app-service",
          "target": "circuit-breaker"
        },
        {
          "id": "e-17-app-service-retry-policy",
          "source": "app-service",
          "target": "retry-policy"
        },
        {
          "id": "e-18-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-19-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-20-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-21-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "cache-invalidation": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "cache-invalidation",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Cache Invalidation Stream",
            "purpose": "Propagates invalidation events to caches to keep data fresh.",
            "defaults": {
              "keys": "",
              "batching": "",
              "dedupe": ""
            },
            "notes": {
              "purpose": "Propagates invalidation events to caches to keep data fresh.",
              "keyDecisions": [
                "Configure keys",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "missed invalidations",
                "out-of-order invalidations"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-7-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-8-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-9-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-10-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "chat": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "Auth Service",
            "purpose": "Issues/validates credentials (sessions, tokens); enforces authentication flows.",
            "defaults": {
              "tokenTTL": "",
              "refreshTTL": "",
              "rotation": "",
              "mfa": ""
            },
            "notes": {
              "purpose": "Issues/validates credentials (sessions, tokens); enforces authentication flows.",
              "keyDecisions": [
                "JWT vs session; token refresh flow",
                "Validate on gateway or service mesh"
              ],
              "failureModes": [
                "Token replay if not bound to request",
                "Session store overload"
              ]
            }
          }
        },
        {
          "id": "realtime-gateway",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Realtime Gateway (WebSocket)",
            "purpose": "Maintains WebSocket connections for real-time bidirectional messaging; routes messages to connected clients.",
            "defaults": {
              "connectionTimeout": "",
              "heartbeatInterval": "",
              "maxConnectionsPerInstance": "",
              "stickySessions": ""
            },
            "notes": {
              "purpose": "Maintains WebSocket connections for real-time bidirectional messaging; routes messages to connected clients.",
              "keyDecisions": [
                "Sticky sessions for WebSocket affinity",
                "Heartbeat/keepalive to detect dead connections"
              ],
              "failureModes": [
                "Connection storms on mass reconnect",
                "Stale connections after instance failover"
              ]
            }
          }
        },
        {
          "id": "presence-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "Presence Service",
            "purpose": "Tracks online/offline status of users; supports last-seen, typing indicators, and room membership.",
            "defaults": {
              "heartbeatTTL": "",
              "slidingWindow": "",
              "shardingKey": ""
            },
            "notes": {
              "purpose": "Tracks online/offline status of users; supports last-seen, typing indicators, and room membership.",
              "keyDecisions": [
                "Heartbeat TTL; sliding window for last-seen",
                "Shard by userId for scale"
              ],
              "failureModes": [
                "Stale presence after client crash",
                "Hot keys for popular users"
              ]
            }
          }
        },
        {
          "id": "conversation-service",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Conversation Service",
            "purpose": "Manages conversation metadata: create/archive threads, list conversations, resolve participants.",
            "defaults": {
              "pagination": "",
              "indexStrategy": "",
              "cacheTTL": ""
            },
            "notes": {
              "purpose": "Manages conversation metadata: create/archive threads, list conversations, resolve participants.",
              "keyDecisions": [
                "Index (userId, lastMessageTs) for list",
                "Cache hot conversation metadata"
              ],
              "failureModes": [
                "N+1 queries on list",
                "Hot partitions for active threads"
              ]
            }
          }
        },
        {
          "id": "message-service",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Message Service",
            "purpose": "Handles message send/receive: validate, persist, fanout to realtime and push pipelines.",
            "defaults": {
              "idempotencyKey": "",
              "ordering": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Handles message send/receive: validate, persist, fanout to realtime and push pipelines.",
              "keyDecisions": [
                "Idempotency key per message; partition by conversationId",
                "Fanout: event-log for realtime, queue for push"
              ],
              "failureModes": [
                "Duplicate messages without idempotency",
                "Ordering breaks under partition rebalance"
              ]
            }
          }
        },
        {
          "id": "message-store",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Message Store (Sharded KV/Wide-Column)",
            "purpose": "Durable storage for chat messages; sharded by conversationId or (conversationId, messageId) for scale.",
            "defaults": {
              "partitionKey": "",
              "sortKey": "",
              "ttl": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable storage for chat messages; sharded by conversationId or (conversationId, messageId) for scale.",
              "keyDecisions": [
                "Partition key: conversationId; sort key: messageId or timestamp",
                "Wide-column or KV; TTL for retention"
              ],
              "failureModes": [
                "Hot partition for viral threads",
                "Uneven shard distribution"
              ]
            }
          }
        },
        {
          "id": "conversation-metadata-store",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Conversation Metadata Store",
            "purpose": "Stores conversation metadata: participants, last message timestamp, read receipts.",
            "defaults": {
              "indexes": "",
              "partitionKey": "",
              "cacheLayer": ""
            },
            "notes": {
              "purpose": "Stores conversation metadata: participants, last message timestamp, read receipts.",
              "keyDecisions": [
                "Document or SQL; index for list-by-user",
                "Eventual consistency for read receipts OK"
              ],
              "failureModes": [
                "Hot rows for active conversations",
                "Read-after-write consistency gaps"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "dlq",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Dead Letter Queue",
            "purpose": "Isolates poison messages for inspection and reprocessing without blocking pipelines.",
            "defaults": {
              "maxReceiveCount": "",
              "redrivePolicy": ""
            },
            "notes": {
              "purpose": "Isolates poison messages for inspection and reprocessing without blocking pipelines.",
              "keyDecisions": [
                "Max retries before DLQ; alert on depth",
                "Manual triage and redrive"
              ],
              "failureModes": [
                "Silent accumulation without monitoring",
                "Reprocessing without fix"
              ]
            }
          }
        },
        {
          "id": "notification-service",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Notification Service (Push)",
            "purpose": "Sends push notifications to offline users via APNs/FCM; batches and retries.",
            "defaults": {
              "batchSize": "",
              "retryPolicy": "",
              "deviceTokenRefresh": ""
            },
            "notes": {
              "purpose": "Sends push notifications to offline users via APNs/FCM; batches and retries.",
              "keyDecisions": [
                "Batch payloads; retry with exponential backoff",
                "Refresh device tokens periodically"
              ],
              "failureModes": [
                "Token expiry causes silent drops",
                "Provider rate limits"
              ]
            }
          }
        },
        {
          "id": "object-storage",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Object Storage",
            "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
            "defaults": {
              "storageClass": "",
              "lifecyclePolicy": "",
              "versioning": "",
              "multipartUpload": ""
            },
            "notes": {
              "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
              "keyDecisions": [
                "Presigned URLs for direct upload",
                "Lifecycle policies for archival"
              ],
              "failureModes": [
                "Eventual consistency edge cases",
                "Hot prefix for popular media"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "media-service",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Media Service",
            "purpose": "Handles image/video upload, transcoding, thumbnails; stores in object storage, serves via CDN.",
            "defaults": {
              "presignedUpload": "",
              "transcodingPipeline": "",
              "thumbnailSize": ""
            },
            "notes": {
              "purpose": "Handles image/video upload, transcoding, thumbnails; stores in object storage, serves via CDN.",
              "keyDecisions": [
                "Async transcoding; store original + variants",
                "Thumbnail generation pipeline"
              ],
              "failureModes": [
                "Upload timeout for large files",
                "Transcoding backlog"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1520
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "tracing",
          "position": {
            "x": 250,
            "y": 1600
          },
          "data": {
            "label": "Tracing",
            "purpose": "Distributed tracing to understand request paths and latency contributors.",
            "defaults": {
              "sampling": "",
              "propagation": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Distributed tracing to understand request paths and latency contributors.",
              "keyDecisions": [
                "Sample 1‚Äì10% of requests",
                "Propagate trace context across services"
              ],
              "failureModes": [
                "Missing propagation",
                "Sampling hides tail latencies"
              ]
            }
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-api-gateway",
          "source": "web-app",
          "target": "api-gateway"
        },
        {
          "id": "e-1-api-gateway-edge-rate-limiter",
          "source": "api-gateway",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-load-balancer-l7",
          "source": "edge-rate-limiter",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-3-api-gateway-auth-service",
          "source": "api-gateway",
          "target": "auth-service"
        },
        {
          "id": "e-4-load-balancer-l7-message-service",
          "source": "load-balancer-l7",
          "target": "message-service"
        },
        {
          "id": "e-5-load-balancer-l7-conversation-service",
          "source": "load-balancer-l7",
          "target": "conversation-service"
        },
        {
          "id": "e-6-load-balancer-l7-realtime-gateway",
          "source": "load-balancer-l7",
          "target": "realtime-gateway"
        },
        {
          "id": "e-7-message-service-message-store",
          "source": "message-service",
          "target": "message-store"
        },
        {
          "id": "e-8-message-service-conversation-metadata-store",
          "source": "message-service",
          "target": "conversation-metadata-store"
        },
        {
          "id": "e-9-message-service-event-log",
          "source": "message-service",
          "target": "event-log"
        },
        {
          "id": "e-10-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-11-worker-realtime-gateway",
          "source": "worker",
          "target": "realtime-gateway"
        },
        {
          "id": "e-12-worker-notification-service",
          "source": "worker",
          "target": "notification-service"
        },
        {
          "id": "e-13-worker-dlq",
          "source": "worker",
          "target": "dlq"
        },
        {
          "id": "e-14-realtime-gateway-presence-service",
          "source": "realtime-gateway",
          "target": "presence-service"
        },
        {
          "id": "e-15-message-service-media-service",
          "source": "message-service",
          "target": "media-service"
        },
        {
          "id": "e-16-media-service-object-storage",
          "source": "media-service",
          "target": "object-storage"
        },
        {
          "id": "e-17-media-service-cdn",
          "source": "media-service",
          "target": "cdn"
        },
        {
          "id": "e-18-message-service-metrics",
          "source": "message-service",
          "target": "metrics"
        },
        {
          "id": "e-19-conversation-service-metrics",
          "source": "conversation-service",
          "target": "metrics"
        },
        {
          "id": "e-20-worker-metrics",
          "source": "worker",
          "target": "metrics"
        },
        {
          "id": "e-21-realtime-gateway-metrics",
          "source": "realtime-gateway",
          "target": "metrics"
        },
        {
          "id": "e-22-notification-service-metrics",
          "source": "notification-service",
          "target": "metrics"
        },
        {
          "id": "e-23-message-service-logging",
          "source": "message-service",
          "target": "logging"
        },
        {
          "id": "e-24-message-service-tracing",
          "source": "message-service",
          "target": "tracing"
        }
      ]
    },
    "video-streaming": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "object-storage",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Object Storage",
            "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
            "defaults": {
              "storageClass": "",
              "lifecyclePolicy": "",
              "versioning": "",
              "multipartUpload": ""
            },
            "notes": {
              "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
              "keyDecisions": [
                "Presigned URLs for direct upload",
                "Lifecycle policies for archival"
              ],
              "failureModes": [
                "Eventual consistency edge cases",
                "Hot prefix for popular media"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-9-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        },
        {
          "id": "e-10-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-11-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-12-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-13-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-14-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-15-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-16-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        },
        {
          "id": "e-17-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        }
      ]
    },
    "url-shortener": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-7-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-8-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-9-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-10-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-11-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "ride-sharing": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "pubsub",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Pub/Sub",
            "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
            "defaults": {
              "subscriptionFilters": "",
              "retention": "",
              "ackDeadline": "",
              "replay": ""
            },
            "notes": {
              "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
              "keyDecisions": [
                "Configure subscriptionFilters",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "slow consumer lag",
                "fanout amplification"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-pubsub",
          "source": "app-service",
          "target": "pubsub"
        },
        {
          "id": "e-9-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-10-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-11-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-12-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-13-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-14-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-15-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-16-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "feature-flag": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "pubsub",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Pub/Sub",
            "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
            "defaults": {
              "subscriptionFilters": "",
              "retention": "",
              "ackDeadline": "",
              "replay": ""
            },
            "notes": {
              "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
              "keyDecisions": [
                "Configure subscriptionFilters",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "slow consumer lag",
                "fanout amplification"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1520
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-pubsub",
          "source": "app-service",
          "target": "pubsub"
        },
        {
          "id": "e-9-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-10-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-11-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-12-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-13-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-14-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-15-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-16-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-17-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "file-upload": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "object-storage",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Object Storage",
            "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
            "defaults": {
              "storageClass": "",
              "lifecyclePolicy": "",
              "versioning": "",
              "multipartUpload": ""
            },
            "notes": {
              "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
              "keyDecisions": [
                "Presigned URLs for direct upload",
                "Lifecycle policies for archival"
              ],
              "failureModes": [
                "Eventual consistency edge cases",
                "Hot prefix for popular media"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-6-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-7-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-8-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        },
        {
          "id": "e-9-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-10-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-11-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-12-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-13-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-14-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-15-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-16-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        },
        {
          "id": "e-17-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        }
      ]
    },
    "metrics-logging": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "search-index",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Search Index",
            "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
            "defaults": {
              "analyzers": "",
              "ranking": "",
              "shards": "",
              "replicas": "",
              "refreshInterval": ""
            },
            "notes": {
              "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
              "keyDecisions": [
                "Configure analyzers",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale index",
                "high write amplification"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-search-index",
          "source": "app-service",
          "target": "search-index"
        },
        {
          "id": "e-7-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-8-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-9-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-10-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-11-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "news-feed": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "pubsub",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Pub/Sub",
            "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
            "defaults": {
              "subscriptionFilters": "",
              "retention": "",
              "ackDeadline": "",
              "replay": ""
            },
            "notes": {
              "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
              "keyDecisions": [
                "Configure subscriptionFilters",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "slow consumer lag",
                "fanout amplification"
              ]
            }
          }
        },
        {
          "id": "object-storage",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Object Storage",
            "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
            "defaults": {
              "storageClass": "",
              "lifecyclePolicy": "",
              "versioning": "",
              "multipartUpload": ""
            },
            "notes": {
              "purpose": "Stores large blobs (images/videos/files); durable and cost-effective.",
              "keyDecisions": [
                "Presigned URLs for direct upload",
                "Lifecycle policies for archival"
              ],
              "failureModes": [
                "Eventual consistency edge cases",
                "Hot prefix for popular media"
              ]
            }
          }
        },
        {
          "id": "stream-processor",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Stream Processor",
            "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
            "defaults": {
              "windowing": "",
              "watermarks": "",
              "stateStore": "",
              "checkpointing": ""
            },
            "notes": {
              "purpose": "Processes streams for aggregation, enrichment, windowing; outputs derived streams.",
              "keyDecisions": [
                "Configure windowing",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "late events",
                "state blowups"
              ]
            }
          }
        },
        {
          "id": "data-warehouse",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Data Warehouse (OLAP)",
            "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
            "defaults": {
              "partitioning": "",
              "clustering": "",
              "retention": "",
              "materializedViews": ""
            },
            "notes": {
              "purpose": "Columnar analytics store for BI queries; optimized for scans/aggregations.",
              "keyDecisions": [
                "Configure partitioning",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "expensive scans",
                "bad partitioning"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "kv-store",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Key-Value Store",
            "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
            "defaults": {
              "partitionKey": "",
              "ttl": "",
              "replication": "",
              "consistencyLevel": ""
            },
            "notes": {
              "purpose": "Low-latency lookups by key; great for sessions, counters, mappings.",
              "keyDecisions": [
                "Configure partitionKey",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "hot keys",
                "uneven partitions"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1440
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1520
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1600
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-pubsub",
          "source": "app-service",
          "target": "pubsub"
        },
        {
          "id": "e-9-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-10-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        },
        {
          "id": "e-11-app-service-kv-store",
          "source": "app-service",
          "target": "kv-store"
        },
        {
          "id": "e-12-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-13-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-14-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-15-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-16-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-17-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-18-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        },
        {
          "id": "e-19-app-service-object-storage",
          "source": "app-service",
          "target": "object-storage"
        }
      ]
    },
    "notification": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Queue",
            "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
            "defaults": {
              "visibilityTimeout": "",
              "maxRetries": "",
              "dlq": "",
              "fifo": "",
              "orderingKey": ""
            },
            "notes": {
              "purpose": "Buffers tasks; decouples producers/consumers; smooths spikes.",
              "keyDecisions": [
                "Configure visibilityTimeout",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "backlog growth",
                "duplicate delivery"
              ]
            }
          }
        },
        {
          "id": "worker",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "Worker",
            "purpose": "Consumes async jobs/events; performs background processing.",
            "defaults": {
              "concurrency": "",
              "retries": "",
              "idempotency": "",
              "batchSize": ""
            },
            "notes": {
              "purpose": "Consumes async jobs/events; performs background processing.",
              "keyDecisions": [
                "Idempotent processing; DLQ for poison",
                "Scale consumers with partition count"
              ],
              "failureModes": [
                "Poison messages block partition",
                "Retry storms without backoff"
              ]
            }
          }
        },
        {
          "id": "event-log",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Event Log / Stream",
            "purpose": "Durable ordered log for high-throughput event streaming and replay.",
            "defaults": {
              "partitions": "",
              "replication": "",
              "retention": "",
              "compaction": ""
            },
            "notes": {
              "purpose": "Durable ordered log for high-throughput event streaming and replay.",
              "keyDecisions": [
                "Partition by conversationId for ordering",
                "Retention policy; compaction for deletes"
              ],
              "failureModes": [
                "Hot partition; consumer lag",
                "Rebalancing storms"
              ]
            }
          }
        },
        {
          "id": "pubsub",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Pub/Sub",
            "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
            "defaults": {
              "subscriptionFilters": "",
              "retention": "",
              "ackDeadline": "",
              "replay": ""
            },
            "notes": {
              "purpose": "Broadcasts events to multiple subscribers; decouples publishers from consumers.",
              "keyDecisions": [
                "Configure subscriptionFilters",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "slow consumer lag",
                "fanout amplification"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "scheduler",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Scheduler",
            "purpose": "Runs periodic jobs (cleanup, compaction, rollups, batch pipelines).",
            "defaults": {
              "interval": "",
              "jitter": "",
              "backfill": "",
              "lock": ""
            },
            "notes": {
              "purpose": "Runs periodic jobs (cleanup, compaction, rollups, batch pipelines).",
              "keyDecisions": [
                "Configure interval",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "double-run without locking",
                "missed runs"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-queue",
          "source": "app-service",
          "target": "queue"
        },
        {
          "id": "e-7-app-service-event-log",
          "source": "app-service",
          "target": "event-log"
        },
        {
          "id": "e-8-app-service-pubsub",
          "source": "app-service",
          "target": "pubsub"
        },
        {
          "id": "e-9-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-10-app-service-worker",
          "source": "app-service",
          "target": "worker"
        },
        {
          "id": "e-11-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-12-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-13-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-14-queue-worker",
          "source": "queue",
          "target": "worker"
        },
        {
          "id": "e-15-event-log-worker",
          "source": "event-log",
          "target": "worker"
        },
        {
          "id": "e-16-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "payment": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-7-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-8-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-9-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-10-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "rate-limiter": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-7-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-8-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-9-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-10-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "web-crawler": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "search-index",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Search Index",
            "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
            "defaults": {
              "analyzers": "",
              "ranking": "",
              "shards": "",
              "replicas": "",
              "refreshInterval": ""
            },
            "notes": {
              "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
              "keyDecisions": [
                "Configure analyzers",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale index",
                "high write amplification"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-search-index",
          "source": "app-service",
          "target": "search-index"
        },
        {
          "id": "e-7-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-8-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-9-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-10-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-11-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    },
    "search-autocomplete": {
      "nodes": [
        {
          "id": "web-app",
          "position": {
            "x": 250,
            "y": 0
          },
          "data": {
            "label": "Web App / UI",
            "purpose": "Client-facing UI; calls APIs; manages user interactions.",
            "defaults": {
              "cache": "",
              "prefetch": "",
              "offlineMode": ""
            },
            "notes": {
              "purpose": "Client-facing UI; calls APIs; manages user interactions.",
              "keyDecisions": [
                "Configure cache",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale UI state",
                "over-fetching"
              ]
            }
          }
        },
        {
          "id": "cdn",
          "position": {
            "x": 250,
            "y": 80
          },
          "data": {
            "label": "CDN",
            "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
            "defaults": {
              "cacheTTL": "",
              "cacheKey": "",
              "staleWhileRevalidate": "",
              "purge": "",
              "geoRestrictions": ""
            },
            "notes": {
              "purpose": "Caches and serves static and cacheable dynamic content close to users; reduces origin load.",
              "keyDecisions": [
                "Cache media by content hash or path",
                "Purge on update; stale-while-revalidate"
              ],
              "failureModes": [
                "Cache poisoning",
                "Origin overload on miss spike"
              ]
            }
          }
        },
        {
          "id": "waf",
          "position": {
            "x": 250,
            "y": 160
          },
          "data": {
            "label": "WAF",
            "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
            "defaults": {
              "rules": "",
              "botProtection": "",
              "ipAllowDeny": "",
              "rateRules": ""
            },
            "notes": {
              "purpose": "Blocks common web attacks (SQLi/XSS), bots, and abusive patterns at the edge.",
              "keyDecisions": [
                "Configure rules",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "false positives blocking good traffic",
                "rules drift"
              ]
            }
          }
        },
        {
          "id": "edge-rate-limiter",
          "position": {
            "x": 250,
            "y": 240
          },
          "data": {
            "label": "Rate Limiter",
            "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
            "defaults": {
              "limitKey": "",
              "limits": "",
              "burst": "",
              "window": "",
              "tokenBucket": "",
              "leakyBucket": ""
            },
            "notes": {
              "purpose": "Protects systems from overload and abuse; enforces per-user/IP/API limits.",
              "keyDecisions": [
                "Token bucket or sliding window per user/IP",
                "Distributed state (Redis) for global limits"
              ],
              "failureModes": [
                "Hot keys on limiter storage",
                "Incorrect keying causes unfair limits"
              ]
            }
          }
        },
        {
          "id": "api-gateway",
          "position": {
            "x": 250,
            "y": 320
          },
          "data": {
            "label": "API Gateway",
            "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
            "defaults": {
              "routes": "",
              "auth": "",
              "quotas": "",
              "timeouts": "",
              "payloadLimits": ""
            },
            "notes": {
              "purpose": "Single entry point for APIs; handles routing, auth, quotas, request shaping.",
              "keyDecisions": [
                "Route by path/version; validate auth before backend",
                "Centralize rate limits and request shaping"
              ],
              "failureModes": [
                "SPOF; deploy HA with health checks",
                "Misconfigured routes cause 404/5xx"
              ]
            }
          }
        },
        {
          "id": "load-balancer-l7",
          "position": {
            "x": 250,
            "y": 400
          },
          "data": {
            "label": "Load Balancer (L7)",
            "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
            "defaults": {
              "algorithm": "",
              "healthChecks": "",
              "timeouts": "",
              "connectionDraining": ""
            },
            "notes": {
              "purpose": "Distributes HTTP traffic across healthy instances; supports routing rules.",
              "keyDecisions": [
                "Configure algorithm",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad health checks flapping",
                "uneven load distribution"
              ]
            }
          }
        },
        {
          "id": "app-service",
          "position": {
            "x": 250,
            "y": 480
          },
          "data": {
            "label": "App Service",
            "purpose": "Core business logic service handling requests and orchestrating dependencies.",
            "defaults": {
              "autoscaling": "",
              "timeouts": "",
              "retries": "",
              "circuitBreaker": ""
            },
            "notes": {
              "purpose": "Core business logic service handling requests and orchestrating dependencies.",
              "keyDecisions": [
                "Configure autoscaling",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "dependency timeouts cascading",
                "resource exhaustion"
              ]
            }
          }
        },
        {
          "id": "search-index",
          "position": {
            "x": 250,
            "y": 560
          },
          "data": {
            "label": "Search Index",
            "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
            "defaults": {
              "analyzers": "",
              "ranking": "",
              "shards": "",
              "replicas": "",
              "refreshInterval": ""
            },
            "notes": {
              "purpose": "Supports text search, filtering, ranking; maintains inverted index.",
              "keyDecisions": [
                "Configure analyzers",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale index",
                "high write amplification"
              ]
            }
          }
        },
        {
          "id": "sql-db",
          "position": {
            "x": 250,
            "y": 640
          },
          "data": {
            "label": "SQL Database",
            "purpose": "Relational storage with transactions and strong consistency options.",
            "defaults": {
              "indexes": "",
              "replication": "",
              "partitioning": "",
              "connectionPool": "",
              "isolationLevel": ""
            },
            "notes": {
              "purpose": "Relational storage with transactions and strong consistency options.",
              "keyDecisions": [
                "Configure indexes",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "lock contention",
                "replication lag"
              ]
            }
          }
        },
        {
          "id": "sql-read-replica",
          "position": {
            "x": 250,
            "y": 720
          },
          "data": {
            "label": "SQL Read Replica",
            "purpose": "Scales reads; offloads primary; may have replication lag.",
            "defaults": {
              "replicationMode": "",
              "readRouting": "",
              "lagBudget": ""
            },
            "notes": {
              "purpose": "Scales reads; offloads primary; may have replication lag.",
              "keyDecisions": [
                "Configure replicationMode",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "stale reads due to lag",
                "failover complexity"
              ]
            }
          }
        },
        {
          "id": "cache",
          "position": {
            "x": 250,
            "y": 800
          },
          "data": {
            "label": "Cache",
            "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
            "defaults": {
              "ttl": "",
              "evictionPolicy": "",
              "maxMemory": "",
              "sharding": "",
              "replication": ""
            },
            "notes": {
              "purpose": "Speeds reads and reduces backend load; stores computed/queried data.",
              "keyDecisions": [
                "Cache-aside for conversation/metadata",
                "TTL + invalidation stream for freshness"
              ],
              "failureModes": [
                "Stampede on miss",
                "Stale data after write"
              ]
            }
          }
        },
        {
          "id": "circuit-breaker",
          "position": {
            "x": 250,
            "y": 880
          },
          "data": {
            "label": "Circuit Breaker",
            "purpose": "Stops calling failing dependencies to prevent cascading failures.",
            "defaults": {
              "errorThreshold": "",
              "openDuration": "",
              "halfOpenProbes": "",
              "fallback": ""
            },
            "notes": {
              "purpose": "Stops calling failing dependencies to prevent cascading failures.",
              "keyDecisions": [
                "Configure errorThreshold",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "bad thresholds causing flapping",
                "no fallback path"
              ]
            }
          }
        },
        {
          "id": "retry-policy",
          "position": {
            "x": 250,
            "y": 960
          },
          "data": {
            "label": "Retry Policy",
            "purpose": "Retries transient failures safely using backoff + jitter; must avoid amplification.",
            "defaults": {
              "maxRetries": "",
              "backoff": "",
              "jitter": "",
              "retryBudget": ""
            },
            "notes": {
              "purpose": "Retries transient failures safely using backoff + jitter; must avoid amplification.",
              "keyDecisions": [
                "Configure maxRetries",
                "Follow best practices for scale"
              ],
              "failureModes": [
                "retry storms",
                "retrying non-idempotent ops"
              ]
            }
          }
        },
        {
          "id": "metrics",
          "position": {
            "x": 250,
            "y": 1040
          },
          "data": {
            "label": "Metrics",
            "purpose": "Collects time-series measurements for monitoring and alerting.",
            "defaults": {
              "cardinalityGuards": "",
              "scrapeInterval": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Collects time-series measurements for monitoring and alerting.",
              "keyDecisions": [
                "Cardinality guards; sample high-volume metrics",
                "SLI/SLO dashboards"
              ],
              "failureModes": [
                "High cardinality costs",
                "Missing metrics"
              ]
            }
          }
        },
        {
          "id": "logging",
          "position": {
            "x": 250,
            "y": 1120
          },
          "data": {
            "label": "Logging",
            "purpose": "Stores logs for debugging/auditing; supports search and retention.",
            "defaults": {
              "sampling": "",
              "retention": "",
              "redaction": ""
            },
            "notes": {
              "purpose": "Stores logs for debugging/auditing; supports search and retention.",
              "keyDecisions": [
                "Structured JSON; correlation IDs",
                "Sampling for high-volume paths"
              ],
              "failureModes": [
                "PII leakage",
                "Cost explosion"
              ]
            }
          }
        },
        {
          "id": "tracing",
          "position": {
            "x": 250,
            "y": 1200
          },
          "data": {
            "label": "Tracing",
            "purpose": "Distributed tracing to understand request paths and latency contributors.",
            "defaults": {
              "sampling": "",
              "propagation": "",
              "retention": ""
            },
            "notes": {
              "purpose": "Distributed tracing to understand request paths and latency contributors.",
              "keyDecisions": [
                "Sample 1‚Äì10% of requests",
                "Propagate trace context across services"
              ],
              "failureModes": [
                "Missing propagation",
                "Sampling hides tail latencies"
              ]
            }
          }
        },
        {
          "id": "queue",
          "position": {
            "x": 250,
            "y": 1280
          },
          "data": {
            "label": "queue"
          }
        },
        {
          "id": "auth-service",
          "position": {
            "x": 250,
            "y": 1360
          },
          "data": {
            "label": "auth-service"
          }
        }
      ],
      "edges": [
        {
          "id": "e-0-web-app-waf",
          "source": "web-app",
          "target": "waf"
        },
        {
          "id": "e-1-waf-edge-rate-limiter",
          "source": "waf",
          "target": "edge-rate-limiter"
        },
        {
          "id": "e-2-edge-rate-limiter-api-gateway",
          "source": "edge-rate-limiter",
          "target": "api-gateway"
        },
        {
          "id": "e-3-api-gateway-load-balancer-l7",
          "source": "api-gateway",
          "target": "load-balancer-l7"
        },
        {
          "id": "e-4-load-balancer-l7-app-service",
          "source": "load-balancer-l7",
          "target": "app-service"
        },
        {
          "id": "e-5-app-service-cache",
          "source": "app-service",
          "target": "cache"
        },
        {
          "id": "e-6-app-service-search-index",
          "source": "app-service",
          "target": "search-index"
        },
        {
          "id": "e-7-app-service-sql-db",
          "source": "app-service",
          "target": "sql-db"
        },
        {
          "id": "e-8-app-service-metrics",
          "source": "app-service",
          "target": "metrics"
        },
        {
          "id": "e-9-app-service-logging",
          "source": "app-service",
          "target": "logging"
        },
        {
          "id": "e-10-app-service-tracing",
          "source": "app-service",
          "target": "tracing"
        },
        {
          "id": "e-11-app-service-circuit-breaker",
          "source": "app-service",
          "target": "circuit-breaker"
        },
        {
          "id": "e-12-app-service-retry-policy",
          "source": "app-service",
          "target": "retry-policy"
        },
        {
          "id": "e-13-sql-db-sql-read-replica",
          "source": "sql-db",
          "target": "sql-read-replica"
        },
        {
          "id": "e-14-app-service-cdn",
          "source": "app-service",
          "target": "cdn"
        }
      ]
    }
  },
  "interviewSessions": {
    "interview-design-2-facebook-messenger-lets-design-an-instan": {
      "sessionId": "interview-design-2-facebook-messenger-lets-design-an-instan",
      "currentPackId": "design-2-facebook-messenger-lets-design-an-instan",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771129214840
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771129214840,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "To connect with people and be able to chat and continuous and consistent communication, realiability",
          "ts": 1771129281726
        },
        {
          "role": "interviewer",
          "text": "Imagine traffic spikes 3x during a launch. At 6918K RPS, your cache sits in front of sharded DB. If one cache node fails, what happens to your primary shard? Quantify the impact on DB QPS and p99 latency. Cache failures can cascade to the database. I'm looking for: p99 latency target, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771129281734,
          "focus": null
        },
        {
          "role": "user",
          "text": "I am not sure can you help",
          "ts": 1771129320827
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 6918K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771129320827,
          "focus": null
        },
        {
          "role": "user",
          "text": "not sure",
          "ts": 1771129328440
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 6918K RPS, state expected p99 latency and one thing that could break. Try this: What is your target p99 latency in ms?",
          "ts": 1771129328441,
          "focus": null
        },
        {
          "role": "user",
          "text": "help me",
          "ts": 1771129333487
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 6918K RPS, state expected p99 latency and one thing that could break. Try this: What tradeoff are you explicitly accepting?",
          "ts": 1771129333488,
          "focus": null
        },
        {
          "role": "user",
          "text": "TTL",
          "ts": 1771129337094
        },
        {
          "role": "interviewer",
          "text": "Different angle: Imagine traffic spikes 3x during a launch. At 6918K RPS, your cache sits in front of sharded DB. If one cache node fails, what happens to your primary shard? Quantify the impact on DB QPS and p99 latency. Cache failures can cascade to the database. I'm looking for: p99 latency target, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771129337116,
          "focus": null
        }
      ],
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [
        "imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front of sharded db. if ",
        "different angle: imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front o"
      ],
      "askedQuestionHashes": [
        "imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front of sharded db. if ",
        "different angle: imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front o"
      ],
      "askedTopics": [
        "default",
        "default"
      ],
      "lastQuestionId": "different angle: imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front o",
      "skillEstimate": 0,
      "mode": "COACH",
      "lastTopics": [
        "requirements",
        "default",
        "default"
      ],
      "lastTopicTags": [
        "requirements",
        "default",
        "default"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "TTL",
      "lastUserAnswerSummary": "TTL",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "different angle: imagine traffic spikes 3x during a launch. at 6918k rps, your cache sits in front o",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [
        "Imagine traffic spikes 3x during a launch",
        "Different angle: Imagine traffic spikes 3x during a launch"
      ],
      "coachFollowUpIndex": 3,
      "lastFocus": null
    },
    "interview-design-3-youtube-or-netflix-lets-design-a-video-s": {
      "sessionId": "interview-design-3-youtube-or-netflix-lets-design-a-video-s",
      "currentPackId": "design-3-youtube-or-netflix-lets-design-a-video-s",
      "history": [],
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "pendingQuestion": false
    },
    "interview-design-4-typeahead-suggestion-lets-design-a-real-": {
      "sessionId": "interview-design-4-typeahead-suggestion-lets-design-a-real-",
      "currentPackId": "design-4-typeahead-suggestion-lets-design-a-real-",
      "history": [],
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "pendingQuestion": false
    },
    "interview-design-5-a-web-crawler-lets-design-a-web-crawler-": {
      "sessionId": "interview-design-5-a-web-crawler-lets-design-a-web-crawler-",
      "currentPackId": "design-5-a-web-crawler-lets-design-a-web-crawler-",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771111481365
        },
        {
          "role": "interviewer",
          "text": "Which component would you like to dive deeper into?",
          "ts": 1771111481365
        }
      ],
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "pendingQuestion": false
    },
    "interview-design-1-instagram-lets-design-a-photo-sharing-se": {
      "sessionId": "interview-design-1-instagram-lets-design-a-photo-sharing-se",
      "currentPackId": "design-1-instagram-lets-design-a-photo-sharing-se",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771129147023
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771129147025,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "not sure",
          "ts": 1771129152119
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 1K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771129152121,
          "focus": null
        },
        {
          "role": "user",
          "text": "QPS",
          "ts": 1771129160156
        },
        {
          "role": "interviewer",
          "text": "At 1K RPS, your cache sits in front of sharded DB. If one cache node fails, what happens to your primary shard? Quantify the impact on DB QPS and p99 latency. Cache failures can cascade to the database. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771129160168,
          "focus": null
        },
        {
          "role": "user",
          "text": "ok",
          "ts": 1771129164238
        },
        {
          "role": "interviewer",
          "text": "Assume cache hit rate is 90%. If a cache node fails and hit rate drops to 70%, what happens to DB QPS? (Rough number is fine.)",
          "ts": 1771129164239,
          "focus": null
        },
        {
          "role": "user",
          "text": "I am not sure",
          "ts": 1771129186260
        },
        {
          "role": "interviewer",
          "text": "A cache sits between your app and DB to avoid hitting the database for repeated reads. ‚Ä¢ Think: what happens on cache miss vs hit? ‚Ä¢ Consider: TTL (how stale is OK?) and invalidation on write ‚Ä¢ Failure: if cache dies, all traffic hits DB‚Äîwhat‚Äôs the impact? Worked example: At 1K RPS with 9:1 read ratio: 90% hit rate means 0.1 √ó 1K = DB load. If cache fails, DB sees full 1K RPS. Try this: What TTL would you use for user profiles vs trending content?",
          "ts": 1771129186261,
          "focus": null
        }
      ],
      "askedTopics": [
        "default"
      ],
      "skillEstimate": 0,
      "mode": "COACH",
      "lastQuestionId": "at 1k rps, your cache sits in front of sharded db. if one cache node fails, what happens to your pri",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [
        "at 1k rps, your cache sits in front of sharded db. if one cache node fails, what happens to your pri"
      ],
      "askedQuestionHashes": [
        "at 1k rps, your cache sits in front of sharded db. if one cache node fails, what happens to your pri"
      ],
      "lastTopics": [
        "requirements",
        "default"
      ],
      "lastTopicTags": [
        "requirements",
        "default"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "I am not sure",
      "lastUserAnswerSummary": "QPS",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "at 1k rps, your cache sits in front of sharded db. if one cache node fails, what happens to your pri",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [
        "At 1K RPS, your cache sits in front of sharded DB"
      ],
      "coachFollowUpIndex": 2,
      "lastFocus": null
    },
    "interview-analytics-pipeline": {
      "sessionId": "interview-analytics-pipeline",
      "currentPackId": "analytics-pipeline",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771173688281
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771173688284,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "Cna you help me",
          "ts": 1771173693123
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 1K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771173693125,
          "focus": null
        },
        {
          "role": "user",
          "text": "TTL 10000",
          "ts": 1771173703464
        },
        {
          "role": "interviewer",
          "text": "You have a message queue in the path. At-least-once or exactly-once? How do you handle duplicates? Delivery semantics affect correctness. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771173703479,
          "focus": null
        }
      ],
      "askedTopics": [
        "default"
      ],
      "skillEstimate": 0,
      "mode": "COACH",
      "lastQuestionId": "you have a message queue in the path. at-least-once or exactly-once? how do you handle duplicates?",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [
        "you have a message queue in the path. at-least-once or exactly-once? how do you handle duplicates?"
      ],
      "askedQuestionHashes": [
        "you have a message queue in the path. at-least-once or exactly-once? how do you handle duplicates?"
      ],
      "lastTopics": [
        "requirements",
        "default"
      ],
      "lastTopicTags": [
        "requirements",
        "default"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "TTL 10000",
      "lastUserAnswerSummary": "TTL 10000",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "you have a message queue in the path. at-least-once or exactly-once? how do you handle duplicates?",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [
        "You have a message queue in the path"
      ],
      "coachFollowUpIndex": 1,
      "lastFocus": null
    },
    "interview-cache-invalidation": {
      "sessionId": "interview-cache-invalidation",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-chat": {
      "sessionId": "interview-chat",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-video-streaming": {
      "sessionId": "interview-video-streaming",
      "currentPackId": "video-streaming",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771131112996
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771131112999,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "teach me this whole design",
          "ts": 1771131122633
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 1K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771131122636,
          "focus": null
        }
      ],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "COACH",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [
        "requirements"
      ],
      "lastTopicTags": [
        "requirements"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "teach me this whole design",
      "lastUserAnswerSummary": "[Ready to start]",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 1,
      "lastFocus": null
    },
    "interview-url-shortener": {
      "sessionId": "interview-url-shortener",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-ride-sharing": {
      "sessionId": "interview-ride-sharing",
      "currentPackId": "ride-sharing",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-feature-flag": {
      "sessionId": "interview-feature-flag",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-file-upload": {
      "sessionId": "interview-file-upload",
      "currentPackId": "file-upload",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-metrics-logging": {
      "sessionId": "interview-metrics-logging",
      "currentPackId": "metrics-logging",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771181949144
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771181949148,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "hwy",
          "ts": 1771181951187
        },
        {
          "role": "interviewer",
          "text": "Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store. Explain your choice. Shows operational depth. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771181951200,
          "focus": null
        },
        {
          "role": "user",
          "text": "I am not sure",
          "ts": 1771181961011
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 1K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771181961013,
          "focus": null
        },
        {
          "role": "user",
          "text": "1M",
          "ts": 1771181970194
        },
        {
          "role": "interviewer",
          "text": "Different angle: Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store. Explain your choice. Shows operational depth. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771181970213,
          "focus": null
        },
        {
          "role": "user",
          "text": "failure",
          "ts": 1771181975460
        },
        {
          "role": "interviewer",
          "text": "Different angle: Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store. Explain your choice. Shows operational depth. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771181975478,
          "focus": null
        }
      ],
      "askedTopics": [
        "default",
        "default",
        "default"
      ],
      "skillEstimate": 0,
      "mode": "COACH",
      "lastQuestionId": "different angle: path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice.",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [
        "path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice.",
        "different angle: path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice."
      ],
      "askedQuestionHashes": [
        "path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice.",
        "different angle: path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice."
      ],
      "lastTopics": [
        "requirements",
        "default",
        "default",
        "default"
      ],
      "lastTopicTags": [
        "requirements",
        "default",
        "default",
        "default"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "failure",
      "lastUserAnswerSummary": "failure",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "different angle: path: agent ‚Üí ingest, ingest ‚Üí metrics store. explain your choice.",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [
        "Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store",
        "Different angle: Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store",
        "Different angle: Path: Agent ‚Üí Ingest, Ingest ‚Üí Metrics Store"
      ],
      "coachFollowUpIndex": 1,
      "lastFocus": null
    },
    "interview-news-feed": {
      "sessionId": "interview-news-feed",
      "currentPackId": "news-feed",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771131389860
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771131389861,
          "focus": "requirements"
        }
      ],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [
        "requirements"
      ],
      "lastTopicTags": [
        "requirements"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "[Ready to start]",
      "lastUserAnswerSummary": "[Ready to start]",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": "requirements"
    },
    "interview-notification": {
      "sessionId": "interview-notification",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-payment": {
      "sessionId": "interview-payment",
      "currentPackId": "payment",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-rate-limiter": {
      "sessionId": "interview-rate-limiter",
      "currentPackId": "rate-limiter",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-web-crawler": {
      "sessionId": "interview-web-crawler",
      "currentPackId": "web-crawler",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-search-autocomplete": {
      "sessionId": "interview-search-autocomplete",
      "currentPackId": "search-autocomplete",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1ehpa-xxnirjy": {
      "sessionId": "interview-d-mlq1ehpa-xxnirjy",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1eije-gculyqc": {
      "sessionId": "interview-d-mlq1eije-gculyqc",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1hqlp-ssyjy94": {
      "sessionId": "interview-d-mlq1hqlp-ssyjy94",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1hrcg-mr3s90t": {
      "sessionId": "interview-d-mlq1hrcg-mr3s90t",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1hsap-m2hxks3": {
      "sessionId": "interview-d-mlq1hsap-m2hxks3",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1j6lm-wztdtdw": {
      "sessionId": "interview-d-mlq1j6lm-wztdtdw",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1jarm-1169ypk": {
      "sessionId": "interview-d-mlq1jarm-1169ypk",
      "currentPackId": "metrics-logging",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771298845521
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771298845527,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "Teach me about thiws",
          "ts": 1771298850553
        },
        {
          "role": "interviewer",
          "text": "Each component has tradeoffs: latency vs consistency, cost vs performance. ‚Ä¢ State your choice clearly ‚Ä¢ Give one number (QPS, TTL, p99) ‚Ä¢ Describe one failure mode Worked example: At 1K RPS, state expected p99 latency and one thing that could break. Try this: What metric would you alert on first?",
          "ts": 1771298850555,
          "focus": null
        }
      ],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "COACH",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [
        "requirements"
      ],
      "lastTopicTags": [
        "requirements"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "Teach me about thiws",
      "lastUserAnswerSummary": "[Ready to start]",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 1,
      "lastFocus": null
    },
    "interview-d-mlq1sc1x-yc9v47k": {
      "sessionId": "interview-d-mlq1sc1x-yc9v47k",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1skje-61ps7lh": {
      "sessionId": "interview-d-mlq1skje-61ps7lh",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1snmk-bhiwz1e": {
      "sessionId": "interview-d-mlq1snmk-bhiwz1e",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1t8gk-61i7zx1": {
      "sessionId": "interview-d-mlq1t8gk-61i7zx1",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1vig6-ujk6tod": {
      "sessionId": "interview-d-mlq1vig6-ujk6tod",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq1vjfg-4zqbyc5": {
      "sessionId": "interview-d-mlq1vjfg-4zqbyc5",
      "currentPackId": "pack-1771299402156-design-cache-invalidation-serv",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq21v4m-iwmz3py": {
      "sessionId": "interview-d-mlq21v4m-iwmz3py",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq22lus-4f97nw8": {
      "sessionId": "interview-d-mlq22lus-4f97nw8",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq280v6-8ap8ea4": {
      "sessionId": "interview-d-mlq280v6-8ap8ea4",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2af81-m4ibk31": {
      "sessionId": "interview-d-mlq2af81-m4ibk31",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2ank3-esqnqae": {
      "sessionId": "interview-d-mlq2ank3-esqnqae",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2aohu-zfm4pwn": {
      "sessionId": "interview-d-mlq2aohu-zfm4pwn",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2aoz3-u8ic5dn": {
      "sessionId": "interview-d-mlq2aoz3-u8ic5dn",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2ap34-xr8sxzy": {
      "sessionId": "interview-d-mlq2ap34-xr8sxzy",
      "currentPackId": "web-crawler",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2swyj-xhc4h1x": {
      "sessionId": "interview-d-mlq2swyj-xhc4h1x",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2sx05-3tscwhe": {
      "sessionId": "interview-d-mlq2sx05-3tscwhe",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2symr-wq07ai2": {
      "sessionId": "interview-d-mlq2symr-wq07ai2",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2syni-w79pyxp": {
      "sessionId": "interview-d-mlq2syni-w79pyxp",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2szj1-x6w26i7": {
      "sessionId": "interview-d-mlq2szj1-x6w26i7",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2t4hb-m7lmik2": {
      "sessionId": "interview-d-mlq2t4hb-m7lmik2",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2t6x8-yx6mywn": {
      "sessionId": "interview-d-mlq2t6x8-yx6mywn",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tj1b-r0bozjt": {
      "sessionId": "interview-d-mlq2tj1b-r0bozjt",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tj27-dhvr2jx": {
      "sessionId": "interview-d-mlq2tj27-dhvr2jx",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tkh3-ct976mq": {
      "sessionId": "interview-d-mlq2tkh3-ct976mq",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tlc2-sw5pl4l": {
      "sessionId": "interview-d-mlq2tlc2-sw5pl4l",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tmpm-675ycpc": {
      "sessionId": "interview-d-mlq2tmpm-675ycpc",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tne1-9exf5d3": {
      "sessionId": "interview-d-mlq2tne1-9exf5d3",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tnuw-89glo8f": {
      "sessionId": "interview-d-mlq2tnuw-89glo8f",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tonz-7njg0xs": {
      "sessionId": "interview-d-mlq2tonz-7njg0xs",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tyrd-cnhpgzt": {
      "sessionId": "interview-d-mlq2tyrd-cnhpgzt",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2tzgv-avr19e1": {
      "sessionId": "interview-d-mlq2tzgv-avr19e1",
      "currentPackId": "ride-sharing",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2v93d-nyv2tjw": {
      "sessionId": "interview-d-mlq2v93d-nyv2tjw",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2vaz0-1whihpi": {
      "sessionId": "interview-d-mlq2vaz0-1whihpi",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2wbvl-56ead3u": {
      "sessionId": "interview-d-mlq2wbvl-56ead3u",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2wyre-k2kxqz0": {
      "sessionId": "interview-d-mlq2wyre-k2kxqz0",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2x44o-0vtnqsu": {
      "sessionId": "interview-d-mlq2x44o-0vtnqsu",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2xpgi-0gc77xd": {
      "sessionId": "interview-d-mlq2xpgi-0gc77xd",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2z7j7-rsc9eo7": {
      "sessionId": "interview-d-mlq2z7j7-rsc9eo7",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2z7kb-181gybt": {
      "sessionId": "interview-d-mlq2z7kb-181gybt",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zhm5-gzvk5zk": {
      "sessionId": "interview-d-mlq2zhm5-gzvk5zk",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zhmt-22ahyu2": {
      "sessionId": "interview-d-mlq2zhmt-22ahyu2",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zia4-qay2qwf": {
      "sessionId": "interview-d-mlq2zia4-qay2qwf",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zian-jj599uu": {
      "sessionId": "interview-d-mlq2zian-jj599uu",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zilw-qtay8mm": {
      "sessionId": "interview-d-mlq2zilw-qtay8mm",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zimh-r84a5et": {
      "sessionId": "interview-d-mlq2zimh-r84a5et",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zisj-bch4w4d": {
      "sessionId": "interview-d-mlq2zisj-bch4w4d",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zit4-rcs6aml": {
      "sessionId": "interview-d-mlq2zit4-rcs6aml",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zj0l-4r4kww4": {
      "sessionId": "interview-d-mlq2zj0l-4r4kww4",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zj15-mzb71vj": {
      "sessionId": "interview-d-mlq2zj15-mzb71vj",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zj7z-1dasrpu": {
      "sessionId": "interview-d-mlq2zj7z-1dasrpu",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq2zj8j-sxwkrf6": {
      "sessionId": "interview-d-mlq2zj8j-sxwkrf6",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq3064a-q4u154d": {
      "sessionId": "interview-d-mlq3064a-q4u154d",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq30ik0-ou4epu7": {
      "sessionId": "interview-d-mlq30ik0-ou4epu7",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq31e2q-efcdts3": {
      "sessionId": "interview-d-mlq31e2q-efcdts3",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq32r3j-cs3mup5": {
      "sessionId": "interview-d-mlq32r3j-cs3mup5",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33937-vg876qy": {
      "sessionId": "interview-d-mlq33937-vg876qy",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq339z5-grqghhb": {
      "sessionId": "interview-d-mlq339z5-grqghhb",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33jub-9ksis00": {
      "sessionId": "interview-d-mlq33jub-9ksis00",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33sbs-e20bido": {
      "sessionId": "interview-d-mlq33sbs-e20bido",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33tjb-cyt41ld": {
      "sessionId": "interview-d-mlq33tjb-cyt41ld",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33ulo-lkd3rhh": {
      "sessionId": "interview-d-mlq33ulo-lkd3rhh",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33vh7-yu6xq8h": {
      "sessionId": "interview-d-mlq33vh7-yu6xq8h",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33w8y-1cj70u0": {
      "sessionId": "interview-d-mlq33w8y-1cj70u0",
      "currentPackId": "file-upload",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq33wx0-r8juqzk": {
      "sessionId": "interview-d-mlq33wx0-r8juqzk",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq343kd-j1ttcu4": {
      "sessionId": "interview-d-mlq343kd-j1ttcu4",
      "currentPackId": "file-upload",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq3449c-q9uoz5n": {
      "sessionId": "interview-d-mlq3449c-q9uoz5n",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq347q1-sxuenfo": {
      "sessionId": "interview-d-mlq347q1-sxuenfo",
      "currentPackId": "ride-sharing",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34bjw-930r5x2": {
      "sessionId": "interview-d-mlq34bjw-930r5x2",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34p17-x8a6psr": {
      "sessionId": "interview-d-mlq34p17-x8a6psr",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34ra2-3oma71s": {
      "sessionId": "interview-d-mlq34ra2-3oma71s",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34t5n-buftnyl": {
      "sessionId": "interview-d-mlq34t5n-buftnyl",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34vcw-dx8pij3": {
      "sessionId": "interview-d-mlq34vcw-dx8pij3",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34w7f-0ivrubk": {
      "sessionId": "interview-d-mlq34w7f-0ivrubk",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34wt5-rl71b6i": {
      "sessionId": "interview-d-mlq34wt5-rl71b6i",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34xmt-s17t01y": {
      "sessionId": "interview-d-mlq34xmt-s17t01y",
      "currentPackId": "file-upload",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34y4p-g8dnah8": {
      "sessionId": "interview-d-mlq34y4p-g8dnah8",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34ypn-apqemqa": {
      "sessionId": "interview-d-mlq34ypn-apqemqa",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34zcb-v3rskv1": {
      "sessionId": "interview-d-mlq34zcb-v3rskv1",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq34zv5-u9hne69": {
      "sessionId": "interview-d-mlq34zv5-u9hne69",
      "currentPackId": "pack-1771299341492-design-cache-invalidation-serv",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq350jc-q67ulrd": {
      "sessionId": "interview-d-mlq350jc-q67ulrd",
      "currentPackId": "pack-1771299402156-design-cache-invalidation-serv",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35149-arjmb83": {
      "sessionId": "interview-d-mlq35149-arjmb83",
      "currentPackId": "payment",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq351n4-oeqzd40": {
      "sessionId": "interview-d-mlq351n4-oeqzd40",
      "currentPackId": "rate-limiter",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35dnn-6rf6kve": {
      "sessionId": "interview-d-mlq35dnn-6rf6kve",
      "currentPackId": "ride-sharing",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35jng-t7ljm5s": {
      "sessionId": "interview-d-mlq35jng-t7ljm5s",
      "currentPackId": "search-autocomplete",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35lm8-p1pkil0": {
      "sessionId": "interview-d-mlq35lm8-p1pkil0",
      "currentPackId": "url-shortener",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35nhs-677hj73": {
      "sessionId": "interview-d-mlq35nhs-677hj73",
      "currentPackId": "video-streaming",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35qih-ayizno9": {
      "sessionId": "interview-d-mlq35qih-ayizno9",
      "currentPackId": "web-crawler",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq35yqi-cpa49mh": {
      "sessionId": "interview-d-mlq35yqi-cpa49mh",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq374r1-eh8y0ft": {
      "sessionId": "interview-d-mlq374r1-eh8y0ft",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq39uhd-j9ne3cq": {
      "sessionId": "interview-d-mlq39uhd-j9ne3cq",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlq39ui0-bhij0w5": {
      "sessionId": "interview-d-mlq39ui0-bhij0w5",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwbte-ulay3c4": {
      "sessionId": "interview-d-mlqtwbte-ulay3c4",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwbua-56degdq": {
      "sessionId": "interview-d-mlqtwbua-56degdq",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwd3p-uqwmemj": {
      "sessionId": "interview-d-mlqtwd3p-uqwmemj",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwd48-ygiq9yd": {
      "sessionId": "interview-d-mlqtwd48-ygiq9yd",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwdtl-f6riyz1": {
      "sessionId": "interview-d-mlqtwdtl-f6riyz1",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwdu6-p1mygdl": {
      "sessionId": "interview-d-mlqtwdu6-p1mygdl",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtwmck-00hah49": {
      "sessionId": "interview-d-mlqtwmck-00hah49",
      "currentPackId": "notification",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtx764-v1el89g": {
      "sessionId": "interview-d-mlqtx764-v1el89g",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqtxloc-a6sk2gn": {
      "sessionId": "interview-d-mlqtxloc-a6sk2gn",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7sr8-ko2bq46": {
      "sessionId": "interview-d-mlqu7sr8-ko2bq46",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7ssi-y6mu3w9": {
      "sessionId": "interview-d-mlqu7ssi-y6mu3w9",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7tj2-ytfkhr9": {
      "sessionId": "interview-d-mlqu7tj2-ytfkhr9",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7tjl-a6hcxgd": {
      "sessionId": "interview-d-mlqu7tjl-a6hcxgd",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7w60-udogxzd": {
      "sessionId": "interview-d-mlqu7w60-udogxzd",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7zhh-ijkwarx": {
      "sessionId": "interview-d-mlqu7zhh-ijkwarx",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu7zi6-n23psyf": {
      "sessionId": "interview-d-mlqu7zi6-n23psyf",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu815g-2hyzcpq": {
      "sessionId": "interview-d-mlqu815g-2hyzcpq",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu8flc-q80z48i": {
      "sessionId": "interview-d-mlqu8flc-q80z48i",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu8gyf-du9mw0z": {
      "sessionId": "interview-d-mlqu8gyf-du9mw0z",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu93zi-cx5xzjt": {
      "sessionId": "interview-d-mlqu93zi-cx5xzjt",
      "currentPackId": "pack-1771346990777-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqu9hjo-wh8ouph": {
      "sessionId": "interview-d-mlqu9hjo-wh8ouph",
      "currentPackId": "pack-1771346990777-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxlp11-qa0guiz": {
      "sessionId": "interview-d-mlqxlp11-qa0guiz",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxlp2x-b3qy85n": {
      "sessionId": "interview-d-mlqxlp2x-b3qy85n",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxm2xj-4fdz56s": {
      "sessionId": "interview-d-mlqxm2xj-4fdz56s",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxm2yy-du98uc6": {
      "sessionId": "interview-d-mlqxm2yy-du98uc6",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxmkp3-c19yv8n": {
      "sessionId": "interview-d-mlqxmkp3-c19yv8n",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxmkpr-rtz913r": {
      "sessionId": "interview-d-mlqxmkpr-rtz913r",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxngs8-oi6aasd": {
      "sessionId": "interview-d-mlqxngs8-oi6aasd",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxngsw-ytv4rqk": {
      "sessionId": "interview-d-mlqxngsw-ytv4rqk",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnhek-tooqy7z": {
      "sessionId": "interview-d-mlqxnhek-tooqy7z",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnhfj-2oxj330": {
      "sessionId": "interview-d-mlqxnhfj-2oxj330",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnwok-3vxvv7w": {
      "sessionId": "interview-d-mlqxnwok-3vxvv7w",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnwp8-js0b6dg": {
      "sessionId": "interview-d-mlqxnwp8-js0b6dg",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnyty-07i9w3m": {
      "sessionId": "interview-d-mlqxnyty-07i9w3m",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxnzal-e024l0f": {
      "sessionId": "interview-d-mlqxnzal-e024l0f",
      "currentPackId": "feature-flag",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxo2lm-jpvzg84": {
      "sessionId": "interview-d-mlqxo2lm-jpvzg84",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqxo63h-zjhovth": {
      "sessionId": "interview-d-mlqxo63h-zjhovth",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqy0dp5-jftvr1n": {
      "sessionId": "interview-d-mlqy0dp5-jftvr1n",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlqy0dt0-cct9grd": {
      "sessionId": "interview-d-mlqy0dt0-cct9grd",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlr8kq8d-acr6rmg": {
      "sessionId": "interview-d-mlr8kq8d-acr6rmg",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlr8kq9k-tnkewb6": {
      "sessionId": "interview-d-mlr8kq9k-tnkewb6",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqpzt-j67ysb5": {
      "sessionId": "interview-d-mlrcqpzt-j67ysb5",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqq0q-bc5zkj2": {
      "sessionId": "interview-d-mlrcqq0q-bc5zkj2",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqttb-x9ghlrr": {
      "sessionId": "interview-d-mlrcqttb-x9ghlrr",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqtu1-ja9klsm": {
      "sessionId": "interview-d-mlrcqtu1-ja9klsm",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcquxs-3ag3tsl": {
      "sessionId": "interview-d-mlrcquxs-3ag3tsl",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqvg5-vhgo2dz": {
      "sessionId": "interview-d-mlrcqvg5-vhgo2dz",
      "currentPackId": "cache-invalidation",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqxqn-xpx2um2": {
      "sessionId": "interview-d-mlrcqxqn-xpx2um2",
      "currentPackId": "metrics-logging",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcqz5l-gcyc56n": {
      "sessionId": "interview-d-mlrcqz5l-gcyc56n",
      "currentPackId": "news-feed",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcr12y-4gbbu8e": {
      "sessionId": "interview-d-mlrcr12y-4gbbu8e",
      "currentPackId": "chat",
      "history": [
        {
          "role": "user",
          "text": "[Ready to start]",
          "ts": 1771378056176
        },
        {
          "role": "interviewer",
          "text": "Let's scope this. What are the core use cases and non-negotiables?",
          "ts": 1771378056193,
          "focus": "requirements"
        },
        {
          "role": "user",
          "text": "A big news",
          "ts": 1771378071957
        },
        {
          "role": "interviewer",
          "text": "At 1K RPS, your cache sits in front of DB. If one cache node fails, what happens? Give me DB QPS impact and p99. Cache failures can cascade to the database. I'm looking for: concrete numbers, explicit tradeoff, failure containment strategy, operational awareness",
          "ts": 1771378071984,
          "focus": null
        }
      ],
      "askedTopics": [
        "default"
      ],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "at 1k rps, your cache sits in front of db. if one cache node fails, what happens? give me db qps imp",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {
        "requirements": true
      },
      "askedComponentQuestions": {},
      "askedHashes": [
        "at 1k rps, your cache sits in front of db. if one cache node fails, what happens? give me db qps imp"
      ],
      "askedQuestionHashes": [
        "at 1k rps, your cache sits in front of db. if one cache node fails, what happens? give me db qps imp"
      ],
      "lastTopics": [
        "requirements",
        "default"
      ],
      "lastTopicTags": [
        "requirements",
        "default"
      ],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "A big news",
      "lastUserAnswerSummary": "A big news",
      "lastActionSummary": "Diagram change",
      "lastQuestionHash": "at 1k rps, your cache sits in front of db. if one cache node fails, what happens? give me db qps imp",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [
        "At 1K RPS, your cache sits in front of DB"
      ],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcscoy-8u61qpa": {
      "sessionId": "interview-d-mlrcscoy-8u61qpa",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcsimz-5qonbod": {
      "sessionId": "interview-d-mlrcsimz-5qonbod",
      "currentPackId": "pack-1771378123123-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcsrfh-5vpfpgr": {
      "sessionId": "interview-d-mlrcsrfh-5vpfpgr",
      "currentPackId": "chat",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrcsy4r-0g8uy62": {
      "sessionId": "interview-d-mlrcsy4r-0g8uy62",
      "currentPackId": "pack-1771346990777-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrct0db-lg3l50l": {
      "sessionId": "interview-d-mlrct0db-lg3l50l",
      "currentPackId": "pack-1771378123123-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlrct2yy-hvkq40g": {
      "sessionId": "interview-d-mlrct2yy-hvkq40g",
      "currentPackId": "pack-1771378123123-design-design-a-chat-system-de",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlre2lpy-8davqzu": {
      "sessionId": "interview-d-mlre2lpy-8davqzu",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlre2lqu-1jwow2p": {
      "sessionId": "interview-d-mlre2lqu-1jwow2p",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlsfzxrs-bzhz3zu": {
      "sessionId": "interview-d-mlsfzxrs-bzhz3zu",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlsfzxsu-gbzmekr": {
      "sessionId": "interview-d-mlsfzxsu-gbzmekr",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlso2qjt-kspb3sw": {
      "sessionId": "interview-d-mlso2qjt-kspb3sw",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlso2qkl-w4aum6y": {
      "sessionId": "interview-d-mlso2qkl-w4aum6y",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltpn2q3-ycpsgws": {
      "sessionId": "interview-d-mltpn2q3-ycpsgws",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltpn2r7-roe1com": {
      "sessionId": "interview-d-mltpn2r7-roe1com",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltv5w5j-bzhzxvq": {
      "sessionId": "interview-d-mltv5w5j-bzhzxvq",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltv5w6q-ebzajyb": {
      "sessionId": "interview-d-mltv5w6q-ebzajyb",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltvo08k-aieq5d9": {
      "sessionId": "interview-d-mltvo08k-aieq5d9",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mltvo09p-wlhq8rs": {
      "sessionId": "interview-d-mltvo09p-wlhq8rs",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlu56mev-n4cnz1u": {
      "sessionId": "interview-d-mlu56mev-n4cnz1u",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlu56mgk-rvc84v8": {
      "sessionId": "interview-d-mlu56mgk-rvc84v8",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlu9ykmk-24fvuao": {
      "sessionId": "interview-d-mlu9ykmk-24fvuao",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlv45lh9-jl4o6m5": {
      "sessionId": "interview-d-mlv45lh9-jl4o6m5",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlv45lib-iuectf8": {
      "sessionId": "interview-d-mlv45lib-iuectf8",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlv698xp-kxp3sht": {
      "sessionId": "interview-d-mlv698xp-kxp3sht",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlv698yo-9ymoczi": {
      "sessionId": "interview-d-mlv698yo-9ymoczi",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlwozlho-49hkj2e": {
      "sessionId": "interview-d-mlwozlho-49hkj2e",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlwozlje-8g64qne": {
      "sessionId": "interview-d-mlwozlje-8g64qne",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlwozslx-jq5w4om": {
      "sessionId": "interview-d-mlwozslx-jq5w4om",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlwozsnv-ztuuxp3": {
      "sessionId": "interview-d-mlwozsnv-ztuuxp3",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlx11yld-erjpcta": {
      "sessionId": "interview-d-mlx11yld-erjpcta",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    },
    "interview-d-mlx11ymc-bsgnwss": {
      "sessionId": "interview-d-mlx11ymc-bsgnwss",
      "currentPackId": "analytics-pipeline",
      "history": [],
      "askedTopics": [],
      "skillEstimate": 0,
      "mode": "ASK",
      "lastQuestionId": "",
      "lastDiagramHash": null,
      "lastMeaningfulChangeTs": null,
      "lastChangeEvent": null,
      "pendingQuestion": false,
      "coveredSections": {},
      "askedComponentQuestions": {},
      "askedHashes": [],
      "askedQuestionHashes": [],
      "lastTopics": [],
      "lastTopicTags": [],
      "difficulty": 1,
      "userSkill": 0,
      "lastUserAnswer": "",
      "lastUserAnswerSummary": "",
      "lastActionSummary": "",
      "lastQuestionHash": "",
      "noOpJustifyAttempts": 0,
      "lastAskedQuestions": [],
      "coachFollowUpIndex": 0,
      "lastFocus": null
    }
  }
}